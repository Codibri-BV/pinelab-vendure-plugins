All packages in this project are backend plugins for Vendure. Vendure uses NestJS under the hood.

Make your answer valid for eslint config `recommendedTypeChecked` from `typescript-eslint`.

Tests are written with `Vitest`.

This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where empty lines have been removed, security check has been disabled.

Use the code below as reference when asked to generate code.

# Files

## File: packages/remote-asset-downloader/src/remote-asset-downloader.spec.ts

```typescript
import { it, expect, beforeEach, afterAll } from 'vitest';
import { RemoteAssetDownloader } from './remote-asset-downloader';
import fs from 'fs';
import path from 'path';
import nock from 'nock';
const TEST_DIR = path.join('./dist/public/');
const CACHE_DIR = path.join('./dist/.cache/');
let scope: nock.Scope;
beforeEach(() => {
  scope = nock('https://example.com')
    .persist()
    .get(/\/assets\/.*/)
    .reply(200, Buffer.from('R0lGODlhAQABAAAAACw='));
});
afterAll(() => {
  fs.rmSync(TEST_DIR, { recursive: true, force: true });
  fs.rmSync(CACHE_DIR, { recursive: true, force: true });
  nock.cleanAll();
});
const downloader = new RemoteAssetDownloader({
  publicAssetDirectory: TEST_DIR,
  subDirectory: 'assets',
  cacheDirectory: CACHE_DIR,
  getRemoteUrl: (assetId) => `https://example.com/assets/${assetId}`,
});
it('Downloads new asset', async () => {
  const result = await downloader.getAsset('123', {
    fileName: 'test-image.webp',
  });
  expect(result).toBe('/assets/123_test-image.webp');
  expect(scope.isDone()).toBe(true);
  expect(
    fs.existsSync(path.join(TEST_DIR, 'assets', '123_test-image.webp'))
  ).toBe(true);
  expect(fs.existsSync(path.join(CACHE_DIR, '123_test-image.webp'))).toBe(true);
});
it('Returns existing cached asset', async () => {
  fs.mkdirSync(path.join(CACHE_DIR), { recursive: true });
  const filePath = path.join(CACHE_DIR, '123_existing.webp');
  fs.writeFileSync(filePath, 'existing-content');
  const result = await downloader.getAsset('123', {
    fileName: 'existing.webp',
  });
  expect(result).toBe('/assets/123_existing.webp');
  expect(scope.pendingMocks().length).toBe(1);
});
it('Returns remote URL when downloadRemoteAsset is false', async () => {
  const noDownloadDownloader = new RemoteAssetDownloader({
    publicAssetDirectory: TEST_DIR,
    subDirectory: '/doesnt-matter/',
    cacheDirectory: CACHE_DIR,
    getRemoteUrl: (assetId) => `https://example.com/assets/${assetId}`,
    downloadRemoteAsset: false,
  });
  const result = await noDownloadDownloader.getAsset('123', {
    fileName: 'test.webp',
    transformationArguments: '?resize=200x200',
  });
  expect(result).toBe('https://example.com/assets/123?resize=200x200');
  expect(scope.pendingMocks().length).toBe(1);
});
it('Strips unsafe characters from filename', async () => {
  const result = await downloader.getAsset('123', {
    fileName: 'Test @#$File.webp',
  });
  expect(result).toBe('/assets/123_test____file.webp');
});
```

## File: packages/remote-asset-downloader/src/remote-asset-downloader.ts

```typescript
import fs from 'fs';
import fetch from 'node-fetch';
interface DownloadConfig {
  publicAssetDirectory: string;
  cacheDirectory: string;
  subDirectory: string;
  getRemoteUrl: (assetId: string) => string;
  downloadRemoteAsset?: boolean;
}
interface AssetOptions {
  fileName: string;
  transformationArguments?: string;
}
export class RemoteAssetDownloader {
  constructor(private readonly config: DownloadConfig) {
    config.publicAssetDirectory = this.stripTrailingAndLeadingSlash(
      config.publicAssetDirectory
    );
    config.subDirectory = this.stripTrailingAndLeadingSlash(
      config.subDirectory
    );
    config.cacheDirectory = this.stripTrailingAndLeadingSlash(
      config.cacheDirectory
    );
  }
  async getAsset(
    assetId: string,
    { fileName, transformationArguments }: AssetOptions
  ): Promise<string> {
    let remoteUrl = this.config.getRemoteUrl(assetId);
    if (transformationArguments) {
      remoteUrl += `${transformationArguments}`;
    }
    if (this.config.downloadRemoteAsset === false) {
      return remoteUrl;
    }
    const assetDir = `${this.config.publicAssetDirectory}/${this.config.subDirectory}`;
    const downloadedFileName = this.stripUnsafeCharacters(
      `${assetId}_${fileName}`
    );
    const destinationPath = `${assetDir}/${downloadedFileName}`;
    const storefrontUrl = destinationPath.replace(
      this.config.publicAssetDirectory,
      ''
    );
    const cachedAsset = `${this.config.cacheDirectory}/${downloadedFileName}`;
    fs.mkdirSync(this.config.cacheDirectory, { recursive: true });
    try {
      // Check if we have a cached asset
      fs.accessSync(cachedAsset);
      // Copy file from cache to target location
      fs.copyFileSync(cachedAsset, destinationPath);
      console.log(`Using cached asset from ${cachedAsset}`);
      return storefrontUrl;
    } catch (e) {
      // File doesn't exist
    }
    console.log(
      `No cached asset found in ${cachedAsset}, downloading asset ${remoteUrl}`
    );
    fs.mkdirSync(assetDir, { recursive: true });
    const response = await fetch(remoteUrl);
    if (!response.ok) {
      throw new Error(`Failed to download asset from ${remoteUrl}`);
    }
    const assetData = await response.arrayBuffer();
    fs.writeFileSync(destinationPath, Buffer.from(assetData));
    fs.copyFileSync(destinationPath, cachedAsset);
    return storefrontUrl;
  }
  private stripUnsafeCharacters(str: string): string {
    return str.toLocaleLowerCase().replace(/[^a-zA-Z0-9-_.]/g, '_');
  }
  private stripTrailingAndLeadingSlash(str: string): string {
    const newStr = str.startsWith('/') ? str.slice(1) : str;
    return newStr.endsWith('/') ? newStr.slice(0, -1) : newStr;
  }
}
```

## File: packages/test/src/admin-utils.ts

```typescript
import { Fulfillment } from '@vendure/common/lib/generated-types';
import {
  defaultShippingCalculator,
  defaultShippingEligibilityChecker,
  ID,
} from '@vendure/core';
import { SimpleGraphQLClient } from '@vendure/testing';
import {
  CancelOrder,
  CancelOrderMutation,
  CancelOrderMutationVariables,
  ConfigArgInput,
  CreateCollection,
  CreateCollectionInput,
  CreateCollectionMutation,
  CreateCollectionMutationVariables,
  CreateFulfillment,
  CreatePromotion,
  CreatePromotionMutation,
  CreatePromotionMutationVariables,
  CreateShippingMethod,
  GetVariants,
  GetVariantsQuery,
  LanguageCode,
  Order as OrderGraphql,
  OrderQuery,
  Orders as OrdersGraphql,
  OrdersQuery,
  Promotion,
  UpdateProduct,
  UpdateProductInput,
  UpdateProductMutation,
  UpdateProductVariantInput,
  UpdateProductVariants,
  UpdateProductVariantsMutation,
} from './generated/admin-graphql';
export async function addShippingMethod(
  adminClient: SimpleGraphQLClient,
  fulfillmentHandlerCode: string,
  price = '500'
): Promise<any> {
  await adminClient.asSuperAdmin();
  const { createShippingMethod } = await adminClient.query(
    CreateShippingMethod,
    {
      input: {
        code: 'test-shipping-method',
        fulfillmentHandler: fulfillmentHandlerCode,
        checker: {
          code: defaultShippingEligibilityChecker.code,
          arguments: [
            {
              name: 'orderMinimum',
              value: '0',
            },
          ],
        },
        calculator: {
          code: defaultShippingCalculator.code,
          arguments: [
            {
              name: 'rate',
              value: price,
            },
            {
              name: 'taxRate',
              value: '0',
            },
          ],
        },
        translations: [
          {
            languageCode: LanguageCode.En,
            name: 'test method',
            description: '',
          },
        ],
      },
    }
  );
  return createShippingMethod;
}
export async function fulfill(
  adminClient: SimpleGraphQLClient,
  handlerCode: string,
  items: Array<[variantId: string, quantity: number]>,
  args?: Array<{ name: string; value: string }>
): Promise<Fulfillment> {
  const lines = items.map((item) => ({
    orderLineId: item[0],
    quantity: item[1],
  }));
  const { addFulfillmentToOrder } = await adminClient.query(CreateFulfillment, {
    input: {
      lines,
      handler: {
        code: handlerCode,
        arguments: args ?? {},
      },
    },
  });
  return addFulfillmentToOrder;
}
export async function getOrder(
  adminClient: SimpleGraphQLClient,
  orderId: ID
): Promise<OrderQuery['order']> {
  const { order } = await adminClient.query(OrderGraphql, { id: orderId });
  return order;
}
export async function updateVariants(
  adminClient: SimpleGraphQLClient,
  input: UpdateProductVariantInput[]
): Promise<UpdateProductVariantsMutation['updateProductVariants']> {
  const { updateProductVariants } = await adminClient.query(
    UpdateProductVariants,
    { input }
  );
  return updateProductVariants;
}
export async function updateProduct(
  adminClient: SimpleGraphQLClient,
  input: UpdateProductInput
): Promise<UpdateProductMutation['updateProduct']> {
  const { updateProduct } = await adminClient.query(UpdateProduct, {
    input,
  });
  return updateProduct;
}
export async function createCollection(
  adminClient: SimpleGraphQLClient,
  input: CreateCollectionInput
): Promise<CreateCollectionMutation['createCollection']> {
  const { createCollection } = await adminClient.query<
    CreateCollectionMutation,
    CreateCollectionMutationVariables
  >(CreateCollection, {
    input,
  });
  return createCollection;
}
export async function getAllOrders(
  adminClient: SimpleGraphQLClient
): Promise<OrdersQuery['orders']['items']> {
  const { orders } = await adminClient.query(OrdersGraphql);
  return orders.items;
}
export async function getAllVariants(
  adminClient: SimpleGraphQLClient
): Promise<GetVariantsQuery['productVariants']['items']> {
  const { productVariants } = await adminClient.query<GetVariantsQuery>(
    GetVariants
  );
  return productVariants.items;
}
export async function createPromotion(
  adminClient: SimpleGraphQLClient,
  couponCode: string,
  promotionActionCode: string,
  args: ConfigArgInput[]
): Promise<Promotion> {
  const { createPromotion } = await adminClient.query<
    CreatePromotionMutation,
    CreatePromotionMutationVariables
  >(CreatePromotion, {
    input: {
      translations: [
        {
          languageCode: LanguageCode.En,
          name: couponCode,
        },
      ],
      enabled: true,
      couponCode,
      conditions: [],
      actions: [
        {
          code: promotionActionCode,
          arguments: args,
        },
      ],
      customFields: {},
    },
  });
  return createPromotion as Promotion;
}
export async function cancelOrder(
  adminClient: SimpleGraphQLClient,
  orderWithLines: { id: string; lines: Array<{ id: string; quantity: number }> }
): Promise<CancelOrderMutation['cancelOrder']> {
  const { cancelOrder } = await adminClient.query<
    CancelOrderMutation,
    CancelOrderMutationVariables
  >(CancelOrder, {
    input: {
      orderId: orderWithLines.id,
      lines: orderWithLines.lines.map((line) => ({
        orderLineId: line.id,
        quantity: line.quantity,
      })),
    },
  });
  return cancelOrder;
}
```

## File: packages/test/src/compile-admin-ui.util.ts

```typescript
import fs from 'fs';
import path from 'path';
import {
  AdminUiExtension,
  compileUiExtensions,
} from '@vendure/ui-devkit/compiler';
export default async function getFilesInAdminUiFolder(
  dirname: string,
  uiExtension: AdminUiExtension
): Promise<string[]> {
  fs.rmSync(path.join(dirname, '__admin-ui'), {
    recursive: true,
    force: true,
  });
  await compileUiExtensions({
    outputPath: path.join(dirname, '__admin-ui'),
    extensions: [uiExtension],
  }).compile?.();
  return fs.readdirSync(path.join(dirname, '__admin-ui/dist'));
}
```

## File: packages/test/src/dev-server.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  SqljsInitializer,
  createTestEnvironment,
  registerInitializer,
} from '@vendure/testing';
import { initialData } from './initial-data';
import { testPaymentMethod } from './test-payment-method';
import dotenv from 'dotenv';
(async () => {
  dotenv.config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [],
  });
  const { server } = createTestEnvironment(config);
  await server.init({
    initialData,
    productsCsvPath: './src/products-import.csv',
  });
})();
```

## File: packages/test/src/initial-data.ts

```typescript
import { LanguageCode } from '@vendure/common/lib/generated-types';
import { InitialData } from '@vendure/core';
export const initialData: InitialData = {
  defaultLanguage: LanguageCode.en,
  defaultZone: 'Europe',
  taxRates: [
    { name: 'Standard Tax', percentage: 20 },
    { name: 'Reduced Tax', percentage: 10 },
    { name: 'Zero Tax', percentage: 0 },
  ],
  shippingMethods: [
    { name: 'Standard Shipping', price: 500 },
    { name: 'Express Shipping', price: 1000 },
  ],
  countries: [
    { name: 'Australia', code: 'AU', zone: 'Oceania' },
    { name: 'Austria', code: 'AT', zone: 'Europe' },
    { name: 'Canada', code: 'CA', zone: 'Americas' },
    { name: 'China', code: 'CN', zone: 'Asia' },
    { name: 'South Africa', code: 'ZA', zone: 'Africa' },
    { name: 'United Kingdom', code: 'GB', zone: 'Europe' },
    { name: 'United States of America', code: 'US', zone: 'Americas' },
    { name: 'Nederland', code: 'NL', zone: 'Europe' },
    { name: 'Belgie', code: 'BE', zone: 'Europe' },
  ],
  collections: [
    {
      name: 'Computers',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['computers'], containsAny: false },
        },
      ],
    },
    {
      name: 'Electronics',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['electronics'], containsAny: false },
        },
      ],
    },
  ],
  paymentMethods: [],
};
```

## File: packages/test/src/shop-utils.ts

```typescript
import { ErrorResult, Order } from '@vendure/core';
import { SimpleGraphQLClient } from '@vendure/testing';
import {
  SetBillingAddress,
  AddItemToOrder,
  AddPaymentToOrder,
  AddPaymentToOrderMutation,
  ApplyCouponCode,
  OrderFieldsFragment,
  SetShippingAddress,
  SetShippingAddressMutationVariables,
  SetShippingMethod,
  TransitionToState,
  TransitionToStateMutation,
  TransitionToStateMutationVariables,
  SetBillingAddressMutationVariables,
  GetActiveOrder,
  GetActiveOrderQuery,
} from './generated/shop-graphql';
import { testPaymentMethod } from './test-payment-method';
export async function setAddressAndShipping(
  shopClient: SimpleGraphQLClient,
  shippingMethodId: string | number,
  shippingAddress?: SetShippingAddressMutationVariables,
  billingAddress?: SetBillingAddressMutationVariables
): Promise<void> {
  const finalShippingAddress = shippingAddress ?? {
    input: {
      fullName: 'Martinho Pinelabio',
      streetLine1: 'Verzetsstraat',
      streetLine2: '12a',
      city: 'Liwwa',
      postalCode: '8923CP',
      countryCode: 'NL',
    },
  };
  await shopClient.query(SetShippingAddress, finalShippingAddress);
  if (billingAddress) {
    await shopClient.query(SetBillingAddress, billingAddress);
  }
  await shopClient.query(SetShippingMethod, {
    ids: [shippingMethodId],
  });
}
export async function proceedToArrangingPayment(
  shopClient: SimpleGraphQLClient,
  shippingMethodId: string | number,
  shippingAddress: SetShippingAddressMutationVariables,
  billingAddress?: SetBillingAddressMutationVariables
): Promise<TransitionToStateMutation['transitionOrderToState']> {
  await setAddressAndShipping(
    shopClient,
    shippingMethodId,
    shippingAddress,
    billingAddress
  );
  const result = await shopClient.query<
    TransitionToStateMutation,
    TransitionToStateMutationVariables
  >(TransitionToState, { state: 'ArrangingPayment' });
  return result.transitionOrderToState;
}
export async function addPaymentToOrder(
  shopClient: SimpleGraphQLClient,
  code: string
): Promise<AddPaymentToOrderMutation['addPaymentToOrder']> {
  const { addPaymentToOrder } = await shopClient.query(AddPaymentToOrder, {
    input: {
      method: code,
      metadata: {
        baz: 'quux',
      },
    },
  });
  return addPaymentToOrder;
}
export async function addItem(
  shopClient: SimpleGraphQLClient,
  variantId: string,
  quantity: number
): Promise<Order> {
  const { addItemToOrder } = await shopClient.query(AddItemToOrder, {
    productVariantId: variantId,
    quantity,
  });
  return addItemToOrder;
}
export async function getActiveOrder(
  shopClient: SimpleGraphQLClient
): Promise<GetActiveOrderQuery['activeOrder'] | undefined> {
  const { activeOrder } = await shopClient.query(GetActiveOrder);
  return activeOrder;
}
export async function applyCouponCode(
  shopClient: SimpleGraphQLClient,
  couponCode: string
): Promise<OrderFieldsFragment> {
  const { applyCouponCode } = await shopClient.query(ApplyCouponCode, {
    couponCode,
  });
  return applyCouponCode;
}
export type SettledOrder = Extract<
  AddPaymentToOrderMutation['addPaymentToOrder'],
  { code: any }
>;
export async function createSettledOrder(
  shopClient: SimpleGraphQLClient,
  shippingMethodId: string | number,
  authorizeFirst = true,
  variants: Array<{ id: string; quantity: number }> = [
    { id: 'T_1', quantity: 1 },
    { id: 'T_2', quantity: 2 },
  ],
  billingAddress?: SetBillingAddressMutationVariables,
  shippingAddress?: SetShippingAddressMutationVariables,
  paymentMethodCode: string = testPaymentMethod.code
): Promise<SettledOrder> {
  if (authorizeFirst) {
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
  }
  for (const v of variants) {
    await addItem(shopClient, v.id, v.quantity);
  }
  let orderShippingAddress = shippingAddress;
  if (!orderShippingAddress) {
    orderShippingAddress = {
      input: {
        fullName: 'Martinho Pinelabio',
        streetLine1: 'Verzetsstraat',
        streetLine2: '12a',
        city: 'Liwwa',
        postalCode: '8923CP',
        countryCode: 'NL',
      },
    };
  }
  const res = await proceedToArrangingPayment(
    shopClient,
    shippingMethodId,
    orderShippingAddress,
    billingAddress
  );
  if ((res as ErrorResult)?.errorCode) {
    console.error(JSON.stringify(res));
    throw Error((res as ErrorResult).errorCode);
  }
  const order = await addPaymentToOrder(shopClient, paymentMethodCode);
  if ((order as ErrorResult).errorCode) {
    throw new Error(
      `Failed to create settled order: ${(order as ErrorResult).message}`
    );
  }
  return order as SettledOrder;
}
```

## File: packages/test/src/test-helpers.ts

```typescript
export async function waitFor<T>(
  conditionFn: () => Promise<T | undefined> | T | undefined,
  interval = 100,
  timeout = 10000
) {
  const startTime = Date.now();
  let result: T | undefined;
  let elapsedTime = 0;
  while (elapsedTime < timeout) {
    result = await conditionFn();
    if (result) {
      return result;
    }
    elapsedTime = Date.now() - startTime;
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  throw new Error(`'waitFor()' Failed to resolve a value after ${timeout}ms`);
}
```

## File: packages/test/src/test-payment-method.ts

```typescript
import { LanguageCode, PaymentMethodHandler } from '@vendure/core';
export const testPaymentMethod = new PaymentMethodHandler({
  code: 'test-payment-method',
  description: [
    { languageCode: LanguageCode.en, value: 'Test Payment Method' },
  ],
  args: {},
  createPayment: (ctx, order, amount, args, metadata) => {
    return {
      amount,
      state: 'Settled',
      transactionId: '12345',
      metadata: { public: metadata },
    };
  },
  settlePayment: () => ({
    success: true,
  }),
});
```

## File: packages/util/src/subscription/default-subscription-strategy.ts

```typescript
import { Injector, Order, ProductVariant, RequestContext } from '@vendure/core';
import { Subscription, SubscriptionStrategy } from './subscription-strategy';
export class DefaultSubscriptionStrategy implements SubscriptionStrategy {
  defineSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    order: Order,
    orderLineCustomFields: { [key: string]: any },
    quantity: number
  ): Subscription {
    return this.getSubscriptionForVariant(productVariant);
  }
  isSubscription(ctx: RequestContext, variant: ProductVariant): boolean {
    return true;
  }
  previewSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    customInputs: any
  ): Subscription {
    return this.getSubscriptionForVariant(productVariant);
  }
  private getSubscriptionForVariant(
    productVariant: ProductVariant
  ): Subscription {
    const price = productVariant.listPrice;
    return {
      name: `Subscription ${productVariant.name}`,
      priceIncludesTax: productVariant.listPriceIncludesTax,
      amountDueNow: price,
      recurring: {
        amount: price,
        interval: 'month',
        intervalCount: 1,
        startDate: this.getOneMonthFromNow(),
      },
    };
  }
  private getOneMonthFromNow(): Date {
    const now = new Date();
    return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate(), 12);
  }
}
```

## File: packages/util/src/subscription/subscription-helper.ts

```typescript
import {
  ID,
  Injector,
  Order,
  OrderLine,
  ProductVariant,
  ProductVariantService,
  RequestContext,
  UserInputError,
} from '@vendure/core';
import { ModuleRef } from '@nestjs/core';
import { Subscription, SubscriptionStrategy } from './subscription-strategy';
export interface SubscriptionWithVariantId extends Subscription {
  variantId: ID;
}
export class SubscriptionHelper {
  injector: Injector;
  constructor(
    private loggerCtx: string,
    private moduleRef: ModuleRef,
    private productVariantService: ProductVariantService,
    private strategy: SubscriptionStrategy
  ) {
    this.injector = new Injector(moduleRef);
  }
  async previewSubscription(
    ctx: RequestContext,
    productVariantId: ID,
    customInputs?: any
  ): Promise<SubscriptionWithVariantId[]> {
    const variant = await this.productVariantService.findOne(
      ctx,
      productVariantId
    );
    if (!variant) {
      throw new UserInputError(
        `No product variant with id '${productVariantId}' found`
      );
    }
    if (!(await this.strategy.isSubscription(ctx, variant, this.injector))) {
      return [];
    }
    const subscriptions = await this.strategy.previewSubscription(
      ctx,
      this.injector,
      variant,
      customInputs
    );
    if (Array.isArray(subscriptions)) {
      return subscriptions.map((sub) => ({
        ...sub,
        variantId: variant.id,
      }));
    } else {
      return [
        {
          ...subscriptions,
          variantId: variant.id,
        },
      ];
    }
  }
  async previewSubscriptionsForProduct(
    ctx: RequestContext,
    productId: ID,
    customInputs?: any
  ): Promise<SubscriptionWithVariantId[]> {
    const { items: variants } =
      await this.productVariantService.getVariantsByProductId(ctx, productId);
    if (!variants?.length) {
      throw new UserInputError(`No variants for product '${productId}' found`);
    }
    const subscriptions = await Promise.all(
      variants.map((v) => this.previewSubscription(ctx, v.id, customInputs))
    );
    return subscriptions.flat();
  }
  async getSubscriptionsForOrder(
    ctx: RequestContext,
    order: Order
  ): Promise<(SubscriptionWithVariantId & { orderLineId: ID })[]> {
    const subscriptionOrderLines = await this.getSubscriptionOrderLines(
      ctx,
      order
    );
    const subscriptions = await Promise.all(
      subscriptionOrderLines.map(async (line) => {
        const subs = await this.getSubscriptionsForOrderLine(ctx, line, order);
        return subs.map((sub) => ({
          orderLineId: line.id,
          variantId: line.productVariant.id,
          ...sub,
        }));
      })
    );
    const flattenedSubscriptionsArray = subscriptions.flat();
    flattenedSubscriptionsArray.forEach((subscription) => {
      if (
        !subscription.recurring.amount ||
        subscription.recurring.amount <= 0
      ) {
        throw Error(
          `[${this.loggerCtx}]: Defined subscription for order line ${subscription.variantId} must have a recurring amount greater than 0`
        );
      }
    });
    return flattenedSubscriptionsArray;
  }
  async hasSubscriptions(ctx: RequestContext, order: Order): Promise<boolean> {
    const subscriptionOrderLines = await this.getSubscriptionOrderLines(
      ctx,
      order
    );
    return subscriptionOrderLines.length > 0;
  }
  async getSubscriptionOrderLines(
    ctx: RequestContext,
    order: Order
  ): Promise<OrderLine[]> {
    const subscriptionOrderLines: OrderLine[] = [];
    await Promise.all(
      order.lines.map(async (l) => {
        if (
          await this.strategy.isSubscription(
            ctx,
            l.productVariant,
            new Injector(this.moduleRef)
          )
        ) {
          subscriptionOrderLines.push(l);
        }
      })
    );
    return subscriptionOrderLines;
  }
  async getSubscriptionsForOrderLine(
    ctx: RequestContext,
    orderLine: OrderLine,
    order: Order
  ): Promise<Subscription[]> {
    if (!(await this.isSubscription(ctx, orderLine.productVariant))) {
      return [];
    }
    const subs = await this.strategy.defineSubscription(
      ctx,
      this.injector,
      orderLine.productVariant,
      order,
      orderLine.customFields,
      orderLine.quantity
    );
    if (Array.isArray(subs)) {
      return subs;
    }
    return [subs];
  }
  async isSubscription(
    ctx: RequestContext,
    variant: ProductVariant
  ): Promise<boolean> {
    return this.strategy.isSubscription(ctx, variant, this.injector);
  }
  defineSubscription(
    ctx: RequestContext,
    productVariant: ProductVariant,
    order: Order,
    orderLineCustomFields: { [key: string]: any },
    quantity: number
  ):
    | Promise<Subscription>
    | Subscription
    | Promise<Subscription[]>
    | Subscription[] {
    return this.strategy.defineSubscription(
      ctx,
      this.injector,
      productVariant,
      order,
      orderLineCustomFields,
      quantity
    );
  }
}
```

## File: packages/util/src/subscription/subscription-strategy.ts

```typescript
import {
  ID,
  Injector,
  Order,
  OrderLine,
  ProductVariant,
  RequestContext,
} from '@vendure/core';
export interface Subscription {
  name: string;
  amountDueNow: number;
  priceIncludesTax: boolean;
  recurring: {
    amount: number;
    interval: 'week' | 'month' | 'year';
    intervalCount: number;
    startDate: Date;
    endDate?: Date;
  };
}
export interface SubscriptionStrategy {
  isSubscription(
    ctx: RequestContext,
    variant: ProductVariant,
    injector: Injector
  ): boolean | Promise<boolean>;
  defineSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    order: Order,
    orderLineCustomFields: { [key: string]: any },
    quantity: number
  ):
    | Promise<Subscription>
    | Subscription
    | Promise<Subscription[]>
    | Subscription[];
  previewSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    customInputs?: any
  ):
    | Promise<Subscription>
    | Subscription
    | Promise<Subscription[]>
    | Subscription[];
}
```

## File: packages/util/src/index.ts

```typescript
export * from './order-state-util';
```

## File: packages/util/src/order-state-util.ts

```typescript
import {
  ErrorResult,
  FulfillmentStateTransitionError,
  Order,
  OrderService,
  RequestContext,
} from '@vendure/core';
import {
  AddFulfillmentToOrderResult,
  ConfigurableOperationInput,
  ItemsAlreadyFulfilledError,
} from '@vendure/common/lib/generated-types';
import { Fulfillment } from '@vendure/core/dist/entity/fulfillment/fulfillment.entity';
export async function fulfillAll(
  ctx: RequestContext,
  orderService: OrderService,
  order: Order,
  handler: ConfigurableOperationInput
): Promise<Fulfillment> {
  const lines = order.lines.map((line) => ({
    orderLineId: line.id,
    quantity: line.quantity,
  }));
  const fulfillment = await orderService.createFulfillment(ctx, {
    handler,
    lines,
  });
  if (
    (fulfillment as ItemsAlreadyFulfilledError).errorCode ===
    'ITEMS_ALREADY_FULFILLED_ERROR'
  ) {
    const fulfillments = await orderService.getOrderFulfillments(ctx, order);
    return fulfillments[0];
  }
  throwIfTransitionFailed(fulfillment);
  return fulfillment as Fulfillment;
}
export async function transitionToShipped(
  orderService: OrderService,
  ctx: RequestContext,
  order: Order,
  handler: ConfigurableOperationInput
): Promise<Fulfillment | FulfillmentStateTransitionError> {
  const fulfillment = await fulfillAll(ctx, orderService, order, handler);
  const result = await orderService.transitionFulfillmentToState(
    ctx,
    fulfillment.id,
    'Shipped'
  );
  throwIfTransitionFailed(result);
  return result;
}
export async function transitionToDelivered(
  orderService: OrderService,
  ctx: RequestContext,
  order: Order,
  handler: ConfigurableOperationInput
): Promise<(Fulfillment | FulfillmentStateTransitionError)[]> {
  const shippedResult = await transitionToShipped(
    orderService,
    ctx,
    order,
    handler
  );
  let fulfillments: Fulfillment[] = [];
  if ((shippedResult as FulfillmentStateTransitionError).errorCode) {
    fulfillments = await orderService.getOrderFulfillments(ctx, order);
  } else {
    fulfillments.push(shippedResult as Fulfillment);
  }
  const results: (Fulfillment | FulfillmentStateTransitionError)[] = [];
  for (const fulfillment of fulfillments) {
    const result = await orderService.transitionFulfillmentToState(
      ctx,
      fulfillment.id,
      'Delivered'
    );
    throwIfTransitionFailed(result);
    results.push(result);
  }
  return results;
}
export function throwIfTransitionFailed(
  result:
    | FulfillmentStateTransitionError
    | Fulfillment
    | AddFulfillmentToOrderResult
): void {
  const stateError = result as FulfillmentStateTransitionError;
  if (
    stateError.transitionError &&
    stateError.fromState === stateError.toState
  ) {
    return;
  }
  const error = result as ErrorResult;
  if (error.errorCode) {
    throw error;
  }
}
```

## File: packages/util/src/raw-body.middleware.ts

```typescript
import { raw } from 'body-parser';
import * as http from 'http';
import type { Request } from 'express';
export interface RequestWithRawBody extends Request {
  rawBody: Buffer;
}
export const rawBodyMiddleware = raw({
  type: '*/*',
  verify(
    req: RequestWithRawBody,
    res: http.ServerResponse,
    buf: Buffer,
    encoding: string
  ) {
    if (Buffer.isBuffer(buf)) {
      req.rawBody = Buffer.from(buf);
    }
    return true;
  },
});
```

## File: packages/util/src/superadmin-request-context.ts

```typescript
import {
  Injector,
  Channel,
  RequestContext,
  TransactionalConnection,
  User,
  ConfigService,
} from '@vendure/core';
export async function getSuperadminContextInChannel(
  injector: Injector,
  channel: Channel
): Promise<RequestContext> {
  const connection = injector.get(TransactionalConnection);
  const configService = injector.get(ConfigService);
  const { superadminCredentials } = configService.authOptions;
  const superAdminUser = await connection
    .getRepository(User)
    .findOneOrFail({ where: { identifier: superadminCredentials.identifier } });
  return new RequestContext({
    channel,
    apiType: 'admin',
    isAuthorized: true,
    authorizedAsOwnerOnly: false,
    session: {
      id: '',
      token: '',
      expires: new Date(),
      cacheExpiry: 999999,
      user: {
        id: superAdminUser.id,
        identifier: superAdminUser.identifier,
        verified: true,
        channelPermissions: [],
      },
    },
  });
}
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-admin-resolver.ts

```typescript
import { Args, Mutation, Resolver } from '@nestjs/graphql';
import { Allow, Ctx, Permission, RequestContext } from '@vendure/core';
import { AcceptBlueService } from './accept-blue-service';
import {
  Mutation as GraphqlMutation,
  MutationRefundAcceptBlueTransactionArgs,
  MutationUpdateAcceptBlueSubscriptionArgs,
} from './generated/graphql';
@Resolver()
export class AcceptBlueAdminResolver {
  constructor(private acceptBlueService: AcceptBlueService) {}
  @Mutation()
  @Allow(Permission.UpdateOrder)
  async refundAcceptBlueTransaction(
    @Ctx() ctx: RequestContext,
    @Args()
    { transactionId, amount, cvv2 }: MutationRefundAcceptBlueTransactionArgs
  ): Promise<GraphqlMutation['refundAcceptBlueTransaction']> {
    return await this.acceptBlueService.refund(
      ctx,
      transactionId,
      amount ?? undefined,
      cvv2 ?? undefined
    );
  }
  @Mutation()
  @Allow(Permission.UpdateOrder)
  async updateAcceptBlueSubscription(
    @Ctx() ctx: RequestContext,
    @Args()
    { input }: MutationUpdateAcceptBlueSubscriptionArgs
  ): Promise<GraphqlMutation['updateAcceptBlueSubscription']> {
    return await this.acceptBlueService.updateSubscription(ctx, input);
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-client.spec.ts

```typescript
import { it, expect } from 'vitest';
import { AcceptBlueClient } from './accept-blue-client';
import { AcceptBluePaymentMethodType } from './generated/graphql';
import { AllowedPaymentMethodInput } from '../types';
const API_KEY = 'test-api-key';
const PIN = 'test-pin';
it('should enable all payment methods when all are allowed', () => {
  const client = new AcceptBlueClient(API_KEY, PIN, {
    allowECheck: true,
    allowVisa: true,
    allowMasterCard: true,
    allowAmex: true,
    allowDiscover: true,
    allowGooglePay: true,
    allowApplePay: true,
  });
  const expected: AcceptBluePaymentMethodType[] = [
    'ECheck',
    'Visa',
    'MasterCard',
    'Amex',
    'Discover',
    'GooglePay',
    'ApplePay',
  ];
  expect(client.enabledPaymentMethods).toEqual(
    expect.arrayContaining(expected)
  );
});
it('should only enable specified payment methods', () => {
  const client = new AcceptBlueClient(API_KEY, PIN, {
    allowECheck: true,
    allowVisa: true,
    allowMasterCard: false,
    allowAmex: false,
    allowDiscover: false,
    allowGooglePay: false,
    allowApplePay: false,
  });
  expect(client.enabledPaymentMethods).toEqual(['ECheck', 'Visa']);
  expect(client.enabledPaymentMethods.length).toBe(2);
});
it('should enable no payment methods when none are allowed', () => {
  const client = new AcceptBlueClient(API_KEY, PIN, {
    allowECheck: false,
    allowVisa: false,
    allowMasterCard: false,
    allowAmex: false,
    allowDiscover: false,
    allowGooglePay: false,
    allowApplePay: false,
  });
  expect(client.enabledPaymentMethods).toEqual([]);
});
it.each([
  {
    name: 'allows ECheck when enabled',
    paymentMethod: { payment_method_type: 'check' },
  },
  {
    name: 'allows Visa when enabled',
    paymentMethod: { card_type: 'Visa' },
  },
  {
    name: 'allows Visa when enabled',
    paymentMethod: { card_type: 'Amex' },
  },
  {
    name: 'allows GooglePay when enabled',
    paymentMethod: { source: 'googlepay' },
  },
  {
    name: 'allows ApplePay when enabled',
    paymentMethod: { source: 'applepay' },
  },
])('$name', ({ paymentMethod }) => {
  const client = new AcceptBlueClient(API_KEY, PIN, {
    allowECheck: true,
    allowVisa: true,
    allowMasterCard: true,
    allowAmex: true,
    allowDiscover: true,
    allowGooglePay: true,
    allowApplePay: true,
  });
  expect(() =>
    client.throwIfPaymentMethodNotAllowed(
      paymentMethod as AllowedPaymentMethodInput
    )
  ).not.toThrow();
});
it.each([
  {
    name: 'Throws error for ECheck when disabled',
    paymentMethod: { payment_method_type: 'check' },
  },
  {
    name: 'Throws error for Visa when disabled',
    paymentMethod: { card_type: 'Visa' },
  },
  {
    name: 'Throws error for Amex when disabled',
    paymentMethod: { card_type: 'Amex' },
  },
  {
    name: 'Throws error for GooglePay when disabled',
    paymentMethod: { source: 'googlepay' },
  },
  {
    name: 'Throws error for ApplePay when disabled',
    paymentMethod: { source: 'applepay' },
  },
])('$name', ({ paymentMethod }) => {
  const client = new AcceptBlueClient(API_KEY, PIN, {
    allowECheck: false,
    allowVisa: false,
    allowMasterCard: false,
    allowAmex: false,
    allowDiscover: false,
    allowGooglePay: false,
    allowApplePay: false,
  });
  expect(() =>
    client.throwIfPaymentMethodNotAllowed(
      paymentMethod as AllowedPaymentMethodInput
    )
  ).toThrow();
});
it('should use test endpoint when testMode is true', () => {
  const client = new AcceptBlueClient(API_KEY, PIN, {}, true);
  expect(client.endpoint).toBe('https://api.develop.accept.blue/api/v2/');
});
it('should use production endpoint when testMode is false', () => {
  const client = new AcceptBlueClient(
    API_KEY,
    PIN,
    {
      allowECheck: true,
    },
    false
  );
  expect(client.endpoint).toBe('https://api.accept.blue/api/v2/');
});
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-client.ts

```typescript
import { Logger, UserInputError } from '@vendure/core';
import axios, { AxiosInstance } from 'axios';
import util from 'util';
import { loggerCtx } from '../constants';
import {
  AcceptBlueChargeTransaction,
  AcceptBlueCustomer,
  AcceptBlueCustomerInput,
  AcceptBluePaymentMethod,
  AcceptBlueRecurringSchedule,
  AcceptBlueRecurringScheduleCreateInput,
  AcceptBlueRecurringScheduleTransaction,
  AcceptBlueRecurringScheduleUpdateInput,
  AcceptBlueTransaction,
  AcceptBlueWebhook,
  AcceptBlueWebhookInput,
  AllowedPaymentMethodInput,
  CheckPaymentMethodInput,
  CustomFields,
  EnabledPaymentMethodsArgs,
  NoncePaymentMethodInput,
  AppleOrGooglePayInput,
  SourcePaymentMethodInput,
} from '../types';
import { isSameCard, isSameCheck } from '../util';
import {
  AcceptBluePaymentMethodType,
  AcceptBlueSurcharges,
} from './generated/graphql';
export class AcceptBlueClient {
  readonly endpoint: string;
  readonly instance: AxiosInstance;
  public readonly enabledPaymentMethods: AcceptBluePaymentMethodType[];
  constructor(
    public readonly apiKey: string,
    public readonly pin: string = '',
    enabledPaymentMethodArgs: EnabledPaymentMethodsArgs,
    public readonly testMode?: boolean
  ) {
    if (this.testMode) {
      this.endpoint = 'https:
      Logger.warn(`Using Accept Blue in test mode`, loggerCtx);
    } else {
      this.endpoint = 'https://api.accept.blue/api/v2/';
      Logger.debug(`Using Accept Blue in live mode`, loggerCtx);
    }
    this.instance = axios.create({
      baseURL: `${this.endpoint}`,
      timeout: 20000,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Basic ${Buffer.from(
          `${this.apiKey}:${this.pin}`
        ).toString('base64')}`,
      },
      validateStatus: () => true,
    });
    const enabledPaymentMethods: AcceptBluePaymentMethodType[] = [];
    if (enabledPaymentMethodArgs.allowECheck) {
      enabledPaymentMethods.push('ECheck');
    }
    if (enabledPaymentMethodArgs.allowVisa) {
      enabledPaymentMethods.push('Visa');
    }
    if (enabledPaymentMethodArgs.allowMasterCard) {
      enabledPaymentMethods.push('MasterCard');
    }
    if (enabledPaymentMethodArgs.allowAmex) {
      enabledPaymentMethods.push('Amex');
    }
    if (enabledPaymentMethodArgs.allowDiscover) {
      enabledPaymentMethods.push('Discover');
    }
    if (enabledPaymentMethodArgs.allowGooglePay) {
      enabledPaymentMethods.push('GooglePay');
    }
    if (enabledPaymentMethodArgs.allowApplePay) {
      enabledPaymentMethods.push('ApplePay');
    }
    this.enabledPaymentMethods = enabledPaymentMethods;
  }
  throwIfPaymentMethodNotAllowed(pm: AllowedPaymentMethodInput): void {
    if (
      pm.payment_method_type === 'check' &&
      this.enabledPaymentMethods.includes('ECheck')
    ) {
      return;
    }
    const cardType = pm.card_type;
    if (cardType && this.enabledPaymentMethods.includes(cardType)) {
      return;
    }
    const source = pm.source;
    if (
      source &&
      this.enabledPaymentMethods.map((p) => p.toLowerCase()).includes(source)
    ) {
      return;
    }
    throw new UserInputError(
      `Payment method '${
        pm.card_type ?? pm.source ?? pm.payment_method_type
      }' is not allowed. Allowed methods: ${this.enabledPaymentMethods.join(
        ', '
      )}`
    );
  }
  async getTransaction(id: number): Promise<AcceptBlueChargeTransaction> {
    return await this.request('get', `transactions/${id}`);
  }
  async upsertCustomer(
    emailAddress: string,
    input: AcceptBlueCustomerInput
  ): Promise<AcceptBlueCustomer> {
    const existing = await this.getCustomer(emailAddress);
    if (existing) {
      await this.updateCustomer(existing.id, input).catch((e) => {
        Logger.error(
          `Failed to update customer ${existing.id}: ${e}`,
          loggerCtx
        );
      });
      return existing;
    } else {
      Logger.info(`Creating new customer ${emailAddress}`, loggerCtx);
      return await this.createCustomer(emailAddress, input);
    }
  }
  async getCustomer(
    emailAddress: string
  ): Promise<AcceptBlueCustomer | undefined> {
    const customers = await this.request(
      'get',
      `customers?active=true&customer_number=${emailAddress}`
    );
    if (customers.length > 1) {
      throw Error(
        `Multiple customers found for email '${emailAddress}' in Accept Blue. There should be only one.`
      );
    }
    if (customers[0]) {
      return customers[0];
    }
    return undefined;
  }
  async createCustomer(
    emailAddress: string,
    input: AcceptBlueCustomerInput
  ): Promise<AcceptBlueCustomer> {
    const customer: AcceptBlueCustomerInput = {
      ...input,
      identifier: emailAddress,
      customer_number: emailAddress,
      email: emailAddress,
      active: true,
    };
    const result = await this.request('post', 'customers', customer);
    Logger.info(`Created new customer '${emailAddress}'`, loggerCtx);
    return result;
  }
  async updateCustomer(
    id: number,
    input: AcceptBlueCustomerInput
  ): Promise<AcceptBlueCustomer> {
    const result = await this.request('patch', `customers/${id}`, input);
    Logger.info(`Updated customer '${id}'`, loggerCtx);
    return result;
  }
  async getOrCreatePaymentMethod(
    acceptBlueCustomerId: number,
    input: NoncePaymentMethodInput | CheckPaymentMethodInput
  ): Promise<AcceptBluePaymentMethod> {
    const methods = await this.getPaymentMethods(acceptBlueCustomerId);
    const existing = methods.find((method) => {
      if (
        (input as NoncePaymentMethodInput).source &&
        method.payment_method_type === 'card'
      ) {
        return isSameCard(input as NoncePaymentMethodInput, method);
      } else if (
        (input as CheckPaymentMethodInput).account_number &&
        method.payment_method_type === 'check'
      ) {
        return isSameCheck(input as CheckPaymentMethodInput, method);
      }
      return false;
    });
    if (existing) {
      return existing;
    }
    return await this.createPaymentMethod(acceptBlueCustomerId, input);
  }
  async getRecurringSchedules(
    ids: number[]
  ): Promise<AcceptBlueRecurringSchedule[]> {
    return await Promise.all(
      ids.map(async (id) => this.request('get', `recurring-schedules/${id}`))
    );
  }
  async updateRecurringSchedule(
    id: number,
    input: AcceptBlueRecurringScheduleUpdateInput
  ): Promise<AcceptBlueRecurringSchedule> {
    const formattedInput = {
      ...input,
      amount: input.amount ? input.amount / 100 : undefined,
      next_run_date: input.next_run_date
        ? this.toDateString(input.next_run_date)
        : undefined,
    };
    return await this.request(
      'patch',
      `recurring-schedules/${id}`,
      formattedInput
    );
  }
  async getTransactionsForRecurringSchedule(
    id: number
  ): Promise<AcceptBlueRecurringScheduleTransaction[]> {
    return await this.request('get', `recurring-schedules/${id}/transactions`);
  }
  async getPaymentMethods(
    acceptBlueCustomerId: number
  ): Promise<AcceptBluePaymentMethod[]> {
    const result = await this.request(
      'get',
      `customers/${acceptBlueCustomerId}/payment-methods?limit=100`
    );
    if (!result) {
      return [];
    }
    if (result.length === 100) {
      throw Error(
        `Customer has more than 100 payment methods. Pagination is not implemented yet...`
      );
    }
    return result;
  }
  async getPaymentMethod(
    acceptBlueCustomerId: number,
    paymentMethodId: number
  ): Promise<AcceptBluePaymentMethod | undefined> {
    const result = await this.request(
      'get',
      `payment-methods/${paymentMethodId}`
    );
    if (result.customer_id == acceptBlueCustomerId) {
      return result as AcceptBluePaymentMethod;
    }
  }
  async createPaymentMethod(
    acceptBlueCustomerId: number,
    input:
      | NoncePaymentMethodInput
      | CheckPaymentMethodInput
      | SourcePaymentMethodInput
  ): Promise<AcceptBluePaymentMethod> {
    const result: AcceptBluePaymentMethod = await this.request(
      'post',
      `customers/${acceptBlueCustomerId}/payment-methods`,
      input
    );
    Logger.info(
      `Created payment method '${result.payment_method_type}' (${result.id}) for customer '${result.customer_id}'`,
      loggerCtx
    );
    return result;
  }
  async createRecurringSchedule(
    customerId: number,
    input: AcceptBlueRecurringScheduleCreateInput
  ): Promise<AcceptBlueRecurringSchedule> {
    const result: AcceptBlueRecurringSchedule = await this.request(
      'post',
      `customers/${customerId}/recurring-schedules`,
      {
        ...input,
        amount: input.amount / 100,
        next_run_date: input.next_run_date
          ? this.toDateString(input.next_run_date)
          : undefined,
      }
    );
    Logger.info(
      `Created recurring schedule ${result.id} for customer '${result.customer_id}'`,
      loggerCtx
    );
    return result;
  }
  async createCharge(
    paymentMethodId: number,
    amountInCents: number,
    customFields: CustomFields
  ): Promise<AcceptBlueChargeTransaction> {
    const amount = amountInCents / 100;
    const result = await this.request('post', `transactions/charge`, {
      source: `pm-${paymentMethodId}`,
      amount,
      custom_fields: customFields,
    });
    if (
      result.status === 'Error' ||
      result.status === 'Declined'
    ) {
      throw new Error(
        `One time charge creation failed: ${result.error_message} (${result.error_code})`
      );
    }
    Logger.info(
      `Created charge of '${amount}' with id '${result.transaction.id}'`,
      loggerCtx
    );
    return result;
  }
  async createDigitalWalletCharge(
    input: AppleOrGooglePayInput,
    customFields: CustomFields
  ): Promise<AcceptBlueChargeTransaction> {
    const result = await this.request('post', `transactions/charge`, {
      amount: input.amount,
      source: input.source,
      token: input.token,
      avs_zip: input.avs_zip,
      avs_address: input.avs_address,
      custom_fields: customFields,
    });
    if (
      result.status === 'Error' ||
      result.status === 'Declined'
    ) {
      throw new Error(
        `One time Digital Wallet charge creation failed: ${result.error_message} (${result.error_code})`
      );
    }
    Logger.info(
      `Created Digital Wallet charge of '${input.amount}' with id '${result.transaction?.id}'`,
      loggerCtx
    );
    return result;
  }
  async refund(
    transactionId: number,
    amountToRefundInCents?: number,
    cvv2?: string
  ): Promise<AcceptBlueTransaction> {
    const options: any = {};
    if (amountToRefundInCents) {
      options.amount = amountToRefundInCents / 100;
    }
    if (cvv2) {
      options.cvv2 = cvv2;
    }
    const result = (await this.request('post', `transactions/refund`, {
      reference_number: transactionId,
      ...options,
    })) as AcceptBlueTransaction;
    if (
      result.status === 'Approved' ||
      result.status === 'Partially Approved'
    ) {
      Logger.info(
        `Refunded transaction ${transactionId}. Status: ${result.status}`,
        loggerCtx
      );
    } else {
      Logger.info(
        `Failed to refund transaction ${transactionId}: [${result.error_code}] ${result.error_message}. Status: ${result.status}`,
        loggerCtx
      );
    }
    return result;
  }
  async getSurcharges(): Promise<AcceptBlueSurcharges> {
    return await this.request('get', `surcharge`);
  }
  async createWebhook(
    input: AcceptBlueWebhookInput
  ): Promise<AcceptBlueWebhook> {
    const result = await this.request('post', 'webhooks', input);
    return result;
  }
  async getWebhooks(): Promise<AcceptBlueWebhook[]> {
    const result = await this.request('get', 'webhooks');
    return result;
  }
  async request(
    method: 'get' | 'post' | 'patch' | 'delete',
    path: string,
    data?: any
  ): Promise<any> {
    const result = await this.instance[method](`/${path}`, data);
    if (result.status === 404) {
      Logger.debug(
        `No result found for ${method} to "${path}", returning undefined`,
        loggerCtx
      );
      return undefined;
    }
    if (result.status >= 400) {
      Logger.error(
        `${method} to "${path}" resulted in: ${result.status} (${
          result.statusText
        }): ${util.inspect(result.data)}`,
        loggerCtx,
        util.inspect(result.data)
      );
      throw Error(result.statusText);
    }
    return result.data;
  }
  toDateString(date: Date): string {
    return date.toISOString().split('T')[0];
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-common-resolvers.ts

```typescript
import { Args, Parent, Query, ResolveField, Resolver } from '@nestjs/graphql';
import {
  Ctx,
  Customer,
  EntityHydrator,
  OrderLine,
  RequestContext,
} from '@vendure/core';
import {
  AcceptBlueCardPaymentMethod,
  AcceptBlueCheckPaymentMethod,
  AcceptBluePaymentMethod,
} from '../types';
import { AcceptBlueService } from './accept-blue-service';
import {
  AcceptBluePaymentMethodQuote,
  AcceptBlueSubscription,
  AcceptBlueSurcharges,
  Query as GraphqlQuery,
  QueryPreviewAcceptBlueSubscriptionsArgs,
  QueryPreviewAcceptBlueSubscriptionsForProductArgs,
} from './generated/graphql';
@Resolver()
export class AcceptBlueCommonResolver {
  constructor(
    private readonly acceptBlueService: AcceptBlueService,
    private entityHydrator: EntityHydrator
  ) {}
  @Query()
  async previewAcceptBlueSubscriptions(
    @Ctx() ctx: RequestContext,
    @Args()
    { productVariantId, customInputs }: QueryPreviewAcceptBlueSubscriptionsArgs
  ): Promise<GraphqlQuery['previewAcceptBlueSubscriptions']> {
    const subscriptions =
      await this.acceptBlueService.subscriptionHelper.previewSubscription(
        ctx,
        productVariantId,
        customInputs
      );
    return subscriptions.map((sub) => ({
      ...sub,
      transactions: [],
    }));
  }
  @Query()
  async previewAcceptBlueSubscriptionsForProduct(
    @Ctx() ctx: RequestContext,
    @Args()
    {
      productId,
      customInputs,
    }: QueryPreviewAcceptBlueSubscriptionsForProductArgs
  ): Promise<GraphqlQuery['previewAcceptBlueSubscriptionsForProduct']> {
    const subscriptions =
      await this.acceptBlueService.subscriptionHelper.previewSubscriptionsForProduct(
        ctx,
        productId,
        customInputs
      );
    return subscriptions.map((sub) => ({
      ...sub,
      transactions: [],
    }));
  }
  @ResolveField('acceptBlueHostedTokenizationKey')
  @Resolver('PaymentMethodQuote')
  async acceptBlueHostedTokenizationKey(
    @Ctx() ctx: RequestContext
  ): Promise<string | null> {
    return await this.acceptBlueService.getHostedTokenizationKey(ctx);
  }
  @ResolveField('savedAcceptBluePaymentMethods')
  @Resolver('Customer')
  async savedPaymentMethods(
    @Ctx() ctx: RequestContext,
    @Parent() customer: Customer
  ): Promise<AcceptBluePaymentMethod[]> {
    return await this.acceptBlueService.getSavedPaymentMethods(ctx, customer);
  }
  @ResolveField('acceptBlueSubscriptions')
  @Resolver('OrderLine')
  async acceptBlueSubscriptions(
    @Ctx() ctx: RequestContext,
    @Parent() orderLine: OrderLine
  ): Promise<AcceptBlueSubscription[]> {
    await this.entityHydrator.hydrate(ctx, orderLine, {
      relations: ['productVariant', 'order'],
    });
    return this.acceptBlueService.getSubscriptionsForOrderLine(
      ctx,
      orderLine,
      orderLine.order
    );
  }
  @ResolveField()
  @Resolver('AcceptBluePaymentMethod')
  __resolveType(
    value: AcceptBlueCheckPaymentMethod | AcceptBlueCardPaymentMethod
  ): string {
    return value.payment_method_type === 'card'
      ? 'AcceptBlueCardPaymentMethod'
      : 'AcceptBlueCheckPaymentMethod';
  }
  @Query()
  async eligibleAcceptBluePaymentMethods(
    @Ctx() ctx: RequestContext
  ): Promise<AcceptBluePaymentMethodQuote[]> {
    return this.acceptBlueService.getEligiblePaymentMethods(ctx);
  }
  @Query()
  async acceptBlueSurcharges(
    @Ctx() ctx: RequestContext
  ): Promise<AcceptBlueSurcharges> {
    return await this.acceptBlueService.getSurcharges(ctx);
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-controller.ts

```typescript
import { Controller, Headers, Param, Post, Req } from '@nestjs/common';
import { ChannelService, Logger, RequestContext } from '@vendure/core';
import { Request } from 'express';
import { loggerCtx } from '../constants';
import { AcceptBlueEvent } from '../types';
import { AcceptBlueService } from './accept-blue-service';
import { asError } from 'catch-unknown';
@Controller('accept-blue')
export class AcceptBlueController {
  constructor(
    private channelService: ChannelService,
    private acceptBlueService: AcceptBlueService
  ) {}
  @Post('webhook/:channelToken')
  async events(
    @Param('channelToken') channelToken: string,
    @Req() request: Request,
    @Headers('X-Signature') signature: string
  ) {
    const rawBody = (request as any).rawBody as Buffer;
    const body = JSON.parse(rawBody.toString('utf-8')) as AcceptBlueEvent;
    const ctx = await this.getCtxForChannel(channelToken);
    await this.acceptBlueService
      .handleIncomingWebhook(ctx, body, rawBody, signature)
      .catch((e) => {
        Logger.error(
          `Error handling Accept Blue webhook event: ${asError(e).message}`,
          loggerCtx
        );
        throw e;
      });
  }
  async getCtxForChannel(token: string): Promise<RequestContext> {
    const channel = await this.channelService.getChannelFromToken(token);
    return new RequestContext({
      apiType: 'admin',
      authorizedAsOwnerOnly: false,
      channel,
      isAuthorized: true,
    });
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-handler.ts

```typescript
import { RefundOrderInput } from '@vendure/common/lib/generated-types';
import {
  CreatePaymentResult,
  CreateRefundResult,
  Injector,
  LanguageCode,
  Logger,
  Order,
  Payment,
  PaymentMethodHandler,
  RequestContext,
  SettlePaymentResult,
  UserInputError,
} from '@vendure/core';
import { loggerCtx } from '../constants';
import {
  CheckPaymentMethodInput,
  AppleOrGooglePayInput,
  NoncePaymentMethodInput,
  SavedPaymentMethodInput,
} from '../types';
import {
  isCheckPaymentMethod,
  isGooglePayPaymentMethod as isAppleOrGooglePay,
  isNoncePaymentMethod,
  isSavedPaymentMethod,
} from '../util';
import { AcceptBlueClient } from './accept-blue-client';
import { AcceptBlueService } from './accept-blue-service';
import { asError } from 'catch-unknown';
let service: AcceptBlueService;
export const acceptBluePaymentHandler = new PaymentMethodHandler({
  code: 'accept-blue-payment',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Accept Blue',
    },
  ],
  args: {
    apiKey: {
      type: 'string',
      required: true,
      label: [{ languageCode: LanguageCode.en, value: 'API key' }],
      ui: { component: 'password-form-input' },
    },
    pin: {
      type: 'string',
      required: false,
      label: [{ languageCode: LanguageCode.en, value: 'PIN' }],
      ui: { component: 'password-form-input' },
    },
    allowVisa: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'Visa' }],
    },
    allowMasterCard: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'Master Card' }],
    },
    allowAmex: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'Amex' }],
    },
    allowDiscover: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'Discover' }],
    },
    allowECheck: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'E-check' }],
    },
    allowGooglePay: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'Google Pay' }],
    },
    allowApplePay: {
      type: 'boolean',
      required: false,
      defaultValue: true,
      label: [{ languageCode: LanguageCode.en, value: 'Allow Pay' }],
    },
    tokenizationSourceKey: {
      type: 'string',
      required: false,
      label: [
        { languageCode: LanguageCode.en, value: 'Hosted tokenization key' },
      ],
    },
    webhookSecret: {
      type: 'string',
      required: false,
      label: [{ languageCode: LanguageCode.en, value: 'Webhook secret' }],
      description: [
        {
          languageCode: LanguageCode.en,
          value:
            'Automatically filled when webhooks are created on payment method creation or update.',
        },
      ],
    },
    testMode: {
      type: 'boolean',
      required: false,
      defaultValue: false,
      label: [{ languageCode: LanguageCode.en, value: 'Use test mode' }],
      ui: { component: 'boolean-form-input' },
    },
  },
  init(injector: Injector) {
    service = injector.get(AcceptBlueService);
  },
  async createPayment(
    ctx,
    order,
    amount,
    args,
    metadata
  ): Promise<CreatePaymentResult> {
    if (
      !isNoncePaymentMethod(metadata as NoncePaymentMethodInput) &&
      !isCheckPaymentMethod(metadata as CheckPaymentMethodInput) &&
      !isAppleOrGooglePay(metadata as AppleOrGooglePayInput) &&
      !isSavedPaymentMethod(metadata as SavedPaymentMethodInput)
    ) {
      throw new UserInputError(
        `You either need to provide Nonce, Check or GooglePay input, or a saved payment method ID`
      );
    }
    const input = metadata as
      | CheckPaymentMethodInput
      | NoncePaymentMethodInput
      | SavedPaymentMethodInput
      | AppleOrGooglePayInput;
    const client = new AcceptBlueClient(
      args.apiKey,
      args.pin,
      args,
      args.testMode
    );
    try {
      if (isAppleOrGooglePay(input as AppleOrGooglePayInput)) {
        return await service.handleAppleOrGooglePayment(
          ctx,
          order,
          amount,
          client,
          input as AppleOrGooglePayInput
        );
      } else {
        return await service.handleTraditionalPaymentForOrder(
          ctx,
          order,
          amount,
          client,
          input as NoncePaymentMethodInput | CheckPaymentMethodInput
        );
      }
    } catch (e) {
      const error = asError(e);
      Logger.error(
        `Error settling payment for order '${order.code}': ${error.message}`,
        loggerCtx,
        error.stack
      );
      return {
        amount,
        state: 'Declined',
        errorMessage: error.message,
      };
    }
  },
  settlePayment(): SettlePaymentResult {
    return {
      success: true,
    };
  },
  async createRefund(
    ctx: RequestContext,
    input: RefundOrderInput,
    amount: number,
    order: Order,
    payment: Payment
  ): Promise<CreateRefundResult> {
    const transactionId = Number(payment.transactionId);
    const refundResult = await service.refund(ctx, transactionId, input.amount);
    if (refundResult.errorCode) {
      return {
        state: 'Failed',
        transactionId: String(refundResult.referenceNumber),
        metadata: refundResult,
      };
    }
    return {
      state: 'Settled',
      transactionId: String(refundResult.referenceNumber),
      metadata: refundResult,
    };
  },
});
```

## File: packages/vendure-plugin-accept-blue/src/api/accept-blue-service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  Customer,
  CustomerService,
  EntityHydrator,
  EventBus,
  ForbiddenError,
  ID,
  Logger,
  Order,
  OrderLine,
  OrderService,
  PaymentMethod,
  PaymentMethodEvent,
  PaymentMethodService,
  ProductVariantService,
  RequestContext,
  TransactionalConnection,
  UserInputError,
} from '@vendure/core';
import { asError } from 'catch-unknown';
import crypto from 'node:crypto';
import { filter } from 'rxjs';
import { In } from 'typeorm';
import * as util from 'util';
import { SubscriptionHelper } from '../';
import { AcceptBluePluginOptions } from '../accept-blue-plugin';
import { PLUGIN_INIT_OPTIONS, loggerCtx } from '../constants';
import { AcceptBlueSubscriptionEvent } from '../events/accept-blue-subscription-event';
import { AcceptBlueTransactionEvent } from '../events/accept-blue-transaction-event';
import {
  AcceptBlueChargeTransaction,
  AcceptBlueCustomerInput,
  AcceptBlueEvent,
  AcceptBluePaymentMethod,
  AcceptBlueRecurringSchedule,
  AcceptBlueRecurringScheduleTransaction,
  CheckPaymentMethodInput,
  EnabledPaymentMethodsArgs,
  AppleOrGooglePayInput,
  HandlePaymentResult,
  NoncePaymentMethodInput,
  SavedPaymentMethodInput,
} from '../types';
import {
  getNrOfBillingCyclesLeft,
  isSavedPaymentMethod,
  isToday,
  toAcceptBlueFrequency,
  toGraphqlRefundStatus,
  toSubscriptionInterval,
} from '../util';
import { AcceptBlueClient } from './accept-blue-client';
import { acceptBluePaymentHandler } from './accept-blue-handler';
import {
  AcceptBluePaymentMethodQuote,
  AcceptBlueRefundResult,
  AcceptBlueSubscription,
  AcceptBlueSurcharges,
  AcceptBlueTransaction,
  UpdateAcceptBlueSubscriptionInput,
} from './generated/graphql';
@Injectable()
export class AcceptBlueService implements OnApplicationBootstrap {
  constructor(
    productVariantService: ProductVariantService,
    private readonly paymentMethodService: PaymentMethodService,
    private readonly customerService: CustomerService,
    private readonly entityHydrator: EntityHydrator,
    private readonly orderService: OrderService,
    private readonly connection: TransactionalConnection,
    private eventBus: EventBus,
    moduleRef: ModuleRef,
    @Inject(PLUGIN_INIT_OPTIONS)
    private readonly options: AcceptBluePluginOptions
  ) {
    this.subscriptionHelper = new SubscriptionHelper(
      loggerCtx,
      moduleRef,
      productVariantService,
      this.options.subscriptionStrategy
    );
  }
  readonly subscriptionHelper: SubscriptionHelper;
  onApplicationBootstrap() {
    this.eventBus
      .ofType(PaymentMethodEvent)
      .pipe(
        filter(
          (data) => data.entity.handler?.code === acceptBluePaymentHandler.code
        )
      )
      .subscribe(({ ctx, entity }) => {
        this.registerWebhook(ctx, entity).catch((err) => {
          Logger.error(
            `Failed to register webhook: ${asError(err).message}`,
            loggerCtx,
            util.inspect(err)
          );
        });
      });
  }
  async registerWebhook(ctx: RequestContext, paymentMethod: PaymentMethod) {
    const client = await this.getClientForChannel(ctx);
    const webhookUrl = `${this.options.vendureHost}/accept-blue/webhook/${ctx.channel.token}`;
    const existingHooks = await client.getWebhooks();
    const existingHook = existingHooks.find(
      (hook) => hook.webhook_url === webhookUrl
    );
    let webhookSecret: string;
    if (existingHook) {
      Logger.info(`Webhook for this server is already registered`, loggerCtx);
      webhookSecret = existingHook.signature;
    } else {
      const webhook = await client.createWebhook({
        webhook_url: webhookUrl,
        description: 'Notify Vendure of any events on the Accept Blue platform',
        active: true,
      });
      webhookSecret = webhook.signature;
    }
    const signatureArg = paymentMethod.handler.args.find(
      (a) => a.name === 'webhookSecret'
    );
    if (signatureArg) {
      signatureArg.value = webhookSecret;
    } else {
      paymentMethod.handler.args.push({
        name: 'webhookSecret',
        value: webhookSecret,
      });
    }
    await this.connection.getRepository(ctx, PaymentMethod).save(paymentMethod);
    Logger.info(
      `The AcceptBlue PaymentMethod (${paymentMethod.code})'s webhook signature has been updated`,
      loggerCtx
    );
  }
  async getOrCreateCustomerForOrder(
    ctx: RequestContext,
    client: AcceptBlueClient,
    order: Order
  ): Promise<number> {
    if (!order.customer) {
      throw new UserInputError(`Order must have a customer`);
    }
    if (!ctx.activeUserId) {
      throw new UserInputError(
        `We can only handle Accept Blue payments for logged in users, because we need to save the payment methods on Accept Blue customers`
      );
    }
    const acceptBlueCustomer = await client.upsertCustomer(
      order.customer.emailAddress,
      this.mapToAcceptBlueCustomerInput(order, order.customer)
    );
    await this.customerService.update(ctx, {
      id: order.customer?.id,
      customFields: { acceptBlueCustomerId: acceptBlueCustomer.id },
    });
    return acceptBlueCustomer.id;
  }
  async handleTraditionalPaymentForOrder(
    ctx: RequestContext,
    order: Order,
    amount: number,
    client: AcceptBlueClient,
    input:
      | NoncePaymentMethodInput
      | CheckPaymentMethodInput
      | SavedPaymentMethodInput
  ): Promise<HandlePaymentResult> {
    const acceptBlueCustomerId = await this.getOrCreateCustomerForOrder(
      ctx,
      client,
      order
    );
    let paymentMethod: AcceptBluePaymentMethod;
    if (isSavedPaymentMethod(input as SavedPaymentMethodInput)) {
      const foundMethod = await client.getPaymentMethod(
        acceptBlueCustomerId,
        (input as SavedPaymentMethodInput).paymentMethodId
      );
      if (!foundMethod) {
        throw new UserInputError(
          `No Accept Blue payment method found with id ${
            (input as SavedPaymentMethodInput).paymentMethodId
          }`
        );
      }
      paymentMethod = foundMethod;
    } else {
      paymentMethod = await client.getOrCreatePaymentMethod(
        acceptBlueCustomerId,
        input as NoncePaymentMethodInput | CheckPaymentMethodInput
      );
    }
    client.throwIfPaymentMethodNotAllowed(paymentMethod);
    await this.createRecurringSchedule(ctx, order, client, paymentMethod.id);
    let chargeTransaction: AcceptBlueChargeTransaction | undefined;
    if (amount > 0) {
      const subscriptionOrderLines =
        await this.subscriptionHelper.getSubscriptionOrderLines(ctx, order);
      chargeTransaction = await client.createCharge(paymentMethod.id, amount, {
        custom1: JSON.stringify(subscriptionOrderLines.map((l) => l.id)),
      });
    }
    const chargeTransactionId = chargeTransaction?.transaction?.id;
    Logger.info(
      `Settled payment for order '${order.code}', for Accept Blue customer '${acceptBlueCustomerId}' and one time charge transaction '${chargeTransactionId}'`,
      loggerCtx
    );
    return {
      amount,
      state: 'Settled',
      transactionId: chargeTransactionId
        ? String(chargeTransactionId)
        : undefined,
      metadata: chargeTransaction,
    };
  }
  async handleAppleOrGooglePayment(
    ctx: RequestContext,
    order: Order,
    amount: number,
    client: AcceptBlueClient,
    input: AppleOrGooglePayInput
  ): Promise<HandlePaymentResult> {
    client.throwIfPaymentMethodNotAllowed(input);
    const googleAmountInCents = input.amount * 100;
    if (amount !== googleAmountInCents) {
      throw new UserInputError(
        `Amount in Google Pay payment method does not match the order amount. Expected '${amount}', got '${googleAmountInCents}' from the Google Pay payment`
      );
    }
    const subscriptionOrderLines =
      await this.subscriptionHelper.getSubscriptionOrderLines(ctx, order);
    const chargeTransaction = await client.createDigitalWalletCharge(input, {
      custom1: JSON.stringify(subscriptionOrderLines.map((l) => l.id)),
    });
    const acceptBlueCustomerId = await this.getOrCreateCustomerForOrder(
      ctx,
      client,
      order
    );
    const acceptBluePaymentMethod = await client.createPaymentMethod(
      acceptBlueCustomerId,
      {
        source: `ref-${chargeTransaction.reference_number}`,
      }
    );
    await this.createRecurringSchedule(
      ctx,
      order,
      client,
      acceptBluePaymentMethod.id
    );
    Logger.info(
      `Settled payment for order '${order.code}' with '${input.source}', for Accept Blue customer '${acceptBlueCustomerId}' and one time charge transaction '${chargeTransaction.transaction?.id}'`,
      loggerCtx
    );
    return {
      amount,
      state: 'Settled',
      transactionId: chargeTransaction.transaction?.id
        ? String(chargeTransaction.transaction.id)
        : undefined,
      metadata: chargeTransaction,
    };
  }
  async getEligiblePaymentMethods(
    ctx: RequestContext
  ): Promise<AcceptBluePaymentMethodQuote[]> {
    const client = await this.getClientForChannel(ctx);
    return client.enabledPaymentMethods.map((pm) => ({
      name: pm,
    }));
  }
  async createRecurringSchedule(
    ctx: RequestContext,
    order: Order,
    client: AcceptBlueClient,
    paymentMethodId: number
  ): Promise<AcceptBlueRecurringSchedule[]> {
    if (!order.customer) {
      throw new UserInputError(
        `Order must have a customer before creating a payment`
      );
    }
    if (!order.customer.user) {
      throw new UserInputError(
        `Saved payment methods can only be used for registered customers, ${order.customer.emailAddress} (customer ID ${order.customer.id}) is not a registered customer`
      );
    }
    const acceptBlueCustomer = await client.getCustomer(
      order.customer.emailAddress
    );
    if (!acceptBlueCustomer) {
      throw new UserInputError(
        `No customer found in Accept bBlue with email ${order.customer.emailAddress} not found`
      );
    }
    const subscriptionDefinitions = (
      await this.subscriptionHelper.getSubscriptionsForOrder(ctx, order)
    ).map((subscription) => {
      const {
        recurring: { startDate, endDate },
      } = subscription;
      const frequency = toAcceptBlueFrequency(subscription);
      const billingCyclesLeft = endDate
        ? getNrOfBillingCyclesLeft(startDate, endDate, frequency)
        : 0;
      const nextRunDate = isToday(startDate) ? undefined : startDate;
      return {
        ...subscription,
        frequency,
        billingCyclesLeft,
        nextRunDate,
      };
    });
    const subscriptionsPerOrderLine = new Map<ID, number[]>();
    const recurringSchedules: AcceptBlueRecurringSchedule[] = [];
    for (const subscriptionDefinition of subscriptionDefinitions) {
      const recurringSchedule = await client.createRecurringSchedule(
        acceptBlueCustomer.id,
        {
          title: subscriptionDefinition.name,
          active: true,
          amount: subscriptionDefinition.recurring.amount,
          frequency: subscriptionDefinition.frequency,
          num_left: subscriptionDefinition.billingCyclesLeft,
          payment_method_id: paymentMethodId,
          receipt_email: order.customer.emailAddress,
          next_run_date: subscriptionDefinition.nextRunDate,
        }
      );
      const subscriptionIds =
        subscriptionsPerOrderLine.get(subscriptionDefinition.orderLineId) ?? [];
      subscriptionIds.push(recurringSchedule.id);
      subscriptionsPerOrderLine.set(
        subscriptionDefinition.orderLineId,
        subscriptionIds
      );
      recurringSchedules.push(recurringSchedule);
    }
    await this.entityHydrator.hydrate(ctx, order, { relations: ['lines'] });
    await Promise.all(
      Array.from(subscriptionsPerOrderLine).map(
        async ([orderLineId, subscriptionIds]) => {
          const orderLine = order.lines.find((l) => l.id === orderLineId);
          if (orderLine) {
            orderLine.customFields.acceptBlueSubscriptionIds = subscriptionIds;
            await this.connection.getRepository(ctx, OrderLine).save(orderLine);
          }
        }
      )
    );
    return recurringSchedules;
  }
  async updateSubscription(
    ctx: RequestContext,
    input: UpdateAcceptBlueSubscriptionInput
  ): Promise<AcceptBlueSubscription> {
    const scheduleId = input.id;
    const orderLine = await this.findOrderLineByScheduleId(ctx, scheduleId);
    if (!orderLine) {
      throw new UserInputError(
        `No order exists with an Accept Blue subscription id of ${scheduleId}`
      );
    }
    await this.entityHydrator.hydrate(ctx, orderLine, {
      relations: ['order', 'productVariant'],
    });
    const client = await this.getClientForChannel(ctx);
    const schedule = await client.updateRecurringSchedule(scheduleId, {
      title: input.title ?? undefined,
      amount: input.amount ?? undefined,
      frequency: input.frequency ?? undefined,
      next_run_date: input.nextRunDate ?? undefined,
      num_left: input.numLeft ?? undefined,
      active: input.active ?? undefined,
      receipt_email: input.receiptEmail || undefined,
    });
    await this.orderService.addNoteToOrder(ctx, {
      id: orderLine.order.id,
      note: `Subscription updated: ${JSON.stringify(input)}`,
      isPublic: true,
    });
    const subscription = this.mapToGraphqlSubscription(
      schedule,
      orderLine.productVariant.id
    );
    await this.eventBus.publish(
      new AcceptBlueSubscriptionEvent(ctx, subscription, 'updated', input)
    );
    return subscription;
  }
  async getSubscriptionsForOrderLine(
    ctx: RequestContext,
    orderLine: OrderLine,
    order: Order
  ): Promise<AcceptBlueSubscription[]> {
    if (order.orderPlacedAt) {
      const client = await this.getClientForChannel(ctx);
      const subscriptionIds =
        orderLine.customFields.acceptBlueSubscriptionIds ?? [];
      const createdSubscriptions = await client.getRecurringSchedules(
        subscriptionIds
      );
      return await Promise.all(
        createdSubscriptions.map(async (s) => {
          const transactions = await client.getTransactionsForRecurringSchedule(
            s.id
          );
          const graphqlTransactions = transactions.map((t) =>
            this.mapToGraphqlTransaction(t)
          );
          return this.mapToGraphqlSubscription(
            s,
            orderLine.productVariant.id,
            graphqlTransactions
          );
        })
      );
    }
    const subscriptionsForOrderLine =
      await this.subscriptionHelper.getSubscriptionsForOrderLine(
        ctx,
        orderLine,
        orderLine.order
      );
    return subscriptionsForOrderLine.map((s) => {
      return {
        ...s,
        variantId: orderLine.productVariant.id,
        transactions: [],
      };
    });
  }
  async getSavedPaymentMethods(
    ctx: RequestContext,
    customer: Customer
  ): Promise<AcceptBluePaymentMethod[]> {
    const client = await this.getClientForChannel(ctx);
    if (!ctx.activeUserId) {
      throw new Error(`User is not logged in!`);
    }
    if (!customer) {
      throw new Error(`No customer found for user ${ctx.activeUserId}`);
    }
    return await client.getPaymentMethods(
      customer.customFields.acceptBlueCustomerId
    );
  }
  async refund(
    ctx: RequestContext,
    transactionId: number,
    amount?: number,
    cvv2?: string
  ): Promise<AcceptBlueRefundResult> {
    const client = await this.getClientForChannel(ctx);
    const refundResult = await client.refund(transactionId, amount, cvv2);
    let errorDetails: string | undefined = undefined;
    if (refundResult.error_details) {
      errorDetails =
        typeof refundResult.error_details === 'object'
          ? JSON.stringify(refundResult.error_details)
          : refundResult.error_details;
    }
    Logger.info(
      `Attempted refund of transaction '${transactionId}' by user '${ctx.activeUserId}' resulted in status '${refundResult.status}'`,
      loggerCtx
    );
    return {
      version: refundResult.version,
      referenceNumber: refundResult.reference_number,
      status: toGraphqlRefundStatus(refundResult.status),
      errorCode: refundResult.error_code,
      errorMessage: refundResult.error_message,
      errorDetails,
    };
  }
  async getSurcharges(ctx: RequestContext): Promise<AcceptBlueSurcharges> {
    const client = await this.getClientForChannel(ctx);
    return await client.getSurcharges();
  }
  async getClientForChannel(ctx: RequestContext): Promise<AcceptBlueClient> {
    const acceptBlueMethod = await this.getAcceptBlueMethod(ctx);
    if (!acceptBlueMethod) {
      throw new Error(
        `No enabled payment method found with code ${acceptBluePaymentHandler.code}`
      );
    }
    const apiKey = acceptBlueMethod.handler.args.find(
      (a) => a.name === 'apiKey'
    )?.value;
    const pin = acceptBlueMethod.handler.args.find(
      (a) => a.name === 'pin'
    )?.value;
    const testMode = acceptBlueMethod.handler.args.find(
      (a) => a.name === 'testMode'
    )?.value as boolean | undefined;
    if (!apiKey) {
      throw new Error(
        `No apiKey or pin found on configured Accept Blue payment method`
      );
    }
    const mapToBoolean = (value: string | undefined) =>
      value === 'true' ? true : false;
    const enabledPaymentMethodArgs: EnabledPaymentMethodsArgs = {
      allowAmex: mapToBoolean(
        acceptBlueMethod.handler.args.find((a) => a.name === 'allowAmex')?.value
      ),
      allowECheck: mapToBoolean(
        acceptBlueMethod.handler.args.find((a) => a.name === 'allowECheck')
          ?.value
      ),
      allowDiscover: mapToBoolean(
        acceptBlueMethod.handler.args.find((a) => a.name === 'allowDiscover')
          ?.value
      ),
      allowMasterCard: mapToBoolean(
        acceptBlueMethod.handler.args.find((a) => a.name === 'allowMasterCard')
          ?.value
      ),
      allowVisa: mapToBoolean(
        acceptBlueMethod.handler.args.find((a) => a.name === 'allowVisa')?.value
      ),
    };
    return new AcceptBlueClient(
      apiKey,
      pin,
      enabledPaymentMethodArgs,
      testMode
    );
  }
  async getHostedTokenizationKey(ctx: RequestContext): Promise<string | null> {
    const acceptBlueMethod = await this.getAcceptBlueMethod(ctx);
    const tokenizationSourceKey = acceptBlueMethod?.handler.args.find(
      (a) => a.name === 'tokenizationSourceKey'
    )?.value;
    return tokenizationSourceKey ?? null;
  }
  async getAcceptBlueMethod(
    ctx: RequestContext
  ): Promise<PaymentMethod | undefined> {
    const methods = await this.paymentMethodService.findAll(ctx, {
      filter: {
        enabled: { eq: true },
      },
    });
    const acceptBlueMethod = methods.items.filter(
      (m) => m.handler.code === acceptBluePaymentHandler.code
    );
    if (acceptBlueMethod.length > 1) {
      throw Error(
        `More than one enabled payment method found with code ${acceptBluePaymentHandler.code}. There should be only 1 per channel`
      );
    }
    if (acceptBlueMethod.length === 0) {
      throw new Error(
        `No enabled payment method found with code ${acceptBluePaymentHandler.code}`
      );
    }
    return acceptBlueMethod[0];
  }
  async handleIncomingWebhook(
    ctx: RequestContext,
    event: AcceptBlueEvent,
    rawBody: Buffer,
    incomingSignature: string
  ): Promise<void> {
    if (event.event === 'batch') {
      Logger.info(
        `Ignoring incoming webhook of type '${event.event}' '${event.type}' (${event.id})`,
        loggerCtx
      );
      return;
    }
    Logger.info(
      `Handling incoming webhook '${event.subType}' '${event.event}' '${event.type}' (${event.id}) ...`,
      loggerCtx
    );
    const acceptBlueMethod = await this.getAcceptBlueMethod(ctx);
    const savedSecret = acceptBlueMethod?.handler.args.find(
      (a) => a.name === 'webhookSecret'
    )?.value;
    if (!savedSecret) {
      throw new Error(
        'No webhook secret found on Accept Blue payment method, can not validate incoming webhook'
      );
    }
    if (!this.isValidSignature(savedSecret, rawBody, incomingSignature)) {
      throw new ForbiddenError();
    }
    const scheduleId = event.data.transaction?.transaction_details?.schedule_id;
    const orderLineIds = this.parseOrderLineCustomField(
      event.data.transaction?.custom_fields?.custom1
    );
    let orderLines: OrderLine[] = [];
    if (scheduleId) {
      const orderLine = await this.findOrderLineByScheduleId(ctx, scheduleId);
      if (orderLine) {
        orderLines = [orderLine];
      }
    } else {
      orderLines = await this.connection
        .getRepository(ctx, OrderLine)
        .find({ where: { id: In(orderLineIds) } });
    }
    if (!orderLines.length) {
      Logger.error(
        `No order lines found for incoming webhook, we can not connect this event to an order line: ${JSON.stringify(
          event
        )}`,
        loggerCtx
      );
      return;
    }
    for (const orderLine of orderLines) {
      await this.entityHydrator.hydrate(ctx, orderLine, {
        relations: ['order', 'order.customer'],
      });
      await this.eventBus.publish(
        new AcceptBlueTransactionEvent(
          ctx,
          event.type,
          event,
          orderLine,
          event.data.transaction?.id
        )
      );
      Logger.debug(
        `Published AcceptBlueTransactionEvent (${event.id}) for orderLine ${orderLine.id}`,
        loggerCtx
      );
    }
    Logger.info(
      `Successfully handled incoming webhook '${event.subType}' '${event.event}' '${event.type}' (${event.id})`,
      loggerCtx
    );
  }
  async findOrderLineByScheduleId(
    ctx: RequestContext,
    scheduleId: number
  ): Promise<OrderLine | null | undefined> {
    const result = await this.connection
      .getRepository(ctx, OrderLine)
      .createQueryBuilder('orderLine')
      .where(
        'orderLine.customFields.acceptBlueSubscriptionIds LIKE :scheduleId',
        { scheduleId: `%${scheduleId}%` }
      )
      .getMany();
    return result.find((orderLine) =>
      orderLine.customFields.acceptBlueSubscriptionIds.includes(scheduleId)
    );
  }
  isValidSignature(
    savedSecret: string,
    rawBody: Buffer,
    incomingSignature: string
  ): boolean {
    const hash = crypto
      .createHmac('sha256', savedSecret)
      .update(rawBody)
      .digest('hex');
    return hash === incomingSignature;
  }
  parseOrderLineCustomField(customField1?: string): ID[] {
    if (!customField1) {
      return [];
    }
    const orderLineIds = JSON.parse(customField1);
    if (!Array.isArray(orderLineIds)) {
      throw new Error(`Given custom field is not an array`);
    }
    return orderLineIds as ID[];
  }
  mapToAcceptBlueCustomerInput(
    order: Order,
    customer: Customer
  ): AcceptBlueCustomerInput {
    const shippingName = order.shippingAddress?.fullName?.split(' ');
    const shippingAddress: AcceptBlueCustomerInput['shipping_info'] = {
      first_name: shippingName?.[0] ?? customer.firstName,
      last_name: shippingName?.[1] ?? customer.lastName,
      street: order.shippingAddress?.streetLine1,
      street2: order.shippingAddress?.streetLine2,
      zip: order.shippingAddress?.postalCode,
      state: order.shippingAddress?.province,
      phone: order.shippingAddress?.phoneNumber,
      city: order.shippingAddress?.city,
      country: order.shippingAddress?.countryCode,
    };
    const billingName = order.billingAddress?.fullName?.split(' ');
    const billingAddress: AcceptBlueCustomerInput['billing_info'] = {
      first_name: billingName?.[0] ?? customer.firstName,
      last_name: billingName?.[1] ?? customer.lastName,
      street: order.billingAddress?.streetLine1,
      street2: order.billingAddress?.streetLine2,
      zip: order.billingAddress?.postalCode,
      state: order.billingAddress?.province,
      phone: order.billingAddress?.phoneNumber,
      city: order.billingAddress?.city,
      country: order.billingAddress?.countryCode,
    };
    return {
      first_name: customer.firstName,
      last_name: customer.lastName,
      identifier: customer.emailAddress,
      email: customer.emailAddress,
      shipping_info: shippingAddress,
      billing_info: billingAddress,
      phone: customer.phoneNumber,
    };
  }
  private mapToGraphqlSubscription(
    subscription: AcceptBlueRecurringSchedule,
    variantId: ID,
    transactions: AcceptBlueTransaction[] = []
  ): AcceptBlueSubscription {
    const { interval, intervalCount } = toSubscriptionInterval(
      subscription.frequency
    );
    return {
      id: subscription.id,
      amountDueNow: 0,
      name: subscription.title,
      priceIncludesTax: true,
      variantId,
      recurring: {
        amount: subscription.amount,
        interval,
        intervalCount,
        startDate: subscription.created_at,
      },
      transactions,
    };
  }
  private mapToGraphqlTransaction(
    transaction: AcceptBlueRecurringScheduleTransaction
  ): AcceptBlueTransaction {
    return {
      id: transaction.id,
      amount: transaction.amount_details.amount,
      createdAt: transaction.created_at,
      settledAt: transaction.settled_date
        ? new Date(transaction.settled_date)
        : undefined,
      cardDetails: transaction.card_details
        ? {
            name: transaction.card_details.name,
            cardType: transaction.card_details.card_type,
            expiryMonth: transaction.card_details.expiry_month,
            expiryYear: transaction.card_details.expiry_year,
            last4: transaction.card_details.last4,
          }
        : undefined,
      checkDetails: transaction.check_details
        ? {
            name: transaction.check_details.name,
            last4: transaction.check_details.account_number_last4,
            routingNumber: transaction.check_details.routing_number,
          }
        : undefined,
      status: transaction.status_details.status,
      errorCode: transaction.status_details.error_code,
      errorMessage: transaction.status_details.error_message,
    };
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/api/api-extensions.ts

```typescript
import { gql } from 'graphql-tag';
const _codegenAdditions = gql`
  scalar DateTime
  scalar JSON
`;
const commonApiExtensions = gql`
  enum AcceptBlueSubscriptionInterval {
    week
    month
    year
  }
  type AcceptBlueSubscription {
    """
    This ID might not be available yet when an order hasn't been placed yet
    """
    id: ID
    name: String!
    variantId: ID!
    amountDueNow: Int!
    priceIncludesTax: Boolean!
    recurring: AcceptBlueSubscriptionRecurringPayment!
    transactions: [AcceptBlueTransaction!]!
  }
  type AcceptBlueSubscriptionRecurringPayment {
    amount: Int!
    interval: AcceptBlueSubscriptionInterval!
    intervalCount: Int!
    startDate: DateTime!
    endDate: DateTime
  }
  type AcceptBlueCardPaymentMethod {
    id: Int!
    created_at: DateTime!
    avs_address: String
    avs_zip: String
    name: String
    expiry_month: Int!
    expiry_year: Int!
    payment_method_type: String
    card_type: String
    last4: String
  }
  type AcceptBlueCheckPaymentMethod {
    id: Int!
    customer_id: Int
    created_at: DateTime!
    name: String
    payment_method_type: String
    last4: String
    account_number: String
    routing_number: String
    account_type: String
    sec_code: String
  }
  type AcceptBlueTransaction {
    id: ID!
    createdAt: DateTime!
    settledAt: DateTime
    amount: Int!
    status: String!
    errorCode: String
    errorMessage: String
    checkDetails: AcceptBlueCheckDetails
    cardDetails: AcceptBlueCardDetails
  }
  enum AcceptBlueRefundStatus {
    Approved
    PartiallyApproved
    Declined
    Error
  }
  type AcceptBlueRefundResult {
    referenceNumber: Int!
    version: String!
    status: AcceptBlueRefundStatus!
    errorMessage: String
    errorCode: String
    errorDetails: String
  }
  type AcceptBlueCheckDetails {
    name: String!
    routingNumber: String!
    last4: String!
  }
  type AcceptBlueCardDetails {
    name: String!
    last4: String!
    expiryMonth: Int!
    expiryYear: Int!
    cardType: String!
  }
  union AcceptBluePaymentMethod =
      AcceptBlueCardPaymentMethod
    | AcceptBlueCheckPaymentMethod
  extend type PaymentMethodQuote {
    acceptBlueHostedTokenizationKey: String
  }
  extend type OrderLine {
    acceptBlueSubscriptions: [AcceptBlueSubscription!]!
  }
  extend type Customer {
    savedAcceptBluePaymentMethods: [AcceptBluePaymentMethod!]!
  }
  enum AcceptBlueFrequencyInput {
    daily
    weekly
    biweekly
    monthly
    bimonthly
    quarterly
    biannually
    annually
  }
  input UpdateAcceptBlueSubscriptionInput {
    id: Int!
    title: String
    frequency: AcceptBlueFrequencyInput
    """
    Amount in cents to bill customer
    """
    amount: Int
    nextRunDate: DateTime
    """
    Number of times the schedule has left to bill. Set to 0 for ongoing
    """
    numLeft: Int
    active: Boolean
    """
    An email address to send a customer receipt to each time the schedule runs
    """
    receiptEmail: String
  }
  enum AcceptBluePaymentMethodType {
    Visa
    MasterCard
    Discover
    Amex
    ECheck
    GooglePay
    ApplePay
  }
  type AcceptBlueSurchargeValue {
    type: String!
    value: Float!
  }
  type AcceptBlueSurcharges {
    check: AcceptBlueSurchargeValue!
    card: AcceptBlueSurchargeValue!
  }
  """
  Used to display eligible payment methods
  """
  type AcceptBluePaymentMethodQuote {
    name: AcceptBluePaymentMethodType!
  }
  extend type Query {
    previewAcceptBlueSubscriptions(
      productVariantId: ID!
      customInputs: JSON
    ): [AcceptBlueSubscription!]!
    previewAcceptBlueSubscriptionsForProduct(
      productId: ID!
      customInputs: JSON
    ): [AcceptBlueSubscription!]!
    eligibleAcceptBluePaymentMethods: [AcceptBluePaymentMethodQuote!]!
    acceptBlueSurcharges: AcceptBlueSurcharges!
  }
`;
export const shopApiExtensions = gql`
  ${commonApiExtensions}
`;
export const adminApiExtensions = gql`
  ${commonApiExtensions}
  extend type Mutation {
    """
    Refund a transaction by ID
    """
    refundAcceptBlueTransaction(
      transactionId: Int!
      amount: Int
      cvv2: String
    ): AcceptBlueRefundResult!
    """
    Update the given subscription in Accept Blue
    """
    updateAcceptBlueSubscription(
      input: UpdateAcceptBlueSubscriptionInput!
    ): AcceptBlueSubscription!
  }
`;
```

## File: packages/vendure-plugin-accept-blue/src/api/custom-field-types.ts

```typescript
import {
  CustomCustomerFields,
  CustomOrderLineFields,
} from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomCustomerFields {
    acceptBlueCustomerId: number;
  }
  interface CustomOrderLineFields {
    acceptBlueSubscriptionIds: number[];
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/events/accept-blue-subscription-event.ts

```typescript
import { RequestContext, VendureEvent } from '@vendure/core';
import {
  AcceptBlueSubscription,
  UpdateAcceptBlueSubscriptionInput,
} from '../api/generated/graphql';
export class AcceptBlueSubscriptionEvent extends VendureEvent {
  constructor(
    ctx: RequestContext,
    public subscription: AcceptBlueSubscription,
    public type: 'created' | 'updated' | 'deleted',
    public input?: UpdateAcceptBlueSubscriptionInput
  ) {
    super();
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/events/accept-blue-transaction-event.ts

```typescript
import { OrderLine, RequestContext, VendureEvent } from '@vendure/core';
import { AcceptBlueEvent } from '../types';
export class AcceptBlueTransactionEvent extends VendureEvent {
  constructor(
    public ctx: RequestContext,
    public status: 'succeeded' | 'updated' | 'declined' | 'error' | 'status',
    public rawData: AcceptBlueEvent,
    public orderLine: OrderLine,
    public transactionId?: number
  ) {
    super();
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/accept-blue-plugin.ts

```typescript
import { PluginCommonModule, Type, VendurePlugin } from '@vendure/core';
import { SubscriptionStrategy } from '../../util/src/subscription/subscription-strategy';
import { AcceptBlueService } from './api/accept-blue-service';
import { acceptBluePaymentHandler } from './api/accept-blue-handler';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { adminApiExtensions, shopApiExtensions } from './api/api-extensions';
import { AcceptBlueCommonResolver } from './api/accept-blue-common-resolvers';
import { AcceptBlueController } from './api/accept-blue-controller';
import { DefaultSubscriptionStrategy } from '../../util/src/subscription/default-subscription-strategy';
import { rawBodyMiddleware } from '../../util/src/raw-body.middleware';
import { AcceptBlueAdminResolver } from './api/accept-blue-admin-resolver';
interface AcceptBluePluginOptionsInput {
  subscriptionStrategy?: SubscriptionStrategy;
  vendureHost: string;
}
export type AcceptBluePluginOptions = Required<AcceptBluePluginOptionsInput>;
@VendurePlugin({
  imports: [PluginCommonModule],
  adminApiExtensions: {
    schema: adminApiExtensions,
    resolvers: [AcceptBlueCommonResolver, AcceptBlueAdminResolver],
  },
  shopApiExtensions: {
    schema: shopApiExtensions,
    resolvers: [AcceptBlueCommonResolver],
  },
  controllers: [AcceptBlueController],
  providers: [
    AcceptBlueService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => AcceptBluePlugin.options,
    },
  ],
  configuration: (config) => {
    config.paymentOptions.paymentMethodHandlers.push(acceptBluePaymentHandler);
    config.apiOptions.middleware.push({
      route: '/accept-blue/*',
      handler: rawBodyMiddleware,
      beforeListen: true,
    });
    config.customFields.OrderLine.push({
      name: 'acceptBlueSubscriptionIds',
      type: 'int',
      list: true,
      nullable: true,
      readonly: true,
    });
    config.customFields.Customer.push({
      name: 'acceptBlueCustomerId',
      nullable: true,
      readonly: true,
      type: 'int',
    });
    return config;
  },
  compatibility: '>=2.2.0',
})
export class AcceptBluePlugin {
  static options: AcceptBluePluginOptions;
  static init(options: AcceptBluePluginOptionsInput): Type<AcceptBluePlugin> {
    let vendureHost = options.vendureHost;
    if (vendureHost.endsWith('/')) {
      vendureHost = vendureHost.slice(0, vendureHost.length - 1);
    }
    this.options = {
      subscriptionStrategy:
        options.subscriptionStrategy ?? new DefaultSubscriptionStrategy(),
      vendureHost,
    };
    return AcceptBluePlugin;
  }
}
```

## File: packages/vendure-plugin-accept-blue/src/constants.ts

```typescript
export const loggerCtx = 'AcceptBluePlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-accept-blue/src/index.ts

```typescript
export * from '../../util/src/subscription/default-subscription-strategy';
export * from '../../util/src/subscription/subscription-strategy';
export * from '../../util/src/subscription/subscription-helper';
export * from './accept-blue-plugin';
export * from './api/accept-blue-service';
export * from './api/accept-blue-client';
export * from './events/accept-blue-transaction-event';
export * from './events/accept-blue-subscription-event';
export * from './api/accept-blue-handler';
export * from './api/accept-blue-common-resolvers';
export * from './api/custom-field-types';
```

## File: packages/vendure-plugin-accept-blue/src/types.ts

```typescript
import { PaymentMetadata, RequestContext } from '@vendure/core';
import type { Request } from 'express';
export interface CustomFields {
  custom1?: string;
}
enum AcceptBlueAVSResultCode {
  YYY = 'YYY',
  YYX = 'YYX',
  NYZ = 'NYZ',
  NYW = 'NYW',
  YNA = 'YNA',
  NNN = 'NNN',
  XXW = 'XXW',
  XXU = 'XXU',
  XXR = 'XXR',
  XXS = 'XXS',
  XXE = 'XXE',
  XXG = 'XXG',
  YYG = 'YYG',
  GGG = 'GGG',
  YGG = 'YGG',
  NNC = 'NNC',
  NA = 'NA',
}
export interface AcceptBlueAddress {
  first_name: string;
  last_name: string;
  street: string;
  street2: string;
  state: string;
  city: string;
  zip: string;
  country: string;
  phone?: string;
}
interface AcceptBlueTerminal {
  operating_environment: number;
  cardholder_authentication_method: number;
  cardholder_authentication_entity: number;
  print_capability: boolean;
}
interface TransactionFlags {
  allow_partial_approval: boolean;
  is_recurring: boolean;
  is_installment: boolean;
  is_customer_initiated: boolean;
  cardholder_present: boolean;
  card_present: boolean;
  terminal: AcceptBlueTerminal;
}
interface TransactionDetails {
  description: string;
  clerk: string;
  terminal: string;
  client_ip: string;
  signature: string;
  invoice_number: string;
  po_number: string;
  order_number: string;
  batch_id: number;
  source: string;
  terminal_name: string;
  username: string;
  type: 'charge' | 'credit';
  reference_number: number;
  schedule_id: number;
}
export interface AcceptBlueAmountInput {
  tax: number;
  surcharge: number;
  shipping: number;
  tip: number;
  discount: number;
}
export interface AcceptBlueAmountDetails extends AcceptBlueAmountInput {
  amount: number;
  subtotal: number;
  original_requested_amount: number;
  original_authorized_amount: number;
}
interface TransactionCustomer {
  identifier: string;
  email: string;
  fax?: string | null;
  customer_id: number;
}
interface ChargeCustomer extends TransactionCustomer {
  send_receipt: boolean;
}
export interface AcceptBlueCustomerInput {
  identifier: string;
  customer_number?: string;
  first_name?: string;
  last_name?: string;
  email?: string;
  website?: string;
  phone?: string;
  alternate_phone?: string;
  billing_info?: Partial<AcceptBlueAddress>;
  shipping_info?: Partial<AcceptBlueAddress>;
  active?: boolean;
}
export interface AcceptBlueCustomer {
  id: number;
  identifier: string;
  customer_number: string;
  first_name?: string;
  last_name?: string;
  email: string;
  website?: string;
  phone?: string;
  alternate_phone?: string;
  billing_info?: AcceptBlueAddress;
  shipping_info?: AcceptBlueAddress;
  active: boolean;
}
type CardType = 'Visa' | 'MasterCard' | 'Discover' | 'Amex';
export type AccountType = 'Checking' | 'Savings';
export type SecCode = 'PPD' | 'CCD' | 'TEL' | 'WEB';
export interface AcceptBlueCardPaymentMethod {
  id: number;
  customer_id: string;
  created_at: Date;
  name: string;
  payment_method_type: 'card';
  last4: string;
  avs_address: string;
  avs_zip: string;
  expiry_month: number;
  expiry_year: number;
  card_type: CardType;
}
export interface AcceptBlueCheckPaymentMethod {
  id: number;
  customer_id: string;
  created_at: Date;
  name: string;
  payment_method_type: 'check';
  last4: string;
  routing_number: string;
  account_type: AccountType;
  sec_code: SecCode;
}
export type AcceptBluePaymentMethod =
  | AcceptBlueCardPaymentMethod
  | AcceptBlueCheckPaymentMethod;
export interface AllowedPaymentMethodInput {
  payment_method_type?: string;
  card_type?: CardType;
  source?: 'googlepay' | 'applepay';
}
export interface AppleOrGooglePayInput {
  amount: number;
  source: 'googlepay' | 'applepay';
  token: string;
  avs_zip?: string;
  avs_address?: string;
}
export interface NoncePaymentMethodInput {
  source: string;
  expiry_month: number;
  expiry_year: number;
  last4: string;
}
export interface SourcePaymentMethodInput {
  source: string;
}
export interface SavedPaymentMethodInput {
  paymentMethodId: number;
}
export interface CheckPaymentMethodInput {
  routing_number: string;
  account_number: string;
  name: string;
  account_type: AccountType;
  sec_code?: SecCode;
}
export interface HandlePaymentResult {
  amount: number;
  state: 'Settled';
  transactionId?: string;
  metadata?: PaymentMetadata;
}
export type Frequency =
  | 'daily'
  | 'weekly'
  | 'biweekly'
  | 'monthly'
  | 'bimonthly'
  | 'quarterly'
  | 'biannually'
  | 'annually';
export interface AcceptBlueRecurringSchedule {
  id: number;
  customer_id: number;
  created_at: Date;
  title: string;
  frequency: Frequency;
  amount: number;
  next_run_date: Date;
  num_left: number;
  payment_method_id: number;
  active: boolean;
  receipt_email: string;
  status: 'active' | 'declined' | 'error' | 'finished' | 'failed';
  prev_run_date: Date;
  transaction_count: number;
}
export interface AcceptBlueRecurringScheduleCreateInput {
  title: string;
  amount: number;
  payment_method_id: number;
  frequency?: Frequency;
  next_run_date?: Date;
  num_left?: number;
  active?: boolean;
  receipt_email?: string;
  use_this_source_key?: boolean;
}
export interface AcceptBlueRecurringScheduleUpdateInput {
  title?: string;
  amount?: number;
  payment_method_id?: number;
  frequency?: Frequency;
  next_run_date?: Date;
  num_left?: number;
  active?: boolean;
  receipt_email?: string;
}
export interface AcceptBlueRecurringScheduleTransaction {
  id: number;
  created_at: Date;
  settled_date: Date;
  amount_details: AcceptBlueAmountDetails;
  transaction_details: TransactionDetails;
  customer: TransactionCustomer;
  billing_info: AcceptBlueAddress;
  shipping_info: AcceptBlueAddress;
  custom_fields: CustomFields;
  status_details: {
    error_code: string;
    error_message: string;
    status: string;
  };
  card_details?: {
    name: string;
    last4: string;
    expiry_month: number;
    expiry_year: number;
    card_type: string;
  };
  check_details?: {
    name: string;
    routing_number: string;
    account_number_last4: string;
    account_type: number;
  };
}
export interface CardTransaction {
  id: number;
  created_at: string;
  settled_date: string;
  amount_details: AcceptBlueAmountDetails;
  transaction_details: TransactionDetails;
  customer: TransactionCustomer;
  billing_info: AcceptBlueAddress;
  shipping_info: AcceptBlueAddress;
  custom_fields: CustomFields;
}
interface AcceptBlueBinType {
  type: 'C' | 'D' | null;
}
export interface AcceptBlueTransaction {
  version: string;
  status: 'Approved' | 'Partially Approved' | 'Declined' | 'Error';
  status_code: 'A' | 'P' | 'D' | 'E';
  error_message: string;
  error_code: string;
  error_details: string | any;
  reference_number: number;
}
export interface AcceptBlueChargeTransaction extends AcceptBlueTransaction {
  auth_amount: number;
  auth_code: string;
  avs_result: string;
  avs_result_code: AcceptBlueAVSResultCode;
  cvv2_result: string;
  cvv2_result_code: 'M' | 'N' | 'P' | 'U' | 'X';
  card_type: CardType;
  last_4: string;
  card_ref: string | null;
  bin_type?: AcceptBlueBinType;
  transaction?: CardTransaction;
}
export interface AcceptBlueEvent {
  ctx: RequestContext;
  type: 'succeeded' | 'updated' | 'declined' | 'error' | 'status';
  subType: string;
  event: 'transaction' | 'batch';
  id: string;
  timestamp: string;
  data: AcceptBlueChargeTransaction;
}
export interface TransactionSuccess extends AcceptBlueEvent {
  type: 'succeeded';
  subType: 'charge' | 'credit' | 'refund';
}
export interface TransactionUpdate extends AcceptBlueEvent {
  type: 'updated';
  subType: 'adjust' | 'void';
}
export interface TransactionDeclined extends AcceptBlueEvent {
  type: 'declined';
  subType: 'charge' | 'credit' | 'refund' | 'adjust' | 'void';
}
export interface TransactionError extends AcceptBlueEvent {
  type: 'error';
  subType: 'charge' | 'credit' | 'refund' | 'adjust' | 'void';
}
export interface TransactionStatus extends AcceptBlueEvent {
  type: 'status';
  subType:
    | 'settled'
    | 'reserve'
    | 'originated'
    | 'pending'
    | 'voided'
    | 'returned'
    | 'error'
    | 'cancelled'
    | 'unknown';
}
export interface BatchObject {
  id: number;
  opened_at: string | null;
  auto_close_date: string | null;
  closed_at: string | null;
  platform: string;
  sequence_number: number;
}
export interface BatchEvent {
  type: 'closed';
  event: 'batch';
  id: string;
  timestamp: string;
  data: BatchObject;
}
export interface AcceptBlueWebhookInput {
  webhook_url: string;
  description: string;
  active: true;
}
export interface AcceptBlueWebhook {
  id: number;
  signature: string;
  webhook_url: string;
  description: string;
  active: boolean;
}
export interface RequestWithRawBody extends Request {
  rawBody: Buffer;
}
export interface EnabledPaymentMethodsArgs {
  allowVisa?: boolean;
  allowMasterCard?: boolean;
  allowAmex?: boolean;
  allowDiscover?: boolean;
  allowECheck?: boolean;
  allowGooglePay?: boolean;
  allowApplePay?: boolean;
}
```

## File: packages/vendure-plugin-accept-blue/src/util.spec.ts

```typescript
import { getNrOfBillingCyclesLeft } from './util';
import { describe, it, expect } from 'vitest';
describe('getNrOfBillingCyclesLeft', () => {
  it('Starts on monday and ends the next tuesday  with frequency weekly', () => {
    const startDate = new Date('2024-11-18');
    const endDate = new Date('2024-11-19');
    const frequency = 'weekly';
    const result = getNrOfBillingCyclesLeft(startDate, endDate, frequency);
    expect(result).toBe(1);
  });
  it('Starts on monday and ends the tuesday 1 week later  with frequency weekly', () => {
    const startDate = new Date('2024-11-18');
    const endDate = new Date('2024-11-26');
    const frequency = 'weekly';
    const result = getNrOfBillingCyclesLeft(startDate, endDate, frequency);
    expect(result).toBe(2);
  });
  it('Starts on monday and ends the sunday 1 week later  with frequency weekly', () => {
    const startDate = new Date('2024-11-18');
    const endDate = new Date('2024-12-01');
    const frequency = 'weekly';
    const result = getNrOfBillingCyclesLeft(startDate, endDate, frequency);
    expect(result).toBe(2);
  });
  it('Starts on monday and ends the monday 1 week later with frequency weekly', () => {
    const startDate = new Date('2024-11-18');
    const endDate = new Date('2024-11-25');
    const frequency = 'weekly';
    const result = getNrOfBillingCyclesLeft(startDate, endDate, frequency);
    expect(result).toBe(1);
  });
  it('Starts monday and ends the monday 1 week later with frequency daily', () => {
    const startDate = new Date('2024-11-18');
    const endDate = new Date('2024-11-25');
    const frequency = 'daily';
    const result = getNrOfBillingCyclesLeft(startDate, endDate, frequency);
    expect(result).toBe(7);
  });
});
```

## File: packages/vendure-plugin-accept-blue/src/util.ts

```typescript
import { Subscription } from '../../util/src/subscription/subscription-strategy';
import { AcceptBlueRefundResult } from './api/generated/graphql';
import {
  AcceptBlueTransaction,
  AccountType,
  CheckPaymentMethodInput,
  Frequency,
  AppleOrGooglePayInput,
  NoncePaymentMethodInput,
  SavedPaymentMethodInput,
} from './types';
interface MaskedCardInput {
  last4: string;
  expiry_month: number;
  expiry_year: number;
}
interface CheckInput {
  name: string;
  routing_number: string;
  account_number: string;
  account_type?: AccountType;
  sec_code?: string;
}
interface ObfuscatedCheck {
  last4: string;
  name: string;
  routing_number: string;
  account_type?: AccountType;
  sec_code?: string;
}
export function isSameCard(
  card1: MaskedCardInput,
  card2: MaskedCardInput
): boolean {
  return (
    card1.last4 === card2.last4 &&
    card1.expiry_month === card2.expiry_month &&
    card1.expiry_year === card2.expiry_year
  );
}
export function isSameCheck(input: CheckInput, check: ObfuscatedCheck) {
  return (
    input.name === check.name &&
    input.routing_number === check.routing_number &&
    input.account_number.endsWith(check.last4) &&
    input.account_type === check.account_type
  );
}
export function toAcceptBlueFrequency(subscription: Subscription): Frequency {
  const {
    recurring: { interval, intervalCount },
  } = subscription;
  if (interval === 'week' && intervalCount === 1) {
    return 'weekly';
  }
  if (interval === 'week' && intervalCount === 2) {
    return 'biweekly';
  }
  if (interval === 'month' && intervalCount === 1) {
    return 'monthly';
  }
  if (interval === 'month' && intervalCount === 2) {
    return 'bimonthly';
  }
  if (interval === 'month' && intervalCount === 3) {
    return 'quarterly';
  }
  if (interval === 'year' && intervalCount === 1) {
    return 'annually';
  }
  if (interval === 'month' && intervalCount === 6) {
    return 'biannually';
  }
  throw new Error(
    `Subscription interval '${interval}' and intervalCount '${intervalCount}' cannot be mapped to any of these frequencies: weekly, biweekly, monthly, bimonthly, quarterly, annually or biannually`
  );
}
export function toSubscriptionInterval(frequency: Frequency): {
  interval: 'week' | 'month' | 'year';
  intervalCount: number;
} {
  if (frequency === 'weekly') {
    return { interval: 'week', intervalCount: 1 };
  } else if (frequency === 'biweekly') {
    return { interval: 'week', intervalCount: 2 };
  } else if (frequency === 'monthly') {
    return { interval: 'month', intervalCount: 1 };
  } else if (frequency === 'bimonthly') {
    return { interval: 'month', intervalCount: 2 };
  } else if (frequency === 'quarterly') {
    return { interval: 'month', intervalCount: 3 };
  } else if (frequency === 'annually') {
    return { interval: 'year', intervalCount: 1 };
  } else if (frequency === 'biannually') {
    return { interval: 'year', intervalCount: 2 };
  } else {
    throw Error(
      `Frequency '${frequency}' cannot be mapped to an interval and interval count`
    );
  }
}
export function getNrOfBillingCyclesLeft(
  startDate: Date,
  endDate: Date,
  frequency: Frequency
): number {
  const diff = endDate.getTime() - startDate.getTime();
  const diffInDays = diff / (1000 * 3600 * 24);
  const nrOfBillingCyclesLeft = Math.ceil(
    diffInDays / getDaysBetweenBillingCycles(frequency)
  );
  return nrOfBillingCyclesLeft;
}
export function getDaysBetweenBillingCycles(frequency: Frequency): number {
  switch (frequency) {
    case 'daily':
      return 1;
    case 'weekly':
      return 7;
    case 'biweekly':
      return 14;
    case 'monthly':
      return 30;
    case 'bimonthly':
      return 60;
    case 'quarterly':
      return 90;
    case 'annually':
      return 365;
    case 'biannually':
      return 730;
    default:
      throw Error(`Frequency '${frequency}' is not a valid frequency`);
  }
}
export function isToday(date: Date): boolean {
  const today = new Date();
  return (
    date.getDate() === today.getDate() &&
    date.getMonth() === today.getMonth() &&
    date.getFullYear() === today.getFullYear()
  );
}
export function isNoncePaymentMethod(input: NoncePaymentMethodInput): boolean {
  return !!(
    input.source &&
    input.expiry_year &&
    input.expiry_month &&
    input.last4
  );
}
export function isCheckPaymentMethod(input: CheckPaymentMethodInput): boolean {
  return !!(
    input.account_number &&
    input.routing_number &&
    input.name &&
    input.account_type
  );
}
export function isGooglePayPaymentMethod(
  input: AppleOrGooglePayInput
): boolean {
  return !!(input.source === 'googlepay' && input.amount && input.token);
}
export function isSavedPaymentMethod(input: SavedPaymentMethodInput): boolean {
  return !!input.paymentMethodId;
}
export function toGraphqlRefundStatus(
  status: AcceptBlueTransaction['status']
): AcceptBlueRefundResult['status'] {
  switch (status) {
    case 'Partially Approved':
      return 'PartiallyApproved';
    default:
      return status;
  }
}
```

## File: packages/vendure-plugin-accept-blue/test/helpers/accept-blue-test-checkout.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { Body, Controller, Get, Headers, Res } from '@nestjs/common';
import { Response } from 'express';
import fs from 'fs/promises';
import Handlebars from 'handlebars';
interface CommonResult {
  cardType: string;
  maskedCard: string;
  maskedCvv2: string;
  expiryMonth: number;
  expiryYear: number;
  last4: string;
}
export interface NonceCardResult extends CommonResult {
  nonce: string;
  surcharge: { type: 'percent' | 'amount'; value: number } | null;
  binType: 'C' | 'D' | null;
  maskedCard: string;
  maskedCvv2: string;
  last4: string;
}
export interface DataResult extends CommonResult {
  avsZip: string;
}
@Controller()
export class CheckoutController {
  @Get('checkout')
  async checkout(
    @Headers('X-signature') signature: string | undefined,
    @Res() res: Response
  ): Promise<void> {
    const html = await fs.readFile(
      `${__dirname}/hosted-tokenization.html`,
      'utf8'
    );
    const renderedHtml = Handlebars.compile(html)({
      acceptBlueTokenizationKey:
        process.env.ACCEPT_BLUE_TOKENIZATION_SOURCE_KEY,
    });
    res.send(renderedHtml);
  }
  @Get('google-pay')
  async googlePay(
    @Headers('X-signature') signature: string | undefined,
    @Res() res: Response
  ): Promise<void> {
    const html = await fs.readFile(`${__dirname}/google-pay.html`, 'utf8');
    const renderedHtml = Handlebars.compile(html)({
      GOOGLE_PAY_MERCHANT_ID: process.env.GOOGLE_PAY_MERCHANT_ID,
    });
    res.send(renderedHtml);
  }
}
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [CheckoutController],
})
export class AcceptBlueTestCheckoutPlugin {}
```

## File: packages/vendure-plugin-accept-blue/test/helpers/graphql-helpers.ts

```typescript
import { gql } from 'graphql-tag';
const ACCEPT_BLUE_PAYMENT_METHOD_FRAGMENT = gql`
  fragment AcceptBluePaymentMethodFields on AcceptBluePaymentMethod {
    ... on AcceptBlueCardPaymentMethod {
      id
      created_at
      name
      payment_method_type
      last4
      avs_address
      avs_zip
      expiry_month
      expiry_year
      card_type
    }
    ... on AcceptBlueCheckPaymentMethod {
      id
      created_at
      name
      payment_method_type
      last4
      created_at
      account_number
      routing_number
      account_type
      sec_code
    }
  }
`;
export const CREATE_PAYMENT_METHOD = gql`
  mutation CreatePaymentMethod($input: CreatePaymentMethodInput!) {
    createPaymentMethod(input: $input) {
      id
      code
    }
  }
`;
export const ADD_ITEM_TO_ORDER = gql`
  mutation AddItemToOrder($productVariantId: ID!, $quantity: Int!) {
    addItemToOrder(productVariantId: $productVariantId, quantity: $quantity) {
      ... on Order {
        id
        code
        totalWithTax
        total
        lines {
          id
          acceptBlueSubscriptions {
            name
            variantId
          }
        }
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const TRANSITION_ORDER_TO = gql`
  mutation TransitionOrderToState($state: String!) {
    transitionOrderToState(state: $state) {
      ... on Order {
        id
        code
        totalWithTax
        total
        state
      }
      ... on OrderStateTransitionError {
        errorCode
        message
        transitionError
      }
    }
  }
`;
export const ADD_PAYMENT_TO_ORDER = gql`
  mutation AddPaymentToOrder($input: PaymentInput!) {
    addPaymentToOrder(input: $input) {
      ... on Order {
        id
        code
        totalWithTax
        total
        state
        lines {
          id
          customFields {
            acceptBlueSubscriptionIds
          }
        }
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const REFUND_TRANSACTION = gql`
  mutation RefundAcceptBlueTransaction(
    $transactionId: Int!
    $amount: Int
    $cvv2: String
  ) {
    refundAcceptBlueTransaction(
      transactionId: $transactionId
      amount: $amount
      cvv2: $cvv2
    ) {
      referenceNumber
      version
      status
      errorMessage
      errorCode
      errorDetails
    }
  }
`;
export const GET_ORDER_BY_CODE = gql`
  query GetOrderByCode($code: String!) {
    orderByCode(code: $code) {
      id
      code
      lines {
        acceptBlueSubscriptions {
          name
          variantId
          amountDueNow
          priceIncludesTax
          recurring {
            amount
            interval
            intervalCount
            startDate
            endDate
          }
          transactions {
            id
            createdAt
            settledAt
            amount
            status
            errorCode
            errorMessage
            checkDetails {
              name
              routingNumber
              last4
            }
            cardDetails {
              name
              last4
              expiryMonth
              expiryYear
            }
          }
        }
      }
    }
  }
`;
export const GET_HISTORY_ENTRIES = gql`
  query GetHistoryEntries($id: ID!) {
    order(id: $id) {
      id
      code
      history {
        items {
          id
          type
          data
        }
      }
    }
  }
`;
export const SET_SHIPPING_METHOD = gql`
  mutation SetShippingMethod($id: [ID!]!) {
    setOrderShippingMethod(shippingMethodId: $id) {
      ... on Order {
        id
        code
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const GET_USER_SAVED_PAYMENT_METHOD = gql`
  query GetUserSavedPaymentMethod {
    activeCustomer {
      savedAcceptBluePaymentMethods {
        ...AcceptBluePaymentMethodFields
      }
    }
  }
  ${ACCEPT_BLUE_PAYMENT_METHOD_FRAGMENT}
`;
export const PREVIEW_SUBSCRIPTIONS_FOR_VARIANT = gql`
  query previewAcceptBlueSubscriptions($productVariantId: ID!) {
    previewAcceptBlueSubscriptions(productVariantId: $productVariantId) {
      name
      variantId
    }
  }
`;
export const PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT = gql`
  query previewAcceptBlueSubscriptionsForProduct($productId: ID!) {
    previewAcceptBlueSubscriptionsForProduct(productId: $productId) {
      name
    }
  }
`;
export const GET_CUSTOMER_WITH_ID = gql`
  query GetCustomerWithId($id: ID!) {
    customer(id: $id) {
      savedAcceptBluePaymentMethods {
        ...AcceptBluePaymentMethodFields
      }
    }
  }
  ${ACCEPT_BLUE_PAYMENT_METHOD_FRAGMENT}
`;
export const UPDATE_SUBSCRIPTION = gql`
  mutation UpdateSubscription($input: UpdateAcceptBlueSubscriptionInput!) {
    updateAcceptBlueSubscription(input: $input) {
      name
      variantId
      amountDueNow
      priceIncludesTax
      recurring {
        amount
        interval
        intervalCount
        startDate
        endDate
      }
    }
  }
`;
export const ELIGIBLE_AC_PAYMENT_METHODS = gql`
  query eligibleAcceptBluePaymentMethods {
    eligibleAcceptBluePaymentMethods {
      name
    }
  }
`;
export const GET_SURCHARGES = gql`
  query {
    acceptBlueSurcharges {
      card {
        type
        value
      }
      check {
        type
        value
      }
    }
  }
`;
```

## File: packages/vendure-plugin-accept-blue/test/helpers/mocks.ts

```typescript
export const haydenSavedPaymentMethods = [
  {
    id: 14556,
    customer_id: 181937,
    created_at: '2024-01-11T10:44:14.000Z',
    name: 'Hayden Zieme',
    payment_method_type: 'card',
    last4: '1118',
    avs_address: 'Testing address',
    avs_zip: '12345',
    expiry_month: 1,
    expiry_year: 2025,
    card_type: 'Visa',
  },
  {
    id: 14969,
    customer_id: 181937,
    created_at: '2024-02-06T09:10:53.000Z',
    name: null,
    payment_method_type: 'card',
    last4: '4444',
    avs_address: null,
    avs_zip: null,
    expiry_month: 1,
    expiry_year: 2025,
    card_type: 'MasterCard',
  },
  {
    id: 15012,
    customer_id: 181937,
    created_at: '2024-02-06T22:14:07.000Z',
    name: 'Hayden Zieme',
    payment_method_type: 'check',
    last4: '9283',
    account_number: null,
    routing_number: '011000138',
    account_type: 'Checking',
    sec_code: 'CCD',
  },
  {
    id: 15019,
    customer_id: 181937,
    created_at: '2024-02-07T07:48:20.000Z',
    name: 'Hayden Zieme',
    payment_method_type: 'check',
    last4: '9289',
    account_number: null,
    routing_number: '011000138',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
  {
    id: 15020,
    customer_id: 181937,
    created_at: '2024-02-07T08:00:23.000Z',
    name: 'Hayden Zieme',
    payment_method_type: 'check',
    last4: '9191',
    account_number: null,
    routing_number: '063100277',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
  {
    id: 15021,
    customer_id: 181937,
    created_at: '2024-02-07T08:01:32.000Z',
    name: 'Hiede',
    payment_method_type: 'check',
    last4: '4567',
    account_number: null,
    routing_number: '061000052',
    account_type: 'Checking',
    sec_code: 'CCD',
  },
  {
    id: 15022,
    customer_id: 181937,
    created_at: '2024-02-07T08:03:25.000Z',
    name: 'Hayden',
    payment_method_type: 'check',
    last4: '0',
    account_number: null,
    routing_number: '063100277',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
  {
    id: 15023,
    customer_id: 181937,
    created_at: '2024-02-07T08:04:22.000Z',
    name: 'Hayden',
    payment_method_type: 'check',
    last4: '7514',
    account_number: null,
    routing_number: '063100277',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
  {
    id: 15024,
    customer_id: 181937,
    created_at: '2024-02-07T08:05:06.000Z',
    name: 'Hayden',
    payment_method_type: 'check',
    last4: '8864',
    account_number: null,
    routing_number: '051000017',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
  {
    id: 15035,
    customer_id: 181937,
    created_at: '2024-02-07T10:50:37.000Z',
    name: 'Hayden Zieme',
    payment_method_type: 'check',
    last4: '0189',
    account_number: null,
    routing_number: '071000505',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
  {
    id: 15036,
    customer_id: 181937,
    created_at: '2024-02-07T22:14:07.000Z',
    name: 'Hayden Zieme',
    payment_method_type: 'check',
    last4: '2087',
    account_number: '49000002087',
    routing_number: '490000018',
    account_type: 'Checking',
    sec_code: 'PPD',
  },
];
export const haydenZiemeCustomerDetails = {
  id: 181937,
  identifier: 'hayden.zieme12@hotmail.com',
  customer_number: 'hayden.zieme12@hotmail.com',
  first_name: 'Hayden',
  last_name: 'Zieme',
  email: 'hayden.zieme12@hotmail.com',
  website: null,
  phone: null,
  alternate_phone: null,
  billing_info: {
    first_name: null,
    last_name: null,
    company: null,
    street: null,
    street2: null,
    state: null,
    city: null,
    zip: null,
    country: 'US',
    phone: null,
  },
  shipping_info: {
    first_name: null,
    last_name: null,
    company: null,
    street: null,
    street2: null,
    state: null,
    city: null,
    zip: null,
    country: 'US',
    phone: null,
  },
  active: true,
};
export function createMockRecurringScheduleResult(id?: number) {
  return {
    id: id ?? Math.floor(Math.random() * 10000),
    created_at: '2024-02-07T23:57:55.000Z',
    customer_id: 181937,
    title: 'Subscription Laptop 13 inch 8GB',
    frequency: 'monthly',
    amount: 129900,
    prev_run_date: null,
    next_run_date: '2024-03-08',
    transaction_count: 0,
    num_left: 0,
    active: true,
    status: 'active',
    payment_method_id: 15035,
    receipt_email: 'hayden.zieme12@hotmail.com',
  };
}
export const creditCardChargeResult = {
  version: '2.0.0',
  status: 'Approved',
  status_code: 'A',
  reference_number: 300180,
  card_type: 'MasterCard',
  last_4: '4444',
  auth_code: 'OK3395',
  auth_amount: 156380,
  avs_result:
    'No AVS response (Typically no AVS data sent or swiped transaction)',
  avs_result_code: 'NA',
  cvv2_result: 'No CVV2/CVC data available for transaction.',
  cvv2_result_code: null,
  transaction: {
    id: 300180,
    created_at: '2024-02-07T23:57:55.000Z',
    settled_date: null,
    card_details: {
      name: null,
      last4: '4444',
      expiry_month: 1,
      expiry_year: 2025,
      card_type: 'MasterCard',
      avs_street: null,
      avs_zip: null,
      auth_code: 'OK3395',
      avs_result:
        'No AVS response (Typically no AVS data sent or swiped transaction)',
      cvv_result: 'No CVV2/CVC data available for transaction.',
      bin: '5555I7',
      avs_result_code: 'NA',
      cvv_result_code: null,
      cavv_result: 'N/A',
      cavv_result_code: null,
    },
    amount_details: {
      amount: 156380,
      original_requested_amount: 156380,
      original_authorized_amount: 156380,
      tax: 0,
      surcharge: 0,
      shipping: 0,
      tip: 0,
      discount: 0,
      subtotal: 156380,
    },
    transaction_details: {
      batch_id: 18674,
      description: null,
      clerk: null,
      terminal: null,
      invoice_number: null,
      po_number: null,
      order_number: null,
      source: 'Martijn dev key',
      type: 'charge',
      reference_number: null,
      schedule_id: null,
    },
    customer: { identifier: null, email: null, fax: null, customer_id: null },
    status_details: { status: 'captured' },
    custom_fields: {},
    billing_info: {
      first_name: null,
      last_name: null,
      street: null,
      street2: null,
      city: null,
      state: null,
      zip: null,
      country: null,
      phone: null,
    },
    shipping_info: {
      first_name: null,
      last_name: null,
      street: null,
      street2: null,
      city: null,
      state: null,
      zip: null,
      country: null,
      phone: null,
    },
  },
};
export const tokenizedCreditCardChargeResult = {
  version: '2.0.0',
  status: 'Approved',
  status_code: 'A',
  reference_number: 300191,
  card_type: 'MasterCard',
  last_4: '4444',
  auth_code: 'OK4315',
  auth_amount: 156380,
  avs_result:
    'No AVS response (Typically no AVS data sent or swiped transaction)',
  avs_result_code: 'NA',
  cvv2_result: 'Match',
  cvv2_result_code: 'M',
  transaction: {
    id: 300191,
    created_at: '2024-02-08T00:00:31.000Z',
    settled_date: null,
    card_details: {
      name: null,
      last4: '4444',
      expiry_month: 1,
      expiry_year: 2025,
      card_type: 'MasterCard',
      avs_street: null,
      avs_zip: null,
      auth_code: 'OK4315',
      avs_result:
        'No AVS response (Typically no AVS data sent or swiped transaction)',
      cvv_result: 'Match',
      bin: '5555I7',
      avs_result_code: 'NA',
      cvv_result_code: 'M',
      cavv_result: 'N/A',
      cavv_result_code: null,
    },
    amount_details: {
      amount: 156380,
      original_requested_amount: 156380,
      original_authorized_amount: 156380,
      tax: 0,
      surcharge: 0,
      shipping: 0,
      tip: 0,
      discount: 0,
      subtotal: 156380,
    },
    transaction_details: {
      batch_id: 18674,
      description: null,
      clerk: null,
      terminal: null,
      invoice_number: null,
      po_number: null,
      order_number: null,
      source: 'Martijn dev key',
      type: 'charge',
      reference_number: null,
      schedule_id: null,
    },
    customer: { identifier: null, email: null, fax: null, customer_id: null },
    status_details: { status: 'captured' },
    custom_fields: {},
    billing_info: {
      first_name: null,
      last_name: null,
      street: null,
      street2: null,
      city: null,
      state: null,
      zip: null,
      country: null,
      phone: null,
    },
    shipping_info: {
      first_name: null,
      last_name: null,
      street: null,
      street2: null,
      city: null,
      state: null,
      zip: null,
      country: null,
      phone: null,
    },
  },
};
export const checkChargeResult = {
  version: '2.0.0',
  status: 'Approved',
  status_code: 'A',
  reference_number: 301221,
  auth_code: 'APPROVED',
  auth_amount: 15.8,
  transaction: {
    id: 301221,
    created_at: '2024-02-08T09:36:41.000Z',
    settled_date: null,
    check_details: {
      routing_number: '490000018',
      account_number_last4: '2087',
      account_type: 'checking',
      sec_code: 'CCD',
      returned_at: null,
      returned_code: null,
      returned_reason: null,
    },
    amount_details: {
      amount: 15.8,
      tax: 0,
      surcharge: 0,
      shipping: 0,
      tip: 0,
      discount: 0,
      subtotal: 15.8,
    },
    transaction_details: {
      batch_id: null,
      description: null,
      clerk: null,
      terminal: null,
      invoice_number: null,
      po_number: null,
      order_number: null,
      source: 'Martijn dev key',
      type: 'charge',
      reference_number: null,
      schedule_id: null,
    },
    customer: { identifier: null, email: null, fax: null, customer_id: null },
    status_details: { status: 'pending' },
    custom_fields: {},
    billing_info: {
      first_name: null,
      last_name: null,
      street: null,
      street2: null,
      city: null,
      state: null,
      zip: null,
      country: null,
      phone: null,
    },
    shipping_info: {
      first_name: null,
      last_name: null,
      street: null,
      street2: null,
      city: null,
      state: null,
      zip: null,
      country: null,
      phone: null,
    },
  },
};
export const mockCardTransaction = {
  id: 332988,
  created_at: '2024-04-13T01:20:00.000Z',
  settled_date: '2024-04-14',
  card_details: {
    name: 'Hayden Zieme',
    last4: '1118',
    expiry_month: 1,
    expiry_year: 2025,
    card_type: 'Visa',
    avs_street: 'Testing address',
    avs_zip: '12345',
    auth_code: '000000',
    avs_result: 'Address: Match & 5 Digit Zip: Match',
    cvv_result: 'No CVV2/CVC data available for transaction.',
    bin: '476153',
    avs_result_code: 'YYY',
    cvv_result_code: null,
    cavv_result: 'N/A',
    cavv_result_code: null,
  },
  amount_details: {
    amount: 155880,
    original_requested_amount: 155880,
    original_authorized_amount: 155880,
    tax: 0,
    surcharge: 0,
    shipping: 0,
    tip: 0,
    discount: 0,
    subtotal: 155880,
  },
  transaction_details: {
    batch_id: 21616,
    description: 'Test recurring schedule',
    clerk: null,
    terminal: null,
    client_ip: null,
    invoice_number: null,
    po_number: null,
    order_number: null,
    signature: null,
    source: 'Recurring',
    username: null,
    type: 'charge',
    reference_number: null,
    schedule_id: 6014,
  },
  customer: {
    identifier: 'hayden.zieme12@hotmail.com',
    email: 'hayden.zieme12@hotmail.com',
    fax: null,
    customer_id: 181937,
  },
  status_details: {
    status: 'settled',
  },
  custom_fields: {},
  billing_info: {
    first_name: null,
    last_name: null,
    street: null,
    street2: null,
    city: null,
    state: null,
    zip: null,
    country: 'US',
    phone: null,
  },
  shipping_info: {
    first_name: null,
    last_name: null,
    street: null,
    street2: null,
    city: null,
    state: null,
    zip: null,
    country: 'US',
    phone: null,
  },
};
import crypto from 'node:crypto';
interface MockWebhookInput {
  scheduleId?: string;
  customFields?: { custom1: string };
}
export function createMockWebhook({
  scheduleId,
  customFields,
}: MockWebhookInput) {
  return {
    event: 'transaction',
    type: 'succeeded',
    subType: 'charge',
    id: 'wztdU5XTEQe4Y1bU56aW81FyZ8CI8N2K',
    timestamp: '2024-09-23T01:20:10.281Z',
    data: {
      version: '2.0.0',
      status: 'Approved',
      status_code: 'A',
      card_type: 'Visa',
      last_4: '1118',
      auth_code: 'TAS068',
      auth_amount: 1234,
      transaction: {
        id: 458095,
        created_at: '2024-09-23T01:20:00.000Z',
        settled_date: null,
        card_details: {
          name: 'Hayden Zieme',
          last4: '1118',
          expiry_month: 1,
          expiry_year: 2025,
          card_type: 'Visa',
          avs_street: 'Testing address',
          avs_zip: '12345',
          auth_code: 'TAS068',
          avs_result: 'Address: No Match & 5 Digit Zip: No Match',
          cvv_result: 'No CVV2/CVC data available for transaction.',
          bin: '476153',
          bin_details: { type: 'C' },
          avs_result_code: 'NNN',
          cvv_result_code: null,
          cavv_result: 'N/A',
          cavv_result_code: null,
        },
        amount_details: {
          amount: 1234,
          original_requested_amount: 1234,
          original_authorized_amount: 1234,
          tax: 0,
          surcharge: 0,
          shipping: 0,
          tip: 0,
          discount: 0,
          subtotal: 1234,
        },
        transaction_details: {
          batch_id: 26750,
          description: 'Test Subscription Laptop 13 inch 16GB',
          clerk: null,
          terminal: null,
          invoice_number: null,
          po_number: null,
          order_number: null,
          source: 'Recurring',
          type: 'charge',
          reference_number: null,
          schedule_id: scheduleId,
        },
        customer: {
          identifier: 'hayden.zieme12@hotmail.com',
          email: 'hayden.zieme12@hotmail.com',
          fax: null,
          customer_id: 181937,
        },
        status_details: { status: 'captured' },
        custom_fields: customFields ?? {},
        billing_info: {
          first_name: null,
          last_name: null,
          street: null,
          street2: null,
          city: null,
          state: null,
          zip: null,
          country: 'US',
          phone: null,
        },
        shipping_info: {
          first_name: null,
          last_name: null,
          street: null,
          street2: null,
          city: null,
          state: null,
          zip: null,
          country: 'US',
          phone: null,
        },
      },
      reference_number: 458095,
    },
  };
}
export function createSignature(webhookSecret: string, body: Object): string {
  return crypto
    .createHmac('sha256', webhookSecret)
    .update(JSON.stringify(body))
    .digest('hex');
}
```

## File: packages/vendure-plugin-accept-blue/test/helpers/test-subscription-strategy.ts

```typescript
import { Injector, Order, ProductVariant, RequestContext } from '@vendure/core';
import { Subscription, SubscriptionStrategy } from '../../src';
export class TestSubscriptionStrategy implements SubscriptionStrategy {
  defineSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    order: Order,
    orderLineCustomFields: { [key: string]: any },
    quantity: number
  ): Subscription {
    return this.getSubscriptionForVariant(productVariant);
  }
  isSubscription(ctx: RequestContext, variant: ProductVariant): boolean {
    return true;
  }
  previewSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    customInputs: any
  ): Subscription {
    return this.getSubscriptionForVariant(productVariant);
  }
  private getSubscriptionForVariant(
    productVariant: ProductVariant
  ): Subscription {
    return {
      name: `Test Subscription ${productVariant.name}`,
      priceIncludesTax: true,
      amountDueNow: 0,
      recurring: {
        amount: 4567,
        interval: 'week',
        intervalCount: 1,
        startDate: this.getTomorrow(),
      },
    };
  }
  private getTomorrow(): Date {
    const now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 12);
  }
}
```

## File: packages/vendure-plugin-accept-blue/test/accept-blue.spec.ts

```typescript
import {
  Customer,
  DefaultLogger,
  EventBus,
  LanguageCode,
  LogLevel,
  mergeConfig,
  Order,
  OrderLine,
} from '@vendure/core';
import nock from 'nock';
import {
  createTestEnvironment,
  E2E_DEFAULT_CHANNEL_TOKEN,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import { DataSource } from 'typeorm';
import { afterEach, beforeAll, describe, expect, it } from 'vitest';
import { SetShippingAddress } from '../../test/src/generated/shop-graphql';
import { initialData } from '../../test/src/initial-data';
import { AcceptBluePlugin, AcceptBlueSubscriptionEvent } from '../src';
import { acceptBluePaymentHandler } from '../src/api/accept-blue-handler';
import {
  AcceptBlueSubscription,
  MutationUpdateAcceptBlueSubscriptionArgs,
} from '../src/api/generated/graphql';
import { AcceptBlueTransactionEvent } from '../src/events/accept-blue-transaction-event';
import {
  AcceptBlueWebhook,
  AccountType,
  CheckPaymentMethodInput,
  NoncePaymentMethodInput,
  SecCode,
} from '../src/types';
import {
  ADD_ITEM_TO_ORDER,
  ADD_PAYMENT_TO_ORDER,
  CREATE_PAYMENT_METHOD,
  ELIGIBLE_AC_PAYMENT_METHODS,
  GET_CUSTOMER_WITH_ID,
  GET_HISTORY_ENTRIES,
  GET_ORDER_BY_CODE,
  GET_SURCHARGES,
  GET_USER_SAVED_PAYMENT_METHOD,
  PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT,
  PREVIEW_SUBSCRIPTIONS_FOR_VARIANT,
  REFUND_TRANSACTION,
  SET_SHIPPING_METHOD,
  TRANSITION_ORDER_TO,
  UPDATE_SUBSCRIPTION,
} from './helpers/graphql-helpers';
import {
  checkChargeResult,
  createMockRecurringScheduleResult,
  createMockWebhook,
  createSignature,
  creditCardChargeResult,
  haydenSavedPaymentMethods,
  haydenZiemeCustomerDetails,
  mockCardTransaction,
} from './helpers/mocks';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
let serverStarted = false;
let acceptBluePaymentMethod: any;
let nockInstance: nock.Scope;
let placedOrder: Order | undefined;
let testingNonceToken = {
  source: 'nonce-1234567',
  expiry_year: 2025,
  expiry_month: 1,
  last4: '4444',
};
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AcceptBluePlugin.init({
        vendureHost: 'https://my-vendure-backend.io',
      }),
    ],
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  serverStarted = true;
  nockInstance = nock('https://api.accept.blue/api/v2/');
}, 60000);
afterEach(async () => {
  nock.cleanAll();
});
it('Should start successfully', async () => {
  expect(serverStarted).toBe(true);
});
it('Creates Accept Blue payment method', async () => {
  nockInstance.get(`/webhooks`).reply(200, []);
  let receivedWebhookCreation = false;
  nockInstance
    .post(`/webhooks`, () => {
      receivedWebhookCreation = true;
      return true;
    })
    .reply(200, <AcceptBlueWebhook>{
      id: 1234,
      active: true,
      description: 'Test webhook',
      signature: 'just-a-test-secret',
    });
  await adminClient.asSuperAdmin();
  ({ createPaymentMethod: acceptBluePaymentMethod } = await adminClient.query(
    CREATE_PAYMENT_METHOD,
    {
      input: {
        code: 'accept-blue',
        enabled: true,
        handler: {
          code: acceptBluePaymentHandler.code,
          arguments: [
            { name: 'apiKey', value: 'process.env.API_KEY' },
            {
              name: 'tokenizationSourceKey',
              value: 'process.env.ACCEPT_BLUE_TOKENIZATION_SOURCE_KEY',
            },
            {
              name: 'allowVisa',
              value: 'true',
            },
            {
              name: 'allowECheck',
              value: 'true',
            },
            {
              name: 'allowMasterCard',
              value: 'true',
            },
            {
              name: 'allowGooglePay',
              value: 'true',
            },
          ],
        },
        translations: [
          { languageCode: LanguageCode.en, name: 'Accept Blue Payment Method' },
        ],
      },
    }
  ));
  await new Promise((resolve) => setTimeout(resolve, 500));
  expect(acceptBluePaymentMethod.id).toBeDefined();
  expect(receivedWebhookCreation).toBe(true);
});
describe('Shop API', () => {
  it('Returns enabled accept blue payment methods', async () => {
    const { eligibleAcceptBluePaymentMethods } = await shopClient.query(
      ELIGIBLE_AC_PAYMENT_METHODS
    );
    expect(eligibleAcceptBluePaymentMethods).toEqual([
      { name: 'ECheck' },
      { name: 'Visa' },
      { name: 'MasterCard' },
    ]);
  });
  it('Returns surcharge configuration', async () => {
    nockInstance.get('/surcharge').reply(200, {
      card: {
        type: 'currency',
        value: 0,
      },
      check: {
        type: 'currency',
        value: 0,
      },
    });
    const { acceptBlueSurcharges } = await shopClient.query(GET_SURCHARGES);
    expect(acceptBlueSurcharges).toEqual({
      card: {
        type: 'currency',
        value: 0,
      },
      check: {
        type: 'currency',
        value: 0,
      },
    });
  });
  it('Previews subscriptions for variant', async () => {
    const { previewAcceptBlueSubscriptions } = await shopClient.query(
      PREVIEW_SUBSCRIPTIONS_FOR_VARIANT,
      { productVariantId: 'T_1' }
    );
    expect(previewAcceptBlueSubscriptions?.length).toBeGreaterThan(0);
    expect(previewAcceptBlueSubscriptions[0]?.variantId).toBe('T_1');
  });
  it('Previews subscriptions for product', async () => {
    const { previewAcceptBlueSubscriptionsForProduct } = await shopClient.query(
      PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT,
      { productId: 'T_1' }
    );
    expect(previewAcceptBlueSubscriptionsForProduct?.length).toBeGreaterThan(0);
  });
  it('Gets saved payment methods for logged in customer', async () => {
    nockInstance
      .get(
        `/customers/${haydenZiemeCustomerDetails.id}/payment-methods?limit=100`
      )
      .reply(200, haydenSavedPaymentMethods);
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    await server.app
      .get(DataSource)
      .getRepository(Customer)
      .update(
        { id: 1 },
        {
          customFields: { acceptBlueCustomerId: haydenZiemeCustomerDetails.id },
        }
      );
    const {
      activeCustomer: { savedAcceptBluePaymentMethods },
    } = await shopClient.query(GET_USER_SAVED_PAYMENT_METHOD);
    expect(savedAcceptBluePaymentMethods?.length).toBe(
      haydenSavedPaymentMethods.length
    );
  });
  it('Fails to get payment methods for anonymous customer', async () => {
    await shopClient.asAnonymousUser();
    const { activeCustomer } = await shopClient.query(
      GET_USER_SAVED_PAYMENT_METHOD
    );
    expect(activeCustomer?.savedAcceptBluePaymentMethods).toBeUndefined();
  });
});
describe('Payment with Saved Payment Method', () => {
  let subscriptionIds: number[] = [];
  it('Adds item to order and set shipping address', async () => {
    await shopClient.asAnonymousUser();
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: '3',
        quantity: 1,
      }
    );
    await shopClient.query(SetShippingAddress, {
      input: {
        fullName: 'Hayden Shipping Name',
        streetLine1: 'Hayden Shipping Street 1',
        streetLine2: 'Hayden Shipping Street 2',
        city: 'City of Hayden',
        postalCode: '1234 XX',
        countryCode: 'US',
      },
    });
    expect(order.lines[0].acceptBlueSubscriptions?.[0]?.variantId).toBe('T_3');
  });
  let patchCustomerRequest: any = {};
  it('Adds payment to order', async () => {
    const queryParams = {
      active: true,
      customer_number: haydenZiemeCustomerDetails.customer_number,
    };
    nockInstance
      .persist()
      .get(`/customers`)
      .query(queryParams)
      .reply(200, [haydenZiemeCustomerDetails]);
    nockInstance
      .patch(`/customers/${haydenZiemeCustomerDetails.id}`, (body) => {
        patchCustomerRequest = body;
        return true;
      })
      .reply(200, [haydenZiemeCustomerDetails]);
    const recurringRequests: any[] = [];
    nockInstance
      .persist()
      .post(
        `/customers/${haydenZiemeCustomerDetails.id}/recurring-schedules`,
        (body) => {
          recurringRequests.push(body);
          return true;
        }
      )
      .reply(201, createMockRecurringScheduleResult(6014));
    nockInstance
      .persist()
      .post(`/transactions/charge`)
      .reply(201, checkChargeResult);
    const testPaymentMethod =
      haydenSavedPaymentMethods[haydenSavedPaymentMethods.length - 1];
    nockInstance
      .get(`/payment-methods/${testPaymentMethod.id}`)
      .reply(201, testPaymentMethod);
    await shopClient.query(SET_SHIPPING_METHOD, {
      id: [1],
    });
    await shopClient.query(TRANSITION_ORDER_TO, {
      state: 'ArrangingPayment',
    });
    const { addPaymentToOrder: order } = await shopClient.query(
      ADD_PAYMENT_TO_ORDER,
      {
        input: {
          method: acceptBluePaymentMethod.code,
          metadata: { paymentMethodId: testPaymentMethod.id },
        },
      }
    );
    placedOrder = order;
    subscriptionIds = order.lines
      .map((l: any) => l.customFields.acceptBlueSubscriptionIds)
      .flat();
    expect(order.state).toBe('PaymentSettled');
    expect(recurringRequests.length).toBe(1);
    expect(recurringRequests[0].amount).toBe(9);
  });
  it('Updated customer at Accept Blue', async () => {
    expect(patchCustomerRequest).toEqual({
      first_name: 'Hayden',
      last_name: 'Zieme',
      identifier: 'hayden.zieme12@hotmail.com',
      email: 'hayden.zieme12@hotmail.com',
      shipping_info: {
        first_name: 'Hayden',
        last_name: 'Shipping',
        street: 'Hayden Shipping Street 1',
        street2: 'Hayden Shipping Street 2',
        zip: '1234 XX',
        city: 'City of Hayden',
        country: 'US',
      },
      billing_info: { first_name: 'Hayden', last_name: 'Zieme' },
      phone: '029 1203 1336',
    });
  });
  it('Created subscriptions at Accept Blue', async () => {
    expect(subscriptionIds.length).toBeGreaterThan(0);
  });
});
describe('Payment with Credit Card Payment Method', () => {
  let createdSubscriptionIds: number[] = [];
  it('Adds item to order', async () => {
    await shopClient.asAnonymousUser();
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: '1',
        quantity: 1,
      }
    );
    expect(order.lines[0].acceptBlueSubscriptions?.[0]?.variantId).toBe('T_1');
  });
  it('Adds payment to order', async () => {
    const queryParams = {
      active: true,
      customer_number: haydenZiemeCustomerDetails.customer_number,
    };
    nockInstance
      .persist()
      .get(`/customers`)
      .query(queryParams)
      .reply(200, [haydenZiemeCustomerDetails]);
    nockInstance
      .persist()
      .get(
        `/customers/${haydenZiemeCustomerDetails.id}/payment-methods?limit=100`
      )
      .reply(200, haydenSavedPaymentMethods);
    nockInstance
      .persist()
      .post(`/customers/${haydenZiemeCustomerDetails.id}/recurring-schedules`)
      .reply(201, createMockRecurringScheduleResult());
    nockInstance
      .persist()
      .post(`/transactions/charge`)
      .reply(201, creditCardChargeResult);
    await shopClient.query(SET_SHIPPING_METHOD, {
      id: [1],
    });
    await shopClient.query(TRANSITION_ORDER_TO, {
      state: 'ArrangingPayment',
    });
    const metadata: NoncePaymentMethodInput = {
      source: testingNonceToken.source,
      expiry_year: testingNonceToken.expiry_year,
      expiry_month: testingNonceToken.expiry_month,
      last4: testingNonceToken.last4,
    };
    const { addPaymentToOrder: order } = await shopClient.query(
      ADD_PAYMENT_TO_ORDER,
      {
        input: {
          method: acceptBluePaymentMethod.code,
          metadata,
        },
      }
    );
    createdSubscriptionIds = order.lines
      .map((l: any) => l.customFields.acceptBlueSubscriptionIds)
      .flat();
    expect(order.state).toBe('PaymentSettled');
  });
  it('Created subscriptions at Accept Blue', async () => {
    expect(createdSubscriptionIds.length).toBeGreaterThan(0);
  });
});
describe('Payment with Check Payment Method', () => {
  let createdSubscriptionIds: number[] = [];
  it('Adds item to order', async () => {
    await shopClient.asAnonymousUser();
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: '3',
        quantity: 1,
      }
    );
    expect(order.lines[0].acceptBlueSubscriptions?.[0]?.variantId).toBe('T_3');
  });
  it('Adds payment to order', async () => {
    const queryParams = {
      active: true,
      customer_number: haydenZiemeCustomerDetails.customer_number,
    };
    nockInstance
      .persist()
      .get(`/customers`)
      .query(queryParams)
      .reply(200, [haydenZiemeCustomerDetails]);
    nockInstance
      .persist()
      .get(
        `/customers/${haydenZiemeCustomerDetails.id}/payment-methods?limit=100`
      )
      .reply(200, haydenSavedPaymentMethods);
    nockInstance
      .persist()
      .post(`/customers/${haydenZiemeCustomerDetails.id}/recurring-schedules`)
      .reply(201, createMockRecurringScheduleResult());
    nockInstance
      .persist()
      .post(`/transactions/charge`)
      .reply(201, checkChargeResult);
    await shopClient.query(SET_SHIPPING_METHOD, {
      id: [1],
    });
    await shopClient.query(TRANSITION_ORDER_TO, {
      state: 'ArrangingPayment',
    });
    const testCheck =
      haydenSavedPaymentMethods[haydenSavedPaymentMethods.length - 1];
    const metadata: CheckPaymentMethodInput = {
      name: testCheck.name!,
      routing_number: testCheck.routing_number!,
      account_number: testCheck.account_number!,
      account_type: testCheck.account_type! as AccountType,
      sec_code: testCheck.sec_code! as SecCode,
    };
    const { addPaymentToOrder: order } = await shopClient.query(
      ADD_PAYMENT_TO_ORDER,
      {
        input: {
          method: acceptBluePaymentMethod.code,
          metadata,
        },
      }
    );
    createdSubscriptionIds = order.lines
      .map((l: any) => l.customFields.acceptBlueSubscriptionIds)
      .flat();
    expect(order.state).toBe('PaymentSettled');
  });
  it('Created subscriptions at Accept Blue', async () => {
    expect(createdSubscriptionIds.length).toBeGreaterThan(0);
  });
});
describe('Payment with Google Pay', () => {
  let createdSubscriptionIds: number[] = [];
  it('Prepares an order for payment', async () => {
    await shopClient.asAnonymousUser();
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: '3',
        quantity: 1,
      }
    );
    await shopClient.query(SET_SHIPPING_METHOD, {
      id: [1],
    });
    const { transitionOrderToState } = await shopClient.query(
      TRANSITION_ORDER_TO,
      {
        state: 'ArrangingPayment',
      }
    );
    expect(order.lines[0].acceptBlueSubscriptions?.[0]?.variantId).toBe('T_3');
    expect(transitionOrderToState.state).toBe('ArrangingPayment');
  });
  it('Adds payment to order', async () => {
    let chargeRequest: any = {};
    nockInstance
      .persist()
      .post(`/transactions/charge`, (req) => {
        chargeRequest = req;
        return true;
      })
      .reply(201, {
        reference_number: 1234,
        transaction: { id: 3333 },
      });
    nockInstance
      .persist()
      .get(`/customers`)
      .query(true)
      .reply(200, [haydenZiemeCustomerDetails]);
    let createPaymentMethodRequest: any = {};
    nockInstance
      .post(
        `/customers/${haydenZiemeCustomerDetails.id}/payment-methods`,
        (req) => {
          createPaymentMethodRequest = req;
          return true;
        }
      )
      .reply(200, {
        id: 6789,
      });
    nockInstance
      .persist()
      .post(`/customers/${haydenZiemeCustomerDetails.id}/recurring-schedules`)
      .reply(201, createMockRecurringScheduleResult());
    const { addPaymentToOrder: order } = await shopClient.query(
      ADD_PAYMENT_TO_ORDER,
      {
        input: {
          method: acceptBluePaymentMethod.code,
          metadata: {
            source: 'googlepay',
            amount: 15.8,
            token: 'encrypted',
          },
        },
      }
    );
    createdSubscriptionIds = order.lines
      .map((l: any) => l.customFields.acceptBlueSubscriptionIds)
      .flat();
    expect(order.state).toBe('PaymentSettled');
    expect(chargeRequest.amount).toBe(15.8);
    expect(chargeRequest.source).toBe('googlepay');
    expect(chargeRequest.token).toBe('encrypted');
    expect(createPaymentMethodRequest.source).toBe('ref-1234');
  });
  it('Created subscriptions at Accept Blue', async () => {
    expect(createdSubscriptionIds.length).toBeGreaterThan(0);
  });
});
describe('Transactions', () => {
  let orderLineWithSubscription: OrderLine;
  it('Emits transaction event for incoming schedule payments webhook', async () => {
    const events: AcceptBlueTransactionEvent[] = [];
    server.app
      .get(EventBus)
      .ofType(AcceptBlueTransactionEvent)
      .subscribe((event) => events.push(event));
    const subscriptionId = placedOrder?.lines
      .map((l: any) => l.customFields.acceptBlueSubscriptionIds)
      .flat()?.[0];
    const mockWebhook = createMockWebhook({ scheduleId: subscriptionId });
    const signature = createSignature('just-a-test-secret', mockWebhook);
    const result = await shopClient.fetch(
      `http://localhost:3050/accept-blue/webhook/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(mockWebhook),
        headers: {
          'x-signature': signature,
        },
      }
    );
    expect(result.status).toBe(201);
    expect(events.length).toBe(1);
    orderLineWithSubscription = events[0].orderLine;
    const orderLine = events[0].orderLine;
    expect((orderLine.customFields as any).acceptBlueSubscriptionIds).toContain(
      subscriptionId
    );
    expect(orderLine.order.code).toBe(placedOrder?.code);
    expect(orderLine.order.customer?.emailAddress).toBeDefined();
  });
  it('Emits transaction event for incoming one-off payments webhook', async () => {
    const events: AcceptBlueTransactionEvent[] = [];
    server.app
      .get(EventBus)
      .ofType(AcceptBlueTransactionEvent)
      .subscribe((event) => events.push(event));
    const mockWebhook = createMockWebhook({
      customFields: { custom1: JSON.stringify([orderLineWithSubscription.id]) },
    });
    const signature = createSignature('just-a-test-secret', mockWebhook);
    const result = await shopClient.fetch(
      `http://localhost:3050/accept-blue/webhook/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(mockWebhook),
        headers: {
          'x-signature': signature,
        },
      }
    );
    expect(result.status).toBe(201);
    expect(events.length).toBe(1);
    expect(events[0].orderLine.id).toBe(orderLineWithSubscription.id);
    expect(events[0].orderLine.order.code).toBe(placedOrder?.code);
    expect(events[0].orderLine.order.customer?.emailAddress).toBeDefined();
  });
  it('Has transactions per subscription', async () => {
    nockInstance
      .get(`/recurring-schedules/6014`)
      .reply(200, createMockRecurringScheduleResult(6014));
    nockInstance
      .get(`/recurring-schedules/6014/transactions`)
      .reply(200, [mockCardTransaction]);
    const { orderByCode } = await shopClient.query(GET_ORDER_BY_CODE, {
      code: placedOrder?.code,
    });
    const transaction =
      orderByCode.lines[0].acceptBlueSubscriptions[0].transactions[0];
    expect(transaction.status).toBe('settled');
    expect(transaction.cardDetails).toBeDefined();
    expect(transaction.amount).toBeDefined();
  });
});
describe('Admin API', () => {
  it('Refunds a transaction', async () => {
    await adminClient.asSuperAdmin();
    let refundRequest: any;
    nockInstance
      .post(`/transactions/refund`, (body) => {
        refundRequest = body;
        return true;
      })
      .reply(200, {
        version: 'version1',
        status: 'Partially Approved',
        error_message: 'Some error message',
        error_code: 'E100',
        error_details: { detail: 'An error detail object' },
        reference_number: 123,
      });
    const { refundAcceptBlueTransaction } = await adminClient.query(
      REFUND_TRANSACTION,
      {
        transactionId: 123,
        amount: 4567,
        cvv2: '999',
      }
    );
    expect(refundRequest.reference_number).toBe(123);
    expect(refundRequest.amount).toBe(45.67);
    expect(refundRequest.cvv2).toBe('999');
    expect(refundAcceptBlueTransaction.referenceNumber).toBe(123);
    expect(refundAcceptBlueTransaction.version).toBe('version1');
    expect(refundAcceptBlueTransaction.status).toBe('PartiallyApproved');
    expect(refundAcceptBlueTransaction.errorMessage).toBe('Some error message');
    expect(refundAcceptBlueTransaction.errorCode).toBe('E100');
    expect(refundAcceptBlueTransaction.errorDetails).toBe(
      '{"detail":"An error detail object"}'
    );
  });
  it('Fails to refund when not logged in', async () => {
    await adminClient.asAnonymousUser();
    let error: any;
    try {
      await adminClient.query(REFUND_TRANSACTION, {
        transactionId: 123,
        amount: 4567,
        cvv2: '999',
      });
    } catch (e) {
      error = e;
    }
    expect(error?.response?.errors?.[0]?.extensions.code).toEqual('FORBIDDEN');
  });
  it('Gets saved payment methods for customer', async () => {
    nockInstance
      .persist()
      .get(
        `/customers/${haydenZiemeCustomerDetails.id}/payment-methods?limit=100`
      )
      .reply(200, haydenSavedPaymentMethods);
    await adminClient.asSuperAdmin();
    const { customer } = await adminClient.query(GET_CUSTOMER_WITH_ID, {
      id: '1',
    });
    expect(customer?.savedAcceptBluePaymentMethods?.length).toBeGreaterThan(0);
  });
  it('Does not allow updating subscriptions by unauthorized admins', async () => {
    await adminClient.asAnonymousUser();
    const updateRequest = adminClient.query<
      { updateAcceptBlueSubscription: AcceptBlueSubscription },
      MutationUpdateAcceptBlueSubscriptionArgs
    >(UPDATE_SUBSCRIPTION, {
      input: {
        id: 123,
        active: false,
      },
    });
    await expect(updateRequest).rejects.toThrowError(
      'You are not currently authorized to perform this action'
    );
  });
  const events: AcceptBlueSubscriptionEvent[] = [];
  it('Updates a subscription', async () => {
    server.app
      .get(EventBus)
      .ofType(AcceptBlueSubscriptionEvent)
      .subscribe((event) => events.push(event));
    await adminClient.asSuperAdmin();
    const scheduleId = 6014;
    let updateRequest: any;
    nockInstance
      .persist()
      .patch(`/recurring-schedules/${scheduleId}`, (body) => {
        updateRequest = body;
        return true;
      })
      .reply(200, createMockRecurringScheduleResult(scheduleId));
    const tenDaysFromNow = new Date();
    tenDaysFromNow.setDate(tenDaysFromNow.getDate() + 10);
    await adminClient.query<any, MutationUpdateAcceptBlueSubscriptionArgs>(
      UPDATE_SUBSCRIPTION,
      {
        input: {
          id: scheduleId,
          amount: 4321,
          active: false,
          frequency: 'biannually',
          nextRunDate: tenDaysFromNow,
          numLeft: 5,
          title: 'Updated title',
          receiptEmail: 'newCustomer@pinelab.studio',
        },
      }
    );
    expect(updateRequest).toEqual({
      active: false,
      title: 'Updated title',
      amount: 43.21,
      frequency: 'biannually',
      next_run_date: tenDaysFromNow.toISOString().substring(0, 10),
      num_left: 5,
      receipt_email: 'newCustomer@pinelab.studio',
    });
  });
  it('Has created history entries', async () => {
    await adminClient.asSuperAdmin();
    const { order } = await adminClient.query(GET_HISTORY_ENTRIES, {
      id: placedOrder?.id,
    });
    const entry = order.history.items.find(
      (entry: any) => entry.type === 'ORDER_NOTE'
    );
    expect(entry?.data.note).toContain('Subscription updated:');
  });
  it('Has published Subscription Event', async () => {
    const event = events[0];
    expect(events.length).toBe(1);
    expect(event.subscription.id).toBe(6014);
    expect(event.type).toBe('updated');
  });
});
```

## File: packages/vendure-plugin-accept-blue/test/dev-server.ts

```typescript
import {} from '../src/api/custom-field-types';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LanguageCode,
  LogLevel,
  mergeConfig,
  VendureConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import readline from 'readline';
import { AcceptBluePlugin } from '../src';
import { acceptBluePaymentHandler } from '../src/api/accept-blue-handler';
import { AcceptBlueTestCheckoutPlugin } from './helpers/accept-blue-test-checkout.plugin';
import {
  ADD_ITEM_TO_ORDER,
  ADD_PAYMENT_TO_ORDER,
  CREATE_PAYMENT_METHOD,
  GET_ORDER_BY_CODE,
  REFUND_TRANSACTION,
  SET_SHIPPING_METHOD,
  TRANSITION_ORDER_TO,
} from './helpers/graphql-helpers';
import { AppleOrGooglePayInput, NoncePaymentMethodInput } from '../src/types';
import { add } from 'date-fns';
import { TestSubscriptionStrategy } from './helpers/test-subscription-strategy';
import { SetShippingAddress } from '../../test/src/generated/shop-graphql';
(async () => {
  require('dotenv').config();
  const tokenizationSourceKey =
    process.env.ACCEPT_BLUE_TOKENIZATION_SOURCE_KEY ?? '';
  if (!tokenizationSourceKey.length) {
    console.log(
      "Missing Accept Blue tokenizationSourceKey. Please look it up on the dashboard and add it to the environment key 'ACCEPT_BLUE_TOKENIZATION_SOURCE_KEY'"
    );
  }
  // eslint-disable-next-line
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config: Required<VendureConfig> = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    dbConnectionOptions: {
      // autoSave: true, // Uncomment this line to persist the database between restarts
    },
    authOptions: {},
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    plugins: [
      AcceptBlueTestCheckoutPlugin,
      AcceptBluePlugin.init({
        // vendureHost: process.env.VENDURE_HOST as string,
        // Our temp webhook to catch the webhook from Accept Blue. View on: https://webhook.site/#!/view/cdef50e0-0e6d-4e23-a4b1-6ffc9ca89df8/2077d0c4-7cfb-4c81-b966-370ba5a44d7e/1
        vendureHost:
          'https://webhook.site/cdef50e0-0e6d-4e23-a4b1-6ffc9ca89df8',
        subscriptionStrategy: new TestSubscriptionStrategy(),
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      // eslint-disable-next-line
      ...require('../../test/src/initial-data').initialData,
      shippingMethods: [{ name: 'Standard Shipping', price: 0 }],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  const port = config.apiOptions?.port ?? '';
  console.log(`Vendure server now running on port ${port}`);
  console.log('Test tokenization:', `http://localhost:${port}/checkout`);
  console.log('Test Google Pay:', `http://localhost:${port}/google-pay`);
  // Create Accept Blue payment method
  await adminClient.asSuperAdmin();
  await adminClient.query(CREATE_PAYMENT_METHOD, {
    input: {
      code: 'accept-blue',
      enabled: true,
      handler: {
        code: acceptBluePaymentHandler.code,
        arguments: [
          { name: 'apiKey', value: process.env.API_KEY },
          { name: 'pin', value: process.env.PIN },
          { name: 'testMode', value: 'true' },
          { name: 'allowECheck', value: 'true' },
          { name: 'allowGooglePay', value: 'true' },
          { name: 'allowApplePay', value: 'true' },
          {
            name: 'tokenizationSourceKey',
            value: process.env.ACCEPT_BLUE_TOKENIZATION_SOURCE_KEY ?? null,
          },
        ],
      },
      translations: [
        {
          languageCode: LanguageCode.en,
          name: 'Accept blue test payment',
        },
      ],
    },
  });
  console.log(`Created paymentMethod`);
  // Prepare sample order
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await shopClient.query(ADD_ITEM_TO_ORDER, {
    productVariantId: '3',
    quantity: 1,
  });
  console.log(`Added item`);
  await shopClient.query(SetShippingAddress, {
    input: {
      fullName: 'Hayden Shipping Name',
      streetLine1: 'Hayden Shipping Street 1',
      streetLine2: 'Hayden Shipping Street 2',
      city: 'City of Hayden',
      postalCode: '1234 XX',
      countryCode: 'US',
    },
  });
  await shopClient.query(SET_SHIPPING_METHOD, {
    id: [1],
  });
  console.log(`Shipping method set`);
  const { transitionOrderToState } = await shopClient.query(
    TRANSITION_ORDER_TO,
    {
      state: 'ArrangingPayment',
    }
  );
  console.log(
    `Transitioned order '${transitionOrderToState.code}' to ArrangingPayment`
  );
  // Add payment
  // Use this metadata in AddpaymentToOrder to use a one time nonce for payment method creation
  // const metadata: NoncePaymentMethodInput = {
  //   source: 'nonce-h301nyq2kycko8b6v6sr',
  //   last4: '1115',
  //   expiry_year: 2030,
  //   expiry_month: 3,
  // };
  const metadata: AppleOrGooglePayInput = {
    source: 'googlepay',
    amount: 10.8,
    token:
      '{"signature":"MEUCIFZG/zqpZQohvMILpMEPRC/HzlYsUvJVTlcjuh6ddNZhAiEAyRldHj7sC9xbnCa00u8dUzwRYMOoENTQqm6tyldRcDU\\u003d","intermediateSigningKey":{"signedKey":"{\\"keyValue\\":\\"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEscxfstKIwGYw8f2aybtHUYjaEKXpXh4c4uEN3NC0kZnawXUpGew8DWdS+vYOVZ5O639ZkRL32L5FeKcb0Wvdlg\\\\u003d\\\\u003d\\",\\"keyExpiration\\":\\"1743759806251\\"}","signatures":["MEYCIQCWPi+p9C/kgQMIuIUeNKRPxPWMORGO7xlm9NrMa6tfbAIhAPyJkxEIPP/ECk3U766OyHvhP5jfAk3/F2giIlNVUHIV"]},"protocolVersion":"ECv2","signedMessage":"{\\"encryptedMessage\\":\\"rXjz4P5ugdTumQ0s3B+kj7PcRDAkxJghyP/flpbxqTz40g4zaYAA9QrG+nX/bJg86I7j6NQU+cJLGTirN196p0bVCqOotx46DeOHXqDG5W2QFabxKa3igcxZ0bbQ3+OQxPN52Vz9jR1lNZkA+ZF4sckK4rtPJJltxxswVCgZm+YNUtTNb7hBh7eoJcu0WJCUv0obNcufJEz8+KoQJiaPu4TwmaIT9RanqKqlHzarXQdOhmHQJiOXfGiP8GeMaROuL9E2h8PowEyjbHEKrx0KjtRW2Jlk2wEQW4GIhietVOvO/9JpesepWX8vfn/HuVsOmXsj9BwBtKEX3Z5r9XlnMWzd8q8U8/1WUPZZgn8Q0B5vdOdzn7srmo4lFKrRBZTeyLjMZGdyINHh5ZSajWZmI9NeucEk3ZvIxAW0bV/mD5OOFmQOetclyldcEMxwsXO7E0TSp65GMAobGwNHkOd0wCN2DMyBxT4Vh4hN0dfZD4lDU2qUWjEc+/GPl/++g+s3rUR1KjyPSH06wv3yqmSG+u/0Gof/mfPoZyf1TRm6UzcFTY8HmoPeR3Oo\\",\\"ephemeralPublicKey\\":\\"BKgk4yeCEVqfZTHIAegqcnABhcc9x4v8IRQZbO7QZMEWAKBeJ9Q/fVKZgs/Tt9WyAKkH7FBfbBTbjEdh+j+3sFc\\\\u003d\\",\\"tag\\":\\"xslhQIESD/gFKNAb/SlRwD9gg8oVMiNQaSOIHFxA5Yo\\\\u003d\\"}"}',
  };
  try {
    const { addPaymentToOrder } = await shopClient.query(ADD_PAYMENT_TO_ORDER, {
      input: {
        method: 'accept-blue',
        metadata,
      },
    });
    console.log(JSON.stringify);
    console.log(
      `Successfully transitioned order to ${addPaymentToOrder.state}`
    );
  } catch (e) {
    console.error(e);
  }
})();
```

## File: packages/vendure-plugin-admin-social-auth/src/api/google-auth-strategy.ts

```typescript
import {
  AdministratorService,
  AuthenticationStrategy,
  ExternalAuthenticationMethod,
  Injector,
  Logger,
  RequestContext,
  TransactionalConnection,
  User,
} from '@vendure/core';
import { DocumentNode } from 'graphql';
import gql from 'graphql-tag';
export interface GoogleAuthData {
  credentialJWT: string;
}
const loggerCtx = 'GoogleAuthStrategy';
export class GoogleAuthStrategy
  implements AuthenticationStrategy<GoogleAuthData>
{
  readonly name = 'google';
  private client!: import('google-auth-library').OAuth2Client;
  private adminService: AdministratorService | undefined;
  private connection: TransactionalConnection | undefined;
  constructor(private readonly clientId: string) {}
  async init(injector: Injector) {
    this.adminService = injector.get(AdministratorService);
    this.connection = injector.get(TransactionalConnection);
    const { OAuth2Client } = await import('google-auth-library');
    this.client = new OAuth2Client(this.clientId);
  }
  defineInputType(): DocumentNode {
    return gql`
      input GoogleAuthInput {
        """
        The encoded response credential returned by the Google Sign-In API
        """
        credentialJWT: String!
      }
    `;
  }
  async authenticate(
    ctx: RequestContext,
    { credentialJWT }: GoogleAuthData
  ): Promise<User | false> {
    // Here is the logic that uses the token provided by the storefront and uses it
    // to find the user data from Google.
    try {
      const ticket = await this.client.verifyIdToken({
        idToken: credentialJWT,
        audience: this.clientId,
      });
      const payload = ticket.getPayload();
      if (!payload || !payload.email) {
        return false;
      }
      const email = payload.email;
      // First we check to see if this user is an admin in our Vendure server
      const admins = await this.adminService!.findAll(
        ctx,
        { filter: { emailAddress: { eq: email } } },
        ['user', 'user.authenticationMethods']
      );
      if (admins.totalItems > 1) {
        Logger.error(
          `Multiple admins for '${email}' found. Only one should exist. Unable to login`,
          loggerCtx
        );
        return false;
      }
      if (admins.totalItems === 0) {
        Logger.warn(
          `Attempted login from user that is not an administrator`,
          loggerCtx
        );
        return false;
      }
      const admin = admins.items[0];
      let user = admin.user;
      const hasGoogleAuth = user.authenticationMethods.find(
        (m) => (m as ExternalAuthenticationMethod).strategy === this.name
      );
      if (!hasGoogleAuth) {
        user = await this.addGoogleAuthMethod(ctx, user, email);
      }
      Logger.info(`Admin '${email}' logged in`, loggerCtx);
      return user;
    } catch (error) {
      if (error instanceof Error) {
        Logger.error(
          `Error authenticating with Google login: ${error.message}`,
          loggerCtx,
          error.stack
        );
      } else {
        Logger.error(
          `Unknown error authenticating with Google login: ${String(error)}`,
          loggerCtx
        );
      }
      return false;
    }
  }
  private async addGoogleAuthMethod(
    ctx: RequestContext,
    user: User,
    externalIdentifier: string
  ): Promise<User> {
    const googleAuthMethod = await this.connection!.getRepository(
      ctx,
      ExternalAuthenticationMethod
    ).save(
      new ExternalAuthenticationMethod({
        externalIdentifier,
        strategy: this.name,
      })
    );
    user.authenticationMethods.push(googleAuthMethod);
    return await this.connection!.getRepository(ctx, User).save(user);
  }
}
```

## File: packages/vendure-plugin-admin-social-auth/src/api/login-controller.ts

```typescript
import { Controller, Get, Inject, Res } from '@nestjs/common';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { AdminUiConfig } from '@vendure/common/lib/shared-types';
import { ConfigService, VENDURE_VERSION } from '@vendure/core';
import { Response } from 'express';
import fs from 'fs/promises';
import Handlebars from 'handlebars';
import { AdminSocialAuthPluginOptions } from '../admin-social-auth.plugin';
import { PLUGIN_INIT_OPTIONS } from '../constants';
@Controller()
export class LoginController {
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS)
    private readonly options: AdminSocialAuthPluginOptions,
    private readonly configService: ConfigService
  ) {}
  @Get('social-auth/login')
  async getLogin(@Res() res: Response): Promise<void> {
    const adminUiConfig: Partial<AdminUiConfig> | undefined = (
      AdminUiPlugin as any
    ).options?.adminUiConfig;
    const loginHtml = await fs.readFile(
      `${__dirname}/../ui/login.html`,
      'utf8'
    );
    const tokenMethod = this.configService.authOptions.tokenMethod;
    const rendered = Handlebars.compile(loginHtml)({
      clientId: this.options.google?.oAuthClientId,
      version: VENDURE_VERSION,
      brand: adminUiConfig?.brand,
      hideVendureBranding: adminUiConfig?.hideVendureBranding,
      isCookieTokenMethodEnabled:
        tokenMethod === 'cookie' || tokenMethod.includes('cookie'),
      hideVersion: adminUiConfig?.hideVersion,
    });
    res.send(rendered);
  }
}
```

## File: packages/vendure-plugin-admin-social-auth/src/admin-social-auth.plugin.ts

```typescript
import { Logger, PluginCommonModule, Type, VendurePlugin } from '@vendure/core';
import { GoogleAuthStrategy } from './api/google-auth-strategy';
import { LoginController } from './api/login-controller';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from './constants';
export interface GoogleInput {
  oAuthClientId: string;
}
export interface AdminSocialAuthPluginOptions {
  google?: GoogleInput;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [LoginController],
  providers: [
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => AdminSocialAuthPlugin.options,
    },
  ],
  configuration: (config) => {
    const pluginOptions = AdminSocialAuthPlugin.options;
    config.authOptions.adminAuthenticationStrategy = [];
    if (pluginOptions.google?.oAuthClientId) {
      config.authOptions.adminAuthenticationStrategy.push(
        new GoogleAuthStrategy(pluginOptions.google.oAuthClientId)
      );
      Logger.info(`Registered Google auth login for administrators`, loggerCtx);
    }
    return config;
  },
  compatibility: '>=2.2.0',
})
export class AdminSocialAuthPlugin {
  static options: AdminSocialAuthPluginOptions;
  static init(
    options: AdminSocialAuthPluginOptions
  ): Type<AdminSocialAuthPlugin> {
    this.options = options;
    return AdminSocialAuthPlugin;
  }
}
```

## File: packages/vendure-plugin-admin-social-auth/src/constants.ts

```typescript
export const loggerCtx = 'AdminSocialAuthPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-admin-social-auth/src/index.ts

```typescript
export * from './admin-social-auth.plugin';
export * from './api/google-auth-strategy';
export * from './api/login-controller';
```

## File: packages/vendure-plugin-admin-social-auth/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  AdministratorService,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import path from 'path';
import { AdminSocialAuthPlugin } from '../src';
import { initialData } from '../../test/src/initial-data';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AdminSocialAuthPlugin.init({
        google: {
          oAuthClientId: process.env.GOOGLE_OAUTH_CLIENT_ID!,
        },
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 5001,
        route: 'admin',
        adminUiConfig: {
          loginUrl: '/social-auth/login',
          brand: 'Pinelab',
          hideVendureBranding: false,
          hideVersion: false,
        },
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  const ctx = await getSuperadminContext(server.app);
  const result = await server.app.get(AdministratorService).create(ctx, {
    emailAddress: 'martijn@pinelab.studio',
    firstName: 'Martijn',
    lastName: 'Pinelab',
    roleIds: ['1'],
    password: 'test',
  });
  console.log(`Created admin user ${result.emailAddress}`);
})();
```

## File: packages/vendure-plugin-admin-social-auth/test/e2e.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { afterAll, beforeAll, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { AdminSocialAuthPlugin } from '../src';
let server: TestServer;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AdminSocialAuthPlugin.init({
        google: {
          oAuthClientId: 'Just a test',
        },
      }),
    ],
  });
  ({ server } = createTestEnvironment(config));
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
}, 60000);
it('Should start successfully', () => {
  expect(server.app.getHttpServer()).toBeDefined();
});
afterAll(() => {
  return server.destroy();
});
```

## File: packages/vendure-plugin-admin-ui-helpers/src/ui/cancel-order-button.module.ts

```typescript
import { addActionBarItem, SharedModule } from '@vendure/admin-ui/core';
import { NgModule } from '@angular/core';
import { Observable, firstValueFrom } from 'rxjs';
import { cancel, mapEntityToButtonState, refund } from './order-state.util';
import { RouterModule } from '@angular/router';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forRoot([], { onSameUrlNavigation: 'reload' }),
  ],
  providers: [
    addActionBarItem({
      id: 'refund-order',
      label: 'Cancel',
      disabled: new Observable<boolean>((subscriber) => {
        subscriber.next(false);
      }),
      buttonColor: 'warning',
      buttonStyle: 'outline',
      icon: 'times-circle',
      locationId: 'order-detail',
      buttonState: mapEntityToButtonState,
      routerLink: [],
      onClick: async (event, { route, dataService, notificationService }) => {
        try {
          if (!window.confirm('This will cancel and refund. Are you sure?')) {
            return;
          }
          const orderId = route.snapshot.params.id;
          const response = await firstValueFrom(
            dataService.order.getOrder(orderId).single$
          );
          if (!response?.order) {
            return notificationService.error('Could not find order...');
          }
          if (
            response.order.state === 'PaymentSettled' ||
            response.order.state === 'Delivered' ||
            response.order.state === 'Shipped'
          ) {
            await refund(dataService, response.order);
          }
          await cancel(dataService, response.order);
          notificationService.success('Order refunded and cancelled');
        } catch (e: any) {
          notificationService.error(e.message);
          console.error(e);
        }
      },
    }),
  ],
})
export class CancelOrderButtonModule {}
```

## File: packages/vendure-plugin-admin-ui-helpers/src/ui/complete-order-button.module.ts

```typescript
import { addActionBarItem, SharedModule } from '@vendure/admin-ui/core';
import { NgModule } from '@angular/core';
import { Observable } from 'rxjs';
import {
  mapEntityToButtonState,
  transitionToDelivered,
  transitionToShipped,
} from './order-state.util';
import { RouterModule } from '@angular/router';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forRoot([], { onSameUrlNavigation: 'reload' }),
  ],
  providers: [
    addActionBarItem({
      id: 'complete-order',
      label: 'Complete',
      disabled: new Observable<boolean>((subscriber) => {
        subscriber.next(false);
      }),
      buttonColor: 'success',
      buttonStyle: 'outline',
      icon: 'check-circle',
      locationId: 'order-detail',
      buttonState: mapEntityToButtonState,
      routerLink: [],
      onClick: async (event, { route, dataService, notificationService }) => {
        try {
          if (!window.confirm('Are you sure? This can not be undone.')) {
            return;
          }
          const orderId = route.snapshot.params.id;
          let getOrderResponse = await dataService.order
            .getOrder(orderId)
            .single$.toPromise();
          if (!getOrderResponse?.order) {
            return notificationService.error('Could not find order...');
          }
          if (getOrderResponse?.order.state === 'AddingItems') {
            return notificationService.error(
              'Active orders cannot be completed.'
            );
          }
          if (getOrderResponse?.order.state === 'Delivered') {
            return notificationService.warning('Order is already Delivered.');
          }
          if (getOrderResponse?.order.state === 'Cancelled') {
            return notificationService.error('Order is already Cancelled.');
          }
          if (getOrderResponse?.order.state === 'PaymentSettled') {
            await transitionToShipped(dataService, getOrderResponse.order);
            await dataService.order.getOrder(orderId).single$.toPromise();
          }
          if (getOrderResponse?.order!.state === 'Shipped') {
            await transitionToDelivered(dataService, getOrderResponse.order);
          }
          await dataService.order.getOrder(orderId).single$.toPromise();
          notificationService.success('Order completed');
        } catch (e: any) {
          notificationService.error(e.message);
          console.error(e);
        }
      },
    }),
  ],
})
export class CompleteOrderButtonModule {}
```

## File: packages/vendure-plugin-admin-ui-helpers/src/ui/order-state.util.ts

```typescript
import { ActionBarContext, DataService } from '@vendure/admin-ui/core';
import {
  FulfillmentStateTransitionError,
  OrderDetailFragment,
} from '@vendure/admin-ui/core';
import { map } from 'rxjs';
import { ErrorResult, RefundOrderStateError } from '@vendure/core';
export async function transitionToShipped(
  dataService: DataService,
  order: OrderDetailFragment
): Promise<void> {
  const response = await dataService.shippingMethod
    .getShippingMethodOperations()
    .single$.toPromise();
  const handlerCode =
    order.shippingLines[0].shippingMethod.fulfillmentHandlerCode;
  const handler = (response?.fulfillmentHandlers ?? []).find(
    (handler) => handler.code === handlerCode
  );
  if (!handler) {
    throw Error(`No handler found for ${handlerCode}`);
  }
  const args = handler.args.map((arg) => ({ name: arg.name, value: '' }));
  const createFullfilmentResponse = await dataService.order
    .createFulfillment({
      handler: {
        code: handlerCode,
        arguments: args,
      },
      lines: order.lines.map((line) => ({
        quantity: line.quantity,
        orderLineId: String(line.id),
      })),
    })
    .toPromise();
  let fulfillmentId = (createFullfilmentResponse?.addFulfillmentToOrder as any)
    ?.id;
  const errorResult =
    createFullfilmentResponse?.addFulfillmentToOrder as FulfillmentStateTransitionError;
  if (errorResult?.errorCode === 'ITEMS_ALREADY_FULFILLED_ERROR') {
    fulfillmentId = order.fulfillments?.[0].id;
  } else if (errorResult.errorCode) {
    throw Error(`${errorResult.errorCode} - ${errorResult.transitionError}`);
  }
  const transitionFulfillmentToStateResponse = await dataService.order
    .transitionFulfillmentToState(fulfillmentId, 'Shipped')
    .toPromise();
  const transitionError =
    transitionFulfillmentToStateResponse?.transitionFulfillmentToState as FulfillmentStateTransitionError;
  if (transitionError?.errorCode) {
    throw Error(`${errorResult.errorCode} - ${errorResult.transitionError}`);
  }
}
export async function transitionToDelivered(
  dataService: DataService,
  order: OrderDetailFragment
): Promise<void> {
  const fulfillmentId = order.fulfillments?.[0].id;
  const transitionFulfillmentToStateResponse = await dataService.order
    .transitionFulfillmentToState(fulfillmentId!, 'Delivered')
    .toPromise();
  const transitionError =
    transitionFulfillmentToStateResponse?.transitionFulfillmentToState as FulfillmentStateTransitionError;
  if (transitionError?.errorCode?.indexOf('"Delivered" to "Delivered"') > -1) {
  } else if (transitionError.errorCode) {
    throw Error(
      `${transitionError.errorCode} - ${transitionError.transitionError}`
    );
  }
}
export async function refund(
  dataService: DataService,
  order: OrderDetailFragment
): Promise<void> {
  let lines = order.lines.map((line) => ({
    quantity: line.quantity,
    orderLineId: String(line.id),
  }));
  if (order.state === 'AddingItems') {
    lines = [];
  }
  const response = await dataService.order
    .refundOrder({
      lines,
      reason: 'Manual refund',
      paymentId: order.payments![0].id,
      adjustment: 0,
      shipping: order.shippingWithTax,
    })
    .toPromise();
  const errorResult = response?.refundOrder as RefundOrderStateError;
  if (errorResult.errorCode) {
    throw Error(`${errorResult.errorCode} - ${errorResult.orderState}`);
  }
}
export async function cancel(
  dataService: DataService,
  order: OrderDetailFragment
): Promise<void> {
  const cancelOrderResponse = await dataService.order
    .cancelOrder({
      lines: order.lines.map((line) => ({
        quantity: line.quantity,
        orderLineId: String(line.id),
      })),
      reason: 'Manual cancel',
      orderId: order.id,
      cancelShipping: true,
    })
    .toPromise();
  const errorResult = cancelOrderResponse?.cancelOrder as ErrorResult;
  if (errorResult.errorCode) {
    throw Error(`${errorResult.errorCode} - ${errorResult.message}`);
  }
}
export function mapEntityToButtonState(context: ActionBarContext) {
  return context.entity$.pipe(
    map((entity) => ({
      disabled: entity?.state === 'ArrangingPayment',
      visible: true,
    }))
  );
}
```

## File: packages/vendure-plugin-admin-ui-helpers/src/index.ts

```typescript
import path from 'path';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
export const completeOrderButton: AdminUiExtension = {
  extensionPath: path.join(__dirname, 'ui'),
  ngModules: [
    {
      type: 'shared',
      ngModuleFileName: 'complete-order-button.module.ts',
      ngModuleName: 'CompleteOrderButtonModule',
    },
  ],
};
export const cancelOrderButton: AdminUiExtension = {
  extensionPath: path.join(__dirname, 'ui'),
  ngModules: [
    {
      type: 'shared',
      ngModuleFileName: 'cancel-order-button.module.ts',
      ngModuleName: 'CancelOrderButtonModule',
    },
  ],
};
```

## File: packages/vendure-plugin-admin-ui-helpers/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler/';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import path from 'path';
import { cancelOrderButton, completeOrderButton } from '../src';
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [completeOrderButton, cancelOrderButton],
          devMode: true,
        }),
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
})();
```

## File: packages/vendure-plugin-anonymized-order/src/anonymized-order.resolver.ts

```typescript
import { Args, Query, Resolver, Info } from '@nestjs/graphql';
import { Ctx, Order, RequestContext } from '@vendure/core';
import { AnonymizeOrderService } from './anonymized-order.service';
@Resolver()
export class AnonymizeOrderShopResolver {
  constructor(private readonly anonymizeOrderService: AnonymizeOrderService) {}
  @Query()
  async anonymizedOrder(
    @Ctx() ctx: RequestContext,
    @Args() args: { orderCode: string; emailAddress: string },
    @Info() info: any
  ): Promise<Order> {
    return await this.anonymizeOrderService.getAnonymizedOrder(
      ctx,
      args.orderCode,
      args.emailAddress
    );
  }
}
```

## File: packages/vendure-plugin-anonymized-order/src/anonymized-order.service.ts

```typescript
import { Injectable, Inject } from '@nestjs/common';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { AnonymizeOrderPluginOptions } from './types';
import {
  ForbiddenError,
  Order,
  OrderService,
  RequestContext,
} from '@vendure/core';
@Injectable()
export class AnonymizeOrderService {
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS)
    private readonly options: AnonymizeOrderPluginOptions,
    private readonly orderService: OrderService
  ) {}
  async getAnonymizedOrder(
    ctx: RequestContext,
    orderCode: string,
    emailAddress: string
  ): Promise<Order> {
    let order = await this.orderService.findOneByCode(ctx, orderCode);
    if (order && order.customer?.emailAddress === emailAddress) {
      if (this.options?.anonymizeOrderFn) {
        this.options.anonymizeOrderFn(order);
      } else {
        order.customer = undefined;
        order.customerId = undefined;
        order.shippingAddress = {};
        order.billingAddress = {};
      }
      return order;
    }
    throw new ForbiddenError();
  }
}
```

## File: packages/vendure-plugin-anonymized-order/src/api-extensions.ts

```typescript
import { gql } from 'graphql-tag';
const scalars = gql`
  scalar Order
`;
export const anonymizeOrderShopSchema = gql`
  extend type Query {
    anonymizedOrder(orderCode: String!, emailAddress: String!): Order!
  }
`;
```

## File: packages/vendure-plugin-anonymized-order/src/constants.ts

```typescript
export const loggerCtx = 'AnonymizedOrderPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-anonymized-order/src/index.ts

```typescript
export * from './plugin';
export * from './types';
export * from './anonymized-order.service';
export * from './anonymized-order.resolver';
```

## File: packages/vendure-plugin-anonymized-order/src/plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { AnonymizeOrderPluginOptions } from './types';
import { AnonymizeOrderService } from './anonymized-order.service';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { AnonymizeOrderShopResolver } from './anonymized-order.resolver';
import { anonymizeOrderShopSchema } from './api-extensions';
@VendurePlugin({
  providers: [
    AnonymizeOrderService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => AnonymizedOrderPlugin.options,
    },
  ],
  shopApiExtensions: {
    resolvers: [AnonymizeOrderShopResolver],
    schema: anonymizeOrderShopSchema,
  },
  imports: [PluginCommonModule],
  compatibility: '>=2.2.0',
})
export class AnonymizedOrderPlugin {
  static options: AnonymizeOrderPluginOptions | undefined;
  static init(
    options: AnonymizeOrderPluginOptions
  ): typeof AnonymizedOrderPlugin {
    this.options = options;
    return AnonymizedOrderPlugin;
  }
}
```

## File: packages/vendure-plugin-anonymized-order/src/types.ts

```typescript
import { Order } from '@vendure/core';
export type AnonymizeOrderFn = (order: Order) => void;
export interface AnonymizeOrderPluginOptions {
  anonymizeOrderFn?: AnonymizeOrderFn;
}
```

## File: packages/vendure-plugin-anonymized-order/test/anonymized-order.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { describe, beforeAll, it, expect } from 'vitest';
import { AnonymizedOrderPlugin } from '../src/plugin';
import { createSettledOrder } from '../../test/src/shop-utils';
import { ANONYMIZED_ORDER_QUERY, GET_ACTIVE_ORDER } from './helpers';
describe('Customer managed groups', function () {
  let server: TestServer;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [AnonymizedOrderPlugin.init({})],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 5,
    });
    serverStarted = true;
  }, 60000);
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  describe('Anonymize Order Plugin', async () => {
    it('Should anonymize Order', async () => {
      const setteledOrder = (await createSettledOrder(shopClient, 1)) as any;
      expect(setteledOrder?.code).toBeDefined();
      expect(setteledOrder?.customer?.firstName).toBeDefined();
      expect(setteledOrder?.billingAddress?.fullName).toBeDefined();
      expect(setteledOrder?.shippingAddress?.fullName).toBeDefined();
      const { anonymizedOrder } = await shopClient.query(
        ANONYMIZED_ORDER_QUERY,
        {
          orderCode: setteledOrder.code,
          emailAddress: setteledOrder.customer?.emailAddress,
        }
      );
      expect(anonymizedOrder?.customer).toBeNull();
      expect(anonymizedOrder?.billingAddress?.fullName).toBeNull();
      expect(anonymizedOrder?.shippingAddress?.fullName).toBeNull();
      expect(anonymizedOrder?.couponCodes?.length).toBe(0);
    });
  });
});
```

## File: packages/vendure-plugin-anonymized-order/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { AssetServerPlugin } from '@vendure/asset-server-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import path from 'path';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { AnonymizedOrderPlugin } from '../src/plugin';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AssetServerPlugin.init({
        assetUploadDir: path.join(__dirname, '__data__/assets'),
        route: 'assets',
      }),
      AnonymizedOrderPlugin,
      AdminUiPlugin.init({
        route: 'admin',
        port: 3002,
      }),
      DefaultSearchPlugin,
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    authOptions: {
      tokenMethod: 'bearer',
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 5,
  });
})();
```

## File: packages/vendure-plugin-anonymized-order/test/helpers.ts

```typescript
import { gql } from 'graphql-tag';
export const OrderFieldsFragment = gql`
  fragment OrderFields on Order {
    id
    orderPlacedAt
    code
    state
    active
    total
    totalWithTax
    shippingWithTax
    couponCodes
    shippingAddress {
      fullName
      company
      streetLine1
      streetLine2
      city
      postalCode
      country
    }
    billingAddress {
      fullName
      company
      streetLine1
      streetLine2
      city
      postalCode
      country
    }
    customer {
      id
      firstName
      lastName
      emailAddress
    }
    lines {
      id
      quantity
      productVariant {
        id
      }
      order {
        customer {
          id
        }
      }
      discounts {
        adjustmentSource
        amount
        amountWithTax
        description
        type
      }
    }
  }
`;
export const GET_ACTIVE_ORDER = gql`
  ${OrderFieldsFragment}
  query GetActiveOrder {
    activeOrder {
      ... on Order {
        ...OrderFields
      }
    }
  }
`;
export const ANONYMIZED_ORDER_QUERY = gql`
  ${OrderFieldsFragment}
  query anonymizedOrderQuery($orderCode: String!, $emailAddress: String!) {
    anonymizedOrder(orderCode: $orderCode, emailAddress: $emailAddress) {
      ...OrderFields
    }
  }
`;
```

## File: packages/vendure-plugin-anonymized-order/vitest.config.ts

```typescript
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    include: ['./test/anonymized-order.spec.ts'],
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-campaign-tracker/src/api/api-extensions.ts

```typescript
import gql from 'graphql-tag';
const _scalars = gql`
  scalar DateTime
  scalar Money
  scalar PaginatedList
  scalar StringOperators
  type Order {
    id: ID
    code: String
    total: Money
  }
  enum SortOrder {
    ASC
    DESC
  }
`;
const commonApiExtensions = gql`
  type Campaign {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    code: String!
    name: String!
    metricsUpdatedAt: DateTime
    revenueLast7days: Money
    revenueLast30days: Money
    revenueLast365days: Money
  }
`;
export const shopApiExtensions = gql`
  ${commonApiExtensions}
  extend type Mutation {
    """
    Add a campaign code to the current order.
    Creates a new active order if none exists.
    """
    addCampaignToOrder(campaignCode: String!): Order
  }
`;
export const adminApiExtensions = gql`
  ${commonApiExtensions}
  type CampaignList {
    items: [Campaign!]!
    totalItems: Int!
  }
  input CampaignInput {
    code: String!
    name: String!
  }
  input CampaignSortParameter {
    createdAt: SortOrder
    updatedAt: SortOrder
    code: SortOrder
    name: SortOrder
    revenueLast7days: SortOrder
    revenueLast30days: SortOrder
    revenueLast365days: SortOrder
  }
  input CampaignFilterParameter {
    code: StringOperators
    name: StringOperators
  }
  input CampaignListOptions {
    skip: Int
    take: Int
    sort: CampaignSortParameter
    filter: CampaignFilterParameter
  }
  extend type Mutation {
    createCampaign(input: CampaignInput!): Campaign!
    updateCampaign(id: ID!, input: CampaignInput!): Campaign!
    deleteCampaign(id: ID!): Boolean!
  }
  extend type Query {
    campaigns(options: CampaignListOptions): CampaignList!
  }
`;
```

## File: packages/vendure-plugin-campaign-tracker/src/api/campaign-tracker-admin.resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { Permission } from '@vendure/common/lib/generated-types';
import { Allow, Ctx, RequestContext, Transaction } from '@vendure/core';
import { CampaignTrackerService } from '../services/campaign-tracker.service';
import {
  Campaign,
  CampaignList,
  MutationCreateCampaignArgs,
  MutationDeleteCampaignArgs,
  MutationUpdateCampaignArgs,
  QueryCampaignsArgs,
} from '../ui/generated/graphql';
@Resolver()
export class CampaignTrackerAdminResolver {
  constructor(private campaignTrackerService: CampaignTrackerService) {}
  @Query()
  @Allow(Permission.SuperAdmin)
  async campaigns(
    @Ctx() ctx: RequestContext,
    @Args() { options }: QueryCampaignsArgs
  ): Promise<CampaignList> {
    return await this.campaignTrackerService.getCampaigns(
      ctx,
      options ?? undefined
    );
  }
  @Mutation()
  @Transaction()
  @Allow(Permission.SuperAdmin)
  async createCampaign(
    @Ctx() ctx: RequestContext,
    @Args() { input }: MutationCreateCampaignArgs
  ): Promise<Campaign> {
    return await this.campaignTrackerService.createCampaign(ctx, input);
  }
  @Mutation()
  @Transaction()
  @Allow(Permission.SuperAdmin)
  async updateCampaign(
    @Ctx() ctx: RequestContext,
    @Args() { id, input }: MutationUpdateCampaignArgs
  ): Promise<Campaign> {
    return await this.campaignTrackerService.updateCampaign(ctx, id, input);
  }
  @Mutation()
  @Transaction()
  @Allow(Permission.SuperAdmin)
  async deleteCampaign(
    @Ctx() ctx: RequestContext,
    @Args() { id }: MutationDeleteCampaignArgs
  ): Promise<boolean> {
    await this.campaignTrackerService.deleteCampaign(ctx, id);
    return true;
  }
}
```

## File: packages/vendure-plugin-campaign-tracker/src/api/campaign-tracker-shop.resolver.ts

```typescript
import { Args, Mutation, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Order,
  OrderService,
  Permission,
  RelationPaths,
  Relations,
  RequestContext,
  Transaction,
} from '@vendure/core';
import { CampaignTrackerService } from '../services/campaign-tracker.service';
import { MutationAddCampaignToOrderArgs } from '../ui/generated/graphql';
@Resolver()
export class CampaignTrackerShopResolver {
  constructor(
    private campaignTrackerService: CampaignTrackerService,
    private orderService: OrderService
  ) {}
  @Mutation()
  @Transaction()
  @Allow(Permission.UpdateOrder, Permission.Owner)
  async addCampaignToOrder(
    @Ctx() ctx: RequestContext,
    @Args() { campaignCode }: MutationAddCampaignToOrderArgs,
    @Relations({ entity: Order, omit: ['aggregateOrder', 'sellerOrders'] })
    relations: RelationPaths<Order>
  ): Promise<Order | undefined> {
    const order = await this.campaignTrackerService.addCampaignToOrder(
      ctx,
      campaignCode
    );
    if (order) {
      return this.orderService.findOne(ctx, order.id, relations);
    }
  }
}
```

## File: packages/vendure-plugin-campaign-tracker/src/entities/campaign.entity.ts

```typescript
import { DeepPartial, ID, VendureEntity } from '@vendure/core';
import { Column, Entity, Unique } from 'typeorm';
@Entity()
@Unique(['channelId', 'code'])
export class Campaign extends VendureEntity {
  constructor(input?: DeepPartial<Campaign>) {
    super(input);
  }
  @Column({ type: Date, nullable: true })
  deletedAt?: Date;
  @Column({ type: 'varchar' })
  channelId!: ID;
  @Column()
  code!: string;
  @Column()
  name!: string;
  @Column({ default: 0, type: 'int' })
  revenueLast7days: number = 0;
  @Column({ default: 0, type: 'int' })
  revenueLast30days: number = 0;
  @Column({ default: 0, type: 'int' })
  revenueLast365days: number = 0;
  @Column({ type: Date, nullable: true })
  metricsUpdatedAt?: Date;
}
```

## File: packages/vendure-plugin-campaign-tracker/src/entities/order-campaign.entity.ts

```typescript
import { DeepPartial, ID, VendureEntity } from '@vendure/core';
import { Column, Entity, ManyToOne } from 'typeorm';
import { Campaign } from './campaign.entity';
@Entity()
export class OrderCampaign extends VendureEntity {
  constructor(input?: DeepPartial<OrderCampaign>) {
    super(input);
  }
  @Column({ type: 'varchar' })
  orderId!: ID;
  @ManyToOne(() => Campaign, { eager: true })
  campaign!: Campaign;
}
```

## File: packages/vendure-plugin-campaign-tracker/src/services/attribution-models.spec.ts

```typescript
import { describe, it, expect } from 'vitest';
import {
  LastInteractionAttribution,
  FirstInteractionAttribution,
  LinearAttribution,
  ConnectedCampaign,
} from './attribution-models';
describe('Attribution Models', () => {
  const mockOrderCampaigns: ConnectedCampaign[] = [
    { id: 1 },
    { id: 2 },
    { id: 3 },
  ] as any;
  it('Attributes 100% to the last interaction with LastInteractionAttribution', () => {
    const result = new LastInteractionAttribution().attributeTo(
      mockOrderCampaigns
    );
    expect(result).toEqual([
      {
        campaignId: 3,
        attributionRate: 1,
      },
    ]);
  });
  it('Attributes 100% to the first interaction with FirstInteractionAttribution', () => {
    const result = new FirstInteractionAttribution().attributeTo(
      mockOrderCampaigns
    );
    expect(result).toEqual([
      {
        campaignId: 1,
        attributionRate: 1,
      },
    ]);
  });
  it('Attributes 33% to each interaction with LinearAttribution', () => {
    const result = new LinearAttribution().attributeTo(mockOrderCampaigns);
    expect(result.length).toBe(3);
    result.forEach((attribution) => {
      expect(attribution.attributionRate).toBe(0.3333333333333333);
    });
  });
});
```

## File: packages/vendure-plugin-campaign-tracker/src/services/attribution-models.ts

```typescript
import { ID } from '@vendure/core';
export interface ConnectedCampaign {
  id: ID;
  name: string;
  code: string;
  createdAt: Date;
  updatedAt: Date;
  connectedAt: Date;
  orderId: ID;
}
export interface AttributionModel {
  attributeTo(orderCampaigns: ConnectedCampaign[]): Attribution[];
}
export interface Attribution {
  campaignId: ID;
  attributionRate: number;
}
export class LastInteractionAttribution implements AttributionModel {
  attributeTo(orderCampaigns: ConnectedCampaign[]): Attribution[] {
    const mostRecentlyAddedCampaign = orderCampaigns[orderCampaigns.length - 1];
    return [
      {
        campaignId: mostRecentlyAddedCampaign.id,
        attributionRate: 1,
      },
    ];
  }
}
export class FirstInteractionAttribution implements AttributionModel {
  attributeTo(orderCampaigns: ConnectedCampaign[]): Attribution[] {
    const firstCampaign = orderCampaigns[0];
    return [
      {
        campaignId: firstCampaign.id,
        attributionRate: 1,
      },
    ];
  }
}
export class LinearAttribution implements AttributionModel {
  attributeTo(orderCampaigns: ConnectedCampaign[]): Attribution[] {
    const totalCampaigns = orderCampaigns.length;
    return orderCampaigns.map((orderCampaign) => ({
      campaignId: orderCampaign.id,
      attributionRate: 1 / totalCampaigns,
    }));
  }
}
```

## File: packages/vendure-plugin-campaign-tracker/src/services/campaign-tracker.service.ts

```typescript
import { Inject, Injectable, OnModuleInit } from '@nestjs/common';
import { LogicalOperator } from '@vendure/common/lib/generated-types';
import {
  ActiveOrderService,
  ID,
  JobQueue,
  JobQueueService,
  ListQueryBuilder,
  Logger,
  Order,
  PaginatedList,
  RequestContext,
  SerializedRequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { IsNull } from 'typeorm';
import { CAMPAIGN_TRACKER_PLUGIN_OPTIONS, loggerCtx } from '../constants';
import { Campaign } from '../entities/campaign.entity';
import { OrderCampaign } from '../entities/order-campaign.entity';
import {
  CampaignTrackerOptions,
  OrderWithCampaigns,
  RawOrderQueryResult,
} from '../types';
import {
  CampaignInput,
  CampaignListOptions,
  SortOrder,
} from '../ui/generated/graphql';
import { calculateRevenuePerCampaign, isOlderThan } from './campaign-util';
import { asError } from 'catch-unknown';
interface JobData {
  ctx: SerializedRequestContext;
}
@Injectable()
export class CampaignTrackerService implements OnModuleInit {
  private readonly refreshMetricsAfter = 1000 * 60 * 60 * 6;
  private jobQueue!: JobQueue<JobData>;
  constructor(
    private connection: TransactionalConnection,
    @Inject(CAMPAIGN_TRACKER_PLUGIN_OPTIONS)
    private options: CampaignTrackerOptions,
    private jobQueueService: JobQueueService,
    private activeOrderService: ActiveOrderService,
    private listQueryBuilder: ListQueryBuilder
  ) {}
  public async onModuleInit(): Promise<void> {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'campaign-tracker',
      process: async (job) => {
        const ctx = RequestContext.deserialize(job.data.ctx);
        return await this.calculateRevenue(ctx).catch((err) => {
          Logger.error(
            `Error calculating revenue: ${asError(err).message}`,
            loggerCtx
          );
        });
      },
    });
  }
  async createCampaign(
    ctx: RequestContext,
    input: CampaignInput
  ): Promise<Campaign> {
    return await this.connection.getRepository(ctx, Campaign).save({
      ...input,
      channelId: ctx.channelId,
    });
  }
  async deleteCampaign(ctx: RequestContext, id: ID): Promise<void> {
    await this.getCampaign(ctx, id);
    await this.connection
      .getRepository(ctx, Campaign)
      .update(id, { deletedAt: new Date() });
  }
  async getCampaign(ctx: RequestContext, id: ID): Promise<Campaign> {
    return await this.connection.getRepository(ctx, Campaign).findOneOrFail({
      where: {
        id,
        channelId: ctx.channelId,
        deletedAt: IsNull(),
      },
    });
  }
  async getCampaignByCode(
    ctx: RequestContext,
    code: string
  ): Promise<Campaign | undefined | null> {
    return await this.connection.getRepository(ctx, Campaign).findOne({
      where: {
        code,
        channelId: ctx.channelId,
        deletedAt: IsNull(),
      },
    });
  }
  async updateCampaign(
    ctx: RequestContext,
    id: ID,
    input: CampaignInput
  ): Promise<Campaign> {
    await this.connection.getRepository(ctx, Campaign).update(id, input);
    return this.getCampaign(ctx, id);
  }
  async getCampaigns(
    ctx: RequestContext,
    options: CampaignListOptions = {}
  ): Promise<PaginatedList<Campaign>> {
    if (!options.sort) {
      options.sort = { createdAt: SortOrder.Desc };
    }
    const [campaigns, count] = await this.listQueryBuilder
      .build(
        Campaign,
        {
          ...options,
          filterOperator: LogicalOperator.OR,
        },
        {
          ctx,
          relations: [],
          where: {
            deletedAt: IsNull(),
            channelId: ctx.channelId,
          },
        }
      )
      .getManyAndCount();
    const outDatedCampaign = campaigns.find((campaign) =>
      isOlderThan(campaign.metricsUpdatedAt, this.refreshMetricsAfter)
    );
    if (outDatedCampaign) {
      this.triggerCalculateCampaignMetrics(ctx).catch((err) => {
        Logger.error(
          `Error creating recalculate-metrics job: ${err}`,
          loggerCtx
        );
      });
    }
    return {
      items: campaigns,
      totalItems: count,
    };
  }
  async addCampaignToOrder(
    ctx: RequestContext,
    campaignCode: string
  ): Promise<Order | undefined> {
    const campaign = await this.getCampaignByCode(ctx, campaignCode);
    if (!campaign) {
      Logger.warn(`No campaign found with code ${campaignCode}`, loggerCtx);
      return;
    }
    const order = await this.activeOrderService.getActiveOrder(
      ctx,
      undefined,
      true
    );
    const orderCampaignRepo = this.connection.getRepository(ctx, OrderCampaign);
    const existingOrderCampaign = await orderCampaignRepo.findOne({
      where: { orderId: order.id, campaign: { id: campaign.id } },
    });
    if (existingOrderCampaign) {
      await orderCampaignRepo.save({
        id: existingOrderCampaign.id,
        updatedAt: new Date(),
      });
    } else {
      await orderCampaignRepo.save({ orderId: order.id, campaign });
      Logger.info(
        `Added campaign ${campaignCode} to order ${order.code}`,
        loggerCtx
      );
    }
    return order;
  }
  async calculateRevenue(ctx: RequestContext): Promise<void> {
    const placedOrders = await this.getOrdersWithCampaigns(
      ctx,
      'orderPlacedAt',
      365
    );
    const revenuePerCampaign = calculateRevenuePerCampaign(
      this.options.attributionModel,
      placedOrders
    );
    for (const [campaignId, campaign] of revenuePerCampaign.entries()) {
      await this.connection.getRepository(ctx, Campaign).update(campaignId, {
        revenueLast365days: Math.round(campaign.revenueLast365days),
        revenueLast30days: Math.round(campaign.revenueLast30days),
        revenueLast7days: Math.round(campaign.revenueLast7days),
      });
      Logger.info(`Updated revenue for campaign ${campaignId}`, loggerCtx);
    }
    await this.connection.getRepository(ctx, Campaign).update(
      {
        channelId: ctx.channelId,
      },
      { metricsUpdatedAt: new Date() }
    );
  }
  async triggerCalculateCampaignMetrics(ctx: RequestContext): Promise<void> {
    await this.jobQueue.add({
      ctx: ctx.serialize(),
    });
    Logger.info(
      `Added job to calculate campaign metrics for channel ${ctx.channel.token}`,
      loggerCtx
    );
  }
  async getOrdersWithCampaigns(
    ctx: RequestContext,
    dateFilter: 'orderPlacedAt' | 'updatedAt',
    lastXDays: number
  ): Promise<OrderWithCampaigns[]> {
    const lastXDaysDate = new Date();
    lastXDaysDate.setDate(lastXDaysDate.getDate() - lastXDays);
    const allOrders: RawOrderQueryResult[] = [];
    let hasMore = true;
    while (hasMore) {
      const query = this.connection
        .getRepository(ctx, Order)
        .createQueryBuilder('order')
        .leftJoin('order.channels', 'channel')
        .innerJoinAndSelect(
          OrderCampaign,
          'orderCampaign',
          'order.id = orderCampaign.orderId'
        )
        .leftJoinAndSelect('orderCampaign.campaign', 'campaign')
        .where('channel.id = :channelId', { channelId: ctx.channelId })
        .andWhere(`order.${dateFilter} > :lastXDaysDate`, { lastXDaysDate })
        .andWhere(`campaign.deletedAt IS NULL`)
        .limit(5000)
        .offset(allOrders.length);
      const orders: RawOrderQueryResult[] = await query.getRawMany();
      const total = await query.getCount();
      allOrders.push(...orders);
      if (allOrders.length >= total) {
        hasMore = false;
      }
    }
    return this.mapToOrderWithCampaigns(allOrders);
  }
  private mapToOrderWithCampaigns(
    rawOrderResults: RawOrderQueryResult[]
  ): OrderWithCampaigns[] {
    const campaignsPerOrder = new Map<ID, OrderWithCampaigns>();
    rawOrderResults.forEach((o) => {
      const campaign = new Campaign({
        id: o.campaign_id,
        code: o.campaign_code,
        name: o.campaign_name,
        channelId: o.campaign_channelId,
        revenueLast7days: o.campaign_revenueLast7days,
        revenueLast30days: o.campaign_revenueLast30days,
        revenueLast365days: o.campaign_revenueLast365days,
        metricsUpdatedAt: o.campaign_metricsUpdatedAt,
      });
      const orderCampaign = new OrderCampaign({
        id: o.orderCampaign_id,
        createdAt: new Date(o.orderCampaign_createdAt),
        updatedAt: new Date(o.orderCampaign_updatedAt),
        orderId: o.order_id,
        campaign: campaign,
      });
      const existingCampaigns =
        campaignsPerOrder.get(o.order_id)?.connectedCampaigns || [];
      campaignsPerOrder.set(o.order_id, {
        orderId: o.order_id,
        orderTotal: o.order_subTotal + o.order_shipping,
        orderPlacedAt: o.order_orderPlacedAt
          ? new Date(o.order_orderPlacedAt)
          : undefined,
        orderUpdatedAt: new Date(o.order_updatedAt),
        connectedCampaigns: [...existingCampaigns, orderCampaign],
      });
    });
    return Array.from(campaignsPerOrder.values()).map((o) => {
      o.connectedCampaigns.sort(
        (a, b) => a.updatedAt.getTime() - b.updatedAt.getTime()
      );
      return o;
    });
  }
}
```

## File: packages/vendure-plugin-campaign-tracker/src/services/campaign-util.spec.ts

```typescript
import { describe, expect, it, vi, afterEach } from 'vitest';
import { OrderWithCampaigns } from '../types';
import { asError } from 'catch-unknown';
import {
  calculateRevenuePerCampaign,
  isOlderThan,
  validateAttributions,
} from './campaign-util';
const attributionModel = {
  attributeTo: vi.fn(),
};
afterEach(() => {
  attributionModel.attributeTo.mockClear();
});
function createMockOrder(
  total = 100,
  campaigns = [{ campaign: { id: 1 } }],
  wasPlacedDaysAgo = 0
): OrderWithCampaigns {
  const orderPlacedAt = new Date();
  orderPlacedAt.setDate(orderPlacedAt.getDate() - wasPlacedDaysAgo);
  return {
    orderId: '1',
    orderTotal: total,
    connectedCampaigns: campaigns,
    orderPlacedAt,
    orderUpdatedAt: orderPlacedAt,
  } as any;
}
describe('calculateRevenuePerCampaign', () => {
  it.each([
    {
      description: 'Has revenue attributed to the 1 campaign',
      orderTotal: 100,
      orderPlacedDaysAgo: 0,
      orderCampaigns: [{ campaign: { id: 5 } }],
      attributionRates: [{ campaignId: 5, attributionRate: 1 }],
      expectedRevenue365Days: 100,
      expectedRevenue30Days: 100,
      expectedRevenue7Days: 100,
    },
    {
      description: 'Has revenue attributed only to 365 days revenue',
      orderTotal: 100,
      orderPlacedDaysAgo: 31,
      orderCampaigns: [{ campaign: { id: 5 } }],
      attributionRates: [{ campaignId: 5, attributionRate: 1 }],
      expectedRevenue365Days: 100,
      expectedRevenue30Days: 0,
      expectedRevenue7Days: 0,
    },
    {
      description: 'Has revenue split over 2 campaigns',
      orderTotal: 100,
      orderPlacedDaysAgo: 0,
      orderCampaigns: [{ campaign: { id: 5 } }, { campaign: { id: 2 } }],
      attributionRates: [
        { campaignId: 5, attributionRate: 0.6 },
        { campaignId: 2, attributionRate: 0.4 },
      ],
      expectedRevenue365Days: 60,
      expectedRevenue30Days: 60,
      expectedRevenue7Days: 60,
    },
  ])(
    '$description',
    ({
      orderTotal,
      orderCampaigns,
      orderPlacedDaysAgo,
      attributionRates,
      expectedRevenue365Days,
      expectedRevenue30Days,
      expectedRevenue7Days,
    }) => {
      attributionModel.attributeTo.mockReturnValue(attributionRates);
      const mockOrder1 = createMockOrder(
        orderTotal / 2,
        orderCampaigns,
        orderPlacedDaysAgo
      );
      const mockOrder2 = createMockOrder(
        orderTotal / 2,
        orderCampaigns,
        orderPlacedDaysAgo
      );
      const result = calculateRevenuePerCampaign(attributionModel as any, [
        mockOrder1,
        mockOrder2,
      ]);
      expect(result.get(5)?.revenueLast365days).toBe(expectedRevenue365Days);
      expect(result.get(5)?.revenueLast30days).toBe(expectedRevenue30Days);
      expect(result.get(5)?.revenueLast7days).toBe(expectedRevenue7Days);
    }
  );
  it('Throws an error if the sum of all attributions is not 1', () => {
    expect.assertions(1);
    try {
      const attributions = [
        { campaignId: 1, attributionRate: 0.6 },
        { campaignId: 2, attributionRate: 0.6 },
      ];
      attributionModel.attributeTo.mockReturnValue(attributions);
      calculateRevenuePerCampaign(attributionModel as any, [createMockOrder()]);
    } catch (e) {
      expect(asError(e).message).toBe(
        "The sum of all attributions for an order should be 1, got '1.2'"
      );
    }
  });
});
describe('validateAttributions', () => {
  it('Passes when attributions sum to exactly 1', () => {
    const attributions = [
      { attributionRate: 0.4 },
      { attributionRate: 0.3 },
      { attributionRate: 0.3 },
    ];
    expect(() => validateAttributions(attributions)).not.toThrow();
  });
  it('Throws an error when attributions do not sum to 1', () => {
    const attributions = [{ attributionRate: 0.5 }, { attributionRate: 0.3 }];
    expect(() => validateAttributions(attributions)).toThrow(
      "The sum of all attributions for an order should be 1, got '0.8'"
    );
  });
  it('Allows asumming up to 0.999', () => {
    const attributions = [
      { attributionRate: 0.666 },
      { attributionRate: 0.333 },
    ];
    expect(() => validateAttributions(attributions)).not.toThrow();
  });
});
describe('isOlderThan', () => {
  it('Says now is not older than 1000ms', () => {
    expect(isOlderThan(new Date(), 1000)).toBe(false);
  });
  it('Says 2023 is older than 1000ms', () => {
    expect(isOlderThan(new Date('2023-01-01'), 1000)).toBe(true);
  });
});
```

## File: packages/vendure-plugin-campaign-tracker/src/services/campaign-util.ts

```typescript
import { ID } from '@vendure/core';
import { Campaign } from '../entities/campaign.entity';
import { OrderWithCampaigns } from '../types';
import {
  Attribution,
  AttributionModel,
  ConnectedCampaign,
} from './attribution-models';
function isDateInLastXDays(date: Date | undefined, nrOfDays: number): boolean {
  if (!date) {
    return false;
  }
  const xDaysAgo = new Date();
  xDaysAgo.setDate(xDaysAgo.getDate() - nrOfDays);
  return date > xDaysAgo;
}
export function validateAttributions(
  attributions: Pick<Attribution, 'attributionRate'>[]
) {
  const sum = attributions.reduce(
    (total, attribution) => total + attribution.attributionRate,
    0
  );
  if (sum >= 0.999 && sum <= 1.001) {
    return true;
  }
  throw new Error(
    `The sum of all attributions for an order should be 1, got '${sum}'`
  );
}
export function calculateRevenuePerCampaign(
  attributionModel: AttributionModel,
  placedOrders: OrderWithCampaigns[]
): Map<ID, Campaign> {
  const revenuePerCampaign = new Map<ID, Campaign>();
  for (const order of placedOrders) {
    const connectedCampaigns: ConnectedCampaign[] =
      order.connectedCampaigns.map((c) => ({
        id: c.campaign.id,
        name: c.campaign.name,
        code: c.campaign.code,
        createdAt: c.campaign.createdAt,
        updatedAt: c.campaign.updatedAt,
        connectedAt: c.updatedAt,
        orderId: c.orderId,
      }));
    const attributions = attributionModel.attributeTo(connectedCampaigns);
    validateAttributions(attributions);
    attributions.forEach((attribution) => {
      const campaign =
        revenuePerCampaign.get(attribution.campaignId) || new Campaign();
      const revenue = order.orderTotal * attribution.attributionRate;
      if (isDateInLastXDays(order.orderPlacedAt, 365)) {
        campaign.revenueLast365days += revenue;
      }
      if (isDateInLastXDays(order.orderPlacedAt, 30)) {
        campaign.revenueLast30days += revenue;
      }
      if (isDateInLastXDays(order.orderPlacedAt, 7)) {
        campaign.revenueLast7days += revenue;
      }
      revenuePerCampaign.set(attribution.campaignId, campaign);
    });
  }
  return revenuePerCampaign;
}
export function isOlderThan(
  givenDate: Date | undefined,
  milliseconds: number
): boolean {
  if (!givenDate) {
    return true;
  }
  const now = new Date();
  return now.getTime() - givenDate.getTime() > milliseconds;
}
```

## File: packages/vendure-plugin-campaign-tracker/src/ui/components/campaign-list.component.ts

```typescript
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  OnInit,
} from '@angular/core';
import { TypedDocumentNode } from '@apollo/client';
import {
  DeleteAdministratorsMutationVariables,
  LogicalOperator,
  NotificationService,
  SharedModule,
  TypedBaseListComponent,
} from '@vendure/admin-ui/core';
import {
  Campaign,
  CampaignList,
  CreateCampaignMutation,
  CreateCampaignMutationVariables,
  DeleteCampaignMutation,
  DeleteCampaignMutationVariables,
  Scalars,
  UpdateCampaignMutation,
  UpdateCampaignMutationVariables,
} from '../generated/graphql';
import {
  CREATE_CAMPAIGN,
  DELETE_CAMPAIGN,
  GET_CAMPAIGNS,
  UPDATE_CAMPAIGN,
} from '../queries';
const GetCampaignsTypedDocument: TypedDocumentNode<{
  campaigns: CampaignList;
}> = GET_CAMPAIGNS;
@Component({
  selector: 'campaign-list',
  templateUrl: './campaign-list.component.html',
  styles: [
    `
      .modal-footer.campaign {
        display: block;
      }
    `,
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [SharedModule],
})
export class CampaignListComponent extends TypedBaseListComponent<
  typeof GetCampaignsTypedDocument,
  'campaigns'
> {
  currencyCode: any;
  showModal = false;
  modalAction: 'Edit' | 'Create' = 'Create';
  currentCampaign = {
    id: '' as Scalars['ID'],
    name: '',
    code: '',
  };
  // Here we set up the sorting options that will be available
  // to use in the data table
  readonly sorts = this.createSortCollection()
    .defaultSort('createdAt', 'DESC')
    .addSort({ name: 'createdAt' })
    .addSort({ name: 'updatedAt' })
    .addSort({ name: 'code' })
    .addSort({ name: 'name' })
    .addSort({ name: 'revenueLast7days' })
    .addSort({ name: 'revenueLast30days' })
    .addSort({ name: 'revenueLast365days' })
    .connectToRoute(this.route);
  constructor(
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService
  ) {
    super();
    super.configure({
      document: GetCampaignsTypedDocument,
      getItems: (data) => data.campaigns,
      setVariables: (skip, take) => ({
        options: {
          skip,
          take,
          filter: {
            name: {
              contains: this.searchTermControl.value,
            },
            code: {
              contains: this.searchTermControl.value,
            },
          },
          sort: this.sorts.createSortInput(),
        },
      }),
      refreshListOnChanges: [this.sorts.valueChanges],
    });
    this.dataService.settings.getActiveChannel().single$.subscribe((data) => {
      this.currencyCode = data.activeChannel.defaultCurrencyCode;
    });
  }
  createOrUpdate() {
    if (this.currentCampaign.id) {
      this.dataService
        .mutate<UpdateCampaignMutation, UpdateCampaignMutationVariables>(
          UPDATE_CAMPAIGN,
          {
            id: this.currentCampaign.id,
            input: {
              code: this.currentCampaign.code,
              name: this.currentCampaign.name,
            },
          }
        )
        .subscribe((s: any) => {
          this.showModal = false;
          this.clearCurrentCampaign();
          this.notificationService.success('Saved');
          this.changeDetector.detectChanges();
        });
    } else {
      this.dataService
        .mutate<CreateCampaignMutation, CreateCampaignMutationVariables>(
          CREATE_CAMPAIGN,
          {
            input: {
              code: this.currentCampaign.code,
              name: this.currentCampaign.name,
            },
          }
        )
        .subscribe((s: any) => {
          this.showModal = false;
          this.clearCurrentCampaign();
          this.notificationService.success('Created');
          this.changeDetector.detectChanges();
          super.refresh();
        });
    }
  }
  create() {
    this.modalAction = 'Create';
    this.currentCampaign.id = '';
    this.currentCampaign.name = '';
    this.currentCampaign.code = '';
    this.showModal = true;
  }
  edit(campaign: Campaign) {
    this.modalAction = 'Edit';
    this.currentCampaign.id = campaign.id;
    this.currentCampaign.name = campaign.name;
    this.currentCampaign.code = campaign.code;
    this.showModal = true;
  }
  delete() {
    this.dataService
      .mutate<DeleteCampaignMutation, DeleteCampaignMutationVariables>(
        DELETE_CAMPAIGN,
        {
          id: this.currentCampaign.id,
        }
      )
      .subscribe((s: any) => {
        this.showModal = false;
        this.clearCurrentCampaign();
        this.notificationService.success('Deleted');
        this.changeDetector.detectChanges();
        super.refresh();
      });
  }
  clearCurrentCampaign() {
    this.currentCampaign.id = '';
    this.currentCampaign.code = '';
    this.currentCampaign.name = '';
  }
}
```

## File: packages/vendure-plugin-campaign-tracker/src/ui/providers.ts

```typescript
import { addNavMenuItem } from '@vendure/admin-ui/core';
export default [
  addNavMenuItem(
    {
      id: 'campaigns',
      label: 'Campaigns',
      routerLink: ['/extensions/campaigns'],
      icon: 'target',
    },
    'marketing'
  ),
];
```

## File: packages/vendure-plugin-campaign-tracker/src/ui/queries.ts

```typescript
import gql from 'graphql-tag';
export const CAMPAIGN_FRAGMENT = gql`
  fragment Campaign on Campaign {
    id
    createdAt
    updatedAt
    code
    name
    metricsUpdatedAt
    revenueLast7days
    revenueLast30days
    revenueLast365days
  }
`;
export const CREATE_CAMPAIGN = gql`
  mutation CreateCampaign($input: CampaignInput!) {
    createCampaign(input: $input) {
      ...Campaign
    }
  }
  ${CAMPAIGN_FRAGMENT}
`;
export const UPDATE_CAMPAIGN = gql`
  mutation UpdateCampaign($id: ID!, $input: CampaignInput!) {
    updateCampaign(id: $id, input: $input) {
      ...Campaign
    }
  }
  ${CAMPAIGN_FRAGMENT}
`;
export const DELETE_CAMPAIGN = gql`
  mutation DeleteCampaign($id: ID!) {
    deleteCampaign(id: $id)
  }
`;
export const GET_CAMPAIGNS = gql`
  query GetCampaigns($options: CampaignListOptions) {
    campaigns(options: $options) {
      items {
        ...Campaign
      }
      totalItems
    }
  }
  ${CAMPAIGN_FRAGMENT}
`;
```

## File: packages/vendure-plugin-campaign-tracker/src/ui/routes.ts

```typescript
import { registerRouteComponent } from '@vendure/admin-ui/core';
import { CampaignListComponent } from './components/campaign-list.component';
export default [
  registerRouteComponent({
    path: '',
    component: CampaignListComponent,
    breadcrumb: 'Campaigns',
  }),
];
```

## File: packages/vendure-plugin-campaign-tracker/src/campaign-tracker.plugin.ts

```typescript
import { PluginCommonModule, Type, VendurePlugin } from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { adminApiExtensions, shopApiExtensions } from './api/api-extensions';
import { CampaignTrackerAdminResolver } from './api/campaign-tracker-admin.resolver';
import { CampaignTrackerShopResolver } from './api/campaign-tracker-shop.resolver';
import { CAMPAIGN_TRACKER_PLUGIN_OPTIONS } from './constants';
import { Campaign } from './entities/campaign.entity';
import { OrderCampaign } from './entities/order-campaign.entity';
import { LastInteractionAttribution } from './services/attribution-models';
import { CampaignTrackerService } from './services/campaign-tracker.service';
import { CampaignTrackerOptions } from './types';
import path from 'path';
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    {
      provide: CAMPAIGN_TRACKER_PLUGIN_OPTIONS,
      useFactory: () => CampaignTrackerPlugin.options,
    },
    CampaignTrackerService,
  ],
  configuration: (config) => {
    return config;
  },
  compatibility: '>=2.2.0',
  adminApiExtensions: {
    schema: adminApiExtensions,
    resolvers: [CampaignTrackerAdminResolver],
  },
  shopApiExtensions: {
    schema: shopApiExtensions,
    resolvers: [CampaignTrackerShopResolver],
  },
  entities: [Campaign, OrderCampaign],
})
export class CampaignTrackerPlugin {
  static options: CampaignTrackerOptions = {
    attributionModel: new LastInteractionAttribution(),
  };
  static init(
    options: Partial<CampaignTrackerOptions>
  ): Type<CampaignTrackerPlugin> {
    this.options = {
      ...this.options,
      ...options,
    };
    return CampaignTrackerPlugin;
  }
  static ui: AdminUiExtension = {
    id: 'campaign-tracker',
    extensionPath: path.join(__dirname, 'ui'),
    routes: [{ route: 'campaigns', filePath: 'routes.ts' }],
    providers: ['providers.ts'],
  };
}
```

## File: packages/vendure-plugin-campaign-tracker/src/constants.ts

```typescript
export const CAMPAIGN_TRACKER_PLUGIN_OPTIONS = Symbol(
  'CAMPAIGN_TRACKER_PLUGIN_OPTIONS'
);
export const loggerCtx = 'CampaignTrackerPlugin';
```

## File: packages/vendure-plugin-campaign-tracker/src/index.ts

```typescript
export * from './campaign-tracker.plugin';
export * from './services/campaign-tracker.service';
export * from './services/campaign-util';
export * from './services/attribution-models';
export * from './types';
```

## File: packages/vendure-plugin-campaign-tracker/src/types.ts

```typescript
import { ID } from '@vendure/core';
import { OrderCampaign } from './entities/order-campaign.entity';
import { AttributionModel } from './services/attribution-models';
export interface CampaignTrackerOptions {
  attributionModel: AttributionModel;
}
export interface OrderWithCampaigns {
  orderId: ID;
  orderTotal: number;
  orderPlacedAt?: Date;
  orderUpdatedAt: Date;
  connectedCampaigns: OrderCampaign[];
}
export interface RawOrderQueryResult {
  order_createdAt: string;
  order_updatedAt: string;
  order_code: string;
  order_state: string;
  order_orderPlacedAt: string;
  order_currencyCode: string;
  order_id: ID;
  order_customerId: number;
  order_subTotal: number;
  order_subTotalWithTax: number;
  order_shipping: number;
  order_shippingWithTax: number;
  orderCampaign_createdAt: string;
  orderCampaign_updatedAt: string;
  orderCampaign_id: ID;
  orderCampaign_orderId: number;
  orderCampaign_campaignId: number;
  campaign_createdAt: string;
  campaign_updatedAt: string;
  campaign_deletedAt?: string;
  campaign_channelId: string;
  campaign_code: string;
  campaign_name: string;
  campaign_revenueLast7days: number;
  campaign_revenueLast30days: number;
  campaign_revenueLast365days: number;
  campaign_metricsUpdatedAt?: string;
  campaign_id: ID;
}
```

## File: packages/vendure-plugin-campaign-tracker/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  configureDefaultOrderProcess,
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  OrderProcess,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { CampaignTrackerPlugin, LastInteractionAttribution } from '../src';
import {
  CreateCampaignMutation,
  CreateCampaignMutationVariables,
  GetCampaignsQuery,
  GetCampaignsQueryVariables,
  MutationAddCampaignToOrderArgs,
  SortOrder,
} from '../src/ui/generated/graphql';
import { CREATE_CAMPAIGN, GET_CAMPAIGNS } from '../src/ui/queries';
import { ADD_CAMPAIGN_TO_ORDER } from './queries';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    orderOptions: {
      process: [
        configureDefaultOrderProcess({
          checkFulfillmentStates: false,
        }) as OrderProcess<any>,
      ],
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    customFields: {
      ProductVariant: [
        {
          name: 'noLongerAvailable',
          type: 'string',
        },
      ],
    },
    plugins: [
      CampaignTrackerPlugin.init({
        attributionModel: new LastInteractionAttribution(),
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [CampaignTrackerPlugin.ui],
          devMode: true,
        }),
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
  const {
    createCampaign: { code },
  } = await adminClient.query<
    CreateCampaignMutation,
    CreateCampaignMutationVariables
  >(CREATE_CAMPAIGN, {
    input: {
      code: 'test_campaign',
      name: 'Test Campaign',
    },
  });
  console.log(`Created campaign ${code}`);
  const {
    createCampaign: { code: code2 },
  } = await adminClient.query<
    CreateCampaignMutation,
    CreateCampaignMutationVariables
  >(CREATE_CAMPAIGN, {
    input: {
      code: 'campaign2',
      name: 'Campaign 2',
    },
  });
  console.log(`Created campaign ${code2}`);
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  const { addCampaignToOrder } = await shopClient.query(ADD_CAMPAIGN_TO_ORDER, {
    campaignCode: 'test_campaign',
  });
  await new Promise((resolve) => setTimeout(resolve, 1200));
  await shopClient.query(ADD_CAMPAIGN_TO_ORDER, { campaignCode: 'campaign2' });
  console.log(`Added campaigns to order ${addCampaignToOrder.code}`);
  const order = await createSettledOrder(shopClient, 1, false);
  console.log(`Settled order ${order.code}`);
  await adminClient.query<GetCampaignsQuery, GetCampaignsQueryVariables>(
    GET_CAMPAIGNS
  );
})();
```

## File: packages/vendure-plugin-campaign-tracker/test/e2e.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig, Order } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { afterAll, beforeAll, expect, it } from 'vitest';
import { CampaignTrackerPlugin, LastInteractionAttribution } from '../src';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import {
  CREATE_CAMPAIGN,
  DELETE_CAMPAIGN,
  GET_CAMPAIGNS,
  UPDATE_CAMPAIGN,
} from '../src/ui/queries';
import {
  CreateCampaignMutation,
  CreateCampaignMutationVariables,
  DeleteCampaignMutation,
  DeleteCampaignMutationVariables,
  GetCampaignsQuery,
  GetCampaignsQueryVariables,
  SortOrder,
  UpdateCampaignMutation,
  UpdateCampaignMutationVariables,
} from '../src/ui/generated/graphql';
import { ADD_CAMPAIGN_TO_ORDER } from './queries';
import { createSettledOrder, SettledOrder } from '../../test/src/shop-utils';
import { waitFor } from '../../test/src/test-helpers';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
let serverStarted = false;
let order1: SettledOrder;
let order2: SettledOrder;
let order3: SettledOrder;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    apiOptions: {
      port: 3106,
    },
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      CampaignTrackerPlugin.init({
        attributionModel: new LastInteractionAttribution(),
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  serverStarted = true;
  await adminClient.asSuperAdmin();
}, 30000);
it('Should start successfully', async () => {
  await expect(serverStarted).toBe(true);
});
it('Creates 2 campaigns', async () => {
  const { createCampaign: campaign1 } = await adminClient.query<
    CreateCampaignMutation,
    CreateCampaignMutationVariables
  >(CREATE_CAMPAIGN, {
    input: {
      code: 'campaign1',
      name: 'Campaign 1',
    },
  });
  const { createCampaign: campaign2 } = await adminClient.query<
    CreateCampaignMutation,
    CreateCampaignMutationVariables
  >(CREATE_CAMPAIGN, {
    input: {
      code: 'campaign2',
      name: 'Campaign 2',
    },
  });
  expect(campaign1.code).toBe('campaign1');
  expect(campaign1.id).toBe('T_1');
  expect(campaign2.code).toBe('campaign2');
  expect(campaign2.id).toBe('T_2');
});
it('Adds a campaign without having an active order', async () => {
  const { addCampaignToOrder: order } = await shopClient.query(
    ADD_CAMPAIGN_TO_ORDER,
    {
      campaignCode: 'campaign1',
    }
  );
  expect(order.code).toBeDefined();
});
it("Doesn't create actie order for non-existant campaign code", async () => {
  const { addCampaignToOrder: order } = await shopClient.query(
    ADD_CAMPAIGN_TO_ORDER,
    {
      campaignCode: 'does-not-exist',
    }
  );
  expect(order).toBeNull();
});
it('Places order with 2 campaigns, where campaign1 was added last', async () => {
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await shopClient.query(ADD_CAMPAIGN_TO_ORDER, {
    campaignCode: 'campaign2',
  });
  await new Promise((resolve) => setTimeout(resolve, 1200));
  const { addCampaignToOrder } = await shopClient.query(ADD_CAMPAIGN_TO_ORDER, {
    campaignCode: 'campaign1',
  });
  order1 = await createSettledOrder(shopClient, 1, false);
  expect(addCampaignToOrder.code).toBe(order1.code);
});
it('Places 2 orders connected to campaign2', async () => {
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await shopClient.query(ADD_CAMPAIGN_TO_ORDER, {
    campaignCode: 'campaign2',
  });
  order2 = await createSettledOrder(shopClient, 1, false);
  expect(order2.code).toBeDefined();
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await shopClient.query(ADD_CAMPAIGN_TO_ORDER, {
    campaignCode: 'campaign2',
  });
  order3 = await createSettledOrder(shopClient, 1, false);
});
it('Calculates revenue', async () => {
  const getCampaigns = async () => {
    const { campaigns } = await adminClient.query<
      GetCampaignsQuery,
      GetCampaignsQueryVariables
    >(GET_CAMPAIGNS);
    return campaigns.items;
  };
  const campaigns = await waitFor(async () => {
    const campaigns = await getCampaigns();
    if (campaigns.every((c) => c.revenueLast7days > 0)) {
      return campaigns;
    }
  }, 4000);
  expect(campaigns.length).toBe(2);
});
it('Has attributed order1 to campaign1', async () => {
  const { campaigns } = await adminClient.query<
    GetCampaignsQuery,
    GetCampaignsQueryVariables
  >(GET_CAMPAIGNS);
  const campaign1 = campaigns.items.find((c) => c.code === 'campaign1');
  expect(campaign1?.revenueLast7days).toBe(order1.total);
  expect(campaign1?.revenueLast30days).toBe(order1.total);
  expect(campaign1?.revenueLast365days).toBe(order1.total);
});
it('Has attributed order2 and order3 to campaign2', async () => {
  const { campaigns } = await adminClient.query<
    GetCampaignsQuery,
    GetCampaignsQueryVariables
  >(GET_CAMPAIGNS);
  const campaign2 = campaigns.items.find((c) => c.code === 'campaign2');
  const totalRevenue = order2.total + order3.total;
  expect(campaign2?.revenueLast7days).toBe(totalRevenue);
  expect(campaign2?.revenueLast30days).toBe(totalRevenue);
  expect(campaign2?.revenueLast365days).toBe(totalRevenue);
});
it('Sorts by revenue ASC', async () => {
  const {
    campaigns: { items: campaigns },
  } = await adminClient.query<GetCampaignsQuery, GetCampaignsQueryVariables>(
    GET_CAMPAIGNS,
    {
      options: { sort: { revenueLast7days: SortOrder.Asc } },
    }
  );
  expect(campaigns[1]?.revenueLast7days).toBeGreaterThan(
    campaigns[0]?.revenueLast7days
  );
});
it('Sorts by revenue DESC', async () => {
  const {
    campaigns: { items: campaigns },
  } = await adminClient.query<GetCampaignsQuery, GetCampaignsQueryVariables>(
    GET_CAMPAIGNS,
    {
      options: { sort: { revenueLast7days: SortOrder.Desc } },
    }
  );
  expect(campaigns[0]?.revenueLast7days).toBeGreaterThan(
    campaigns[1]?.revenueLast7days
  );
});
it('Updates a campaign name', async () => {
  const { updateCampaign } = await adminClient.query<
    UpdateCampaignMutation,
    UpdateCampaignMutationVariables
  >(UPDATE_CAMPAIGN, {
    id: '1',
    input: {
      code: 'campaign1',
      name: 'Updated Campaign 1',
    },
  });
  expect(updateCampaign.id).toBe('T_1');
  expect(updateCampaign.code).toBe('campaign1');
  expect(updateCampaign.name).toBe('Updated Campaign 1');
});
it('Deletes a campaign', async () => {
  const { deleteCampaign } = await adminClient.query<
    DeleteCampaignMutation,
    DeleteCampaignMutationVariables
  >(DELETE_CAMPAIGN, {
    id: '1',
  });
  expect(deleteCampaign).toBe(true);
});
if (process.env.TEST_ADMIN_UI) {
  it('Should compile admin', async () => {
    const files = await getFilesInAdminUiFolder(
      __dirname,
      CampaignTrackerPlugin.ui
    );
    expect(files?.length).toBeGreaterThan(0);
  }, 200000);
}
afterAll(async () => {
  await server.destroy();
});
```

## File: packages/vendure-plugin-campaign-tracker/test/queries.ts

```typescript
import gql from 'graphql-tag';
export const ADD_CAMPAIGN_TO_ORDER = gql`
  mutation addCampaignToOrder($campaignCode: String!) {
    addCampaignToOrder(campaignCode: $campaignCode) {
      id
      code
      total
      taxSummary {
        taxTotal
      }
    }
  }
`;
```

## File: packages/vendure-plugin-coinbase/src/coinbase.client.ts

```typescript
import { AxiosInstance, AxiosResponse } from 'axios';
import { ChargeInput, ChargeResult } from './coinbase.types';
import { Logger } from '@vendure/core';
import { loggerCtx } from './constants';
const axios = require('axios').default;
export class CoinbaseClient {
  private readonly client: AxiosInstance;
  constructor(private config: { apiKey: string; apiVersion?: string }) {
    this.config.apiVersion = this.config.apiVersion || '2018-03-22';
    this.client = axios.create({
      baseURL: 'https://api.commerce.coinbase.com',
    });
    this.client.defaults.headers.common['Content-Type'] = 'application/json';
    this.client.defaults.headers.common['X-CC-Api-Key'] = this.config.apiKey;
    this.client.defaults.headers.common['X-CC-Version'] =
      this.config.apiVersion;
  }
  async createCharge(input: ChargeInput): Promise<ChargeResult> {
    const result = await this.client.post('/charges', input);
    return this.validateResponse(result);
  }
  async getCharge(id: string): Promise<ChargeResult> {
    const result = await this.client.get(`/charges/${id}`);
    return this.validateResponse(result);
  }
  private validateResponse(result: AxiosResponse): any {
    if (result.data.error) {
      Logger.error(
        `Coinbase call failed: ${result.data.error?.message}`,
        loggerCtx
      );
      throw Error(result.data.error?.message);
    }
    return result.data;
  }
}
```

## File: packages/vendure-plugin-coinbase/src/coinbase.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { Resolver, Mutation } from '@nestjs/graphql';
import { CoinbaseService } from './coinbase.service';
import { Ctx, Logger, RequestContext } from '@vendure/core';
import { ChargeConfirmedWebhookEvent } from './coinbase.types';
import { loggerCtx } from './constants';
@Controller('payments')
export class CoinbaseController {
  constructor(private service: CoinbaseService) {}
  @Post('coinbase')
  async webhook(@Body() body: ChargeConfirmedWebhookEvent): Promise<void> {
    try {
      await this.service.settlePayment(body.event);
    } catch (error: any) {
      Logger.error(
        `Failed to process incoming webhook: ${
          error?.message
        }: ${JSON.stringify(body)}`,
        loggerCtx,
        error
      );
      throw error;
    }
  }
}
@Resolver()
export class CoinbaseResolver {
  constructor(private service: CoinbaseService) {}
  @Mutation()
  createCoinbasePaymentIntent(@Ctx() ctx: RequestContext): Promise<string> {
    return this.service.createPaymentIntent(ctx);
  }
}
```

## File: packages/vendure-plugin-coinbase/src/coinbase.handler.ts

```typescript
import { LanguageCode } from '@vendure/common/lib/generated-types';
import {
  CreatePaymentErrorResult,
  CreatePaymentResult,
  CreateRefundResult,
  Logger,
  PaymentMethodHandler,
  SettlePaymentResult,
} from '@vendure/core';
import { loggerCtx } from './constants';
export const coinbaseHandler = new PaymentMethodHandler({
  code: 'coinbase-payment-handler',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Coinbase payment',
    },
  ],
  args: {
    apiKey: {
      type: 'string',
      label: [{ languageCode: LanguageCode.en, value: 'API Key' }],
    },
    redirectUrl: {
      type: 'string',
      label: [{ languageCode: LanguageCode.en, value: 'Redirect URL' }],
      description: [
        {
          languageCode: LanguageCode.en,
          value: 'Redirect the client to this URL after payment',
        },
      ],
    },
  },
  createPayment: async (
    ctx,
    order,
    amount,
    args,
    metadata
  ): Promise<CreatePaymentResult | CreatePaymentErrorResult> => {
    if (ctx.apiType !== 'admin') {
      throw Error(`CreatePayment is not allowed for apiType '${ctx.apiType}'`);
    }
    return {
      amount,
      state: 'Settled' as const,
      transactionId: metadata.paymentId,
      metadata,
    };
  },
  settlePayment: async (): Promise<SettlePaymentResult> => {
    return { success: true };
  },
  createRefund: async (
    ctx,
    input,
    amount,
    order,
    payment
  ): Promise<CreateRefundResult> => {
    Logger.warn(
      `This plugin does not support refunds. You need to manually refund ${payment.transactionId} via Coinbase`,
      loggerCtx
    );
    return {
      state: 'Failed',
      metadata: {
        public: {
          message: `This plugin does not support refunds. You need to manually refund ${payment.transactionId} via Coinbase`,
        },
      },
    };
  },
});
```

## File: packages/vendure-plugin-coinbase/src/coinbase.plugin.ts

```typescript
import {
  PluginCommonModule,
  RuntimeVendureConfig,
  VendurePlugin,
} from '@vendure/core';
import gql from 'graphql-tag';
import { CoinbaseController, CoinbaseResolver } from './coinbase.controller';
import { coinbaseHandler } from './coinbase.handler';
import { CoinbaseService } from './coinbase.service';
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [CoinbaseController],
  providers: [CoinbaseService],
  shopApiExtensions: {
    schema: gql`
      extend type Mutation {
        createCoinbasePaymentIntent: String!
      }
    `,
    resolvers: [CoinbaseResolver],
  },
  compatibility: '>=2.2.0',
  configuration: (config: RuntimeVendureConfig) => {
    config.paymentOptions.paymentMethodHandlers.push(coinbaseHandler);
    return config;
  },
})
export class CoinbasePlugin {}
```

## File: packages/vendure-plugin-coinbase/src/coinbase.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import {
  ActiveOrderService,
  ChannelService,
  EntityHydrator,
  ErrorResult,
  Logger,
  OrderService,
  OrderStateTransitionError,
  PaymentMethodService,
  RequestContext,
} from '@vendure/core';
import { coinbaseHandler } from './coinbase.handler';
import { loggerCtx } from './constants';
import { CoinbaseClient } from './coinbase.client';
import { ChargeConfirmedWebhookEvent } from './coinbase.types';
@Injectable()
export class CoinbaseService {
  constructor(
    private activeOrderService: ActiveOrderService,
    private orderService: OrderService,
    private channelService: ChannelService,
    private paymentMethodService: PaymentMethodService,
    private entityHydrator: EntityHydrator
  ) {}
  async createPaymentIntent(ctx: RequestContext): Promise<string> {
    const order = await this.activeOrderService.getOrderFromContext(ctx);
    if (!order) {
      throw Error('No active order found for session');
    }
    await this.entityHydrator.hydrate(ctx, order, {
      relations: ['lines', 'customer', 'shippingLines'],
    });
    if (!order.lines?.length) {
      throw Error('Cannot create payment intent for empty order');
    }
    if (!order.customer) {
      throw Error('Cannot create payment intent for order without customer');
    }
    if (!order.shippingLines?.length) {
      throw Error(
        'Cannot create payment intent for order without shippingMethod'
      );
    }
    const { apiKey, redirectUrl } = await this.getCoinbasePaymentMethod(ctx);
    const client = new CoinbaseClient({ apiKey });
    const result = await client.createCharge({
      name: `Order ${order.code}`,
      description: `Order ${order.code}`,
      local_price: {
        amount: `${(order.totalWithTax / 100).toFixed(2)}`,
        currency: order.currencyCode,
      },
      metadata: {
        orderCode: order.code,
        channelToken: ctx.channel.token,
      },
      pricing_type: 'fixed_price',
      redirect_url: `${redirectUrl}/${order.code}`,
    });
    return result.data.hosted_url;
  }
  async settlePayment(
    event: ChargeConfirmedWebhookEvent['event']
  ): Promise<void> {
    if (event?.type !== 'charge:confirmed') {
      Logger.info(
        `Incoming webhook is of type ${event?.type} for order ${event?.data?.metadata?.orderCode}, not processing this event.`,
        loggerCtx
      );
      return;
    }
    if (
      !event.data?.metadata?.orderCode ||
      !event.data.metadata.channelToken ||
      !event.data.code
    ) {
      throw Error(
        `Incoming Coinbase webhook is missing metadata.orderCode, metadata.channelToken or code field: ${JSON.stringify(
          event.data?.metadata
        )}`
      );
    }
    const orderCode = event.data.metadata.orderCode;
    const ctx = new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      channel: await this.channelService.getChannelFromToken(
        event.data.metadata.channelToken
      ),
      authorizedAsOwnerOnly: false,
    });
    const { apiKey, method } = await this.getCoinbasePaymentMethod(ctx);
    const client = new CoinbaseClient({ apiKey });
    const charge = await client.getCharge(event.data.code);
    console.log(JSON.stringify(charge));
    if (!charge.data.confirmed_at) {
      Logger.error(
        `Requested charge ${event.data.code} does not have 'confirmed_at' on Coinbase. This payment will not be settled.`,
        loggerCtx
      );
      return;
    }
    const order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      throw Error(
        `Unable to find order ${orderCode}, unable to settle payment ${event.data.code}!`
      );
    }
    if (order.state !== 'ArrangingPayment') {
      const transitionToStateResult = await this.orderService.transitionToState(
        ctx,
        order.id,
        'ArrangingPayment'
      );
      if (transitionToStateResult instanceof OrderStateTransitionError) {
        throw Error(
          `Error transitioning order ${order.code} from ${transitionToStateResult.fromState} to ${transitionToStateResult.toState}: ${transitionToStateResult.message}`
        );
      }
    }
    const addPaymentToOrderResult = await this.orderService.addPaymentToOrder(
      ctx,
      order.id,
      {
        method: method.code,
        metadata: {
          id: event.id,
          code: event.data.code,
          addresses: event.data.addresses,
          metadata: event.data.metadata,
        },
      }
    );
    if ((addPaymentToOrderResult as ErrorResult).errorCode) {
      throw Error(
        `Error adding payment to order ${orderCode}: ${
          (addPaymentToOrderResult as ErrorResult).message
        }`
      );
    }
    Logger.info(`Payment for order ${orderCode} settled`, loggerCtx);
  }
  private async getCoinbasePaymentMethod(ctx: RequestContext) {
    let { items } = await this.paymentMethodService.findAll(ctx);
    const method = items.find(
      (item) => item.handler.code === coinbaseHandler.code
    );
    if (!method) {
      throw Error(
        `No paymentMethod configured with handler ${coinbaseHandler.code}`
      );
    }
    const apiKey = method.handler.args.find((arg) => arg.name === 'apiKey');
    const redirectUrl = method.handler.args.find(
      (arg) => arg.name === 'redirectUrl'
    );
    if (!apiKey || !redirectUrl) {
      Logger.error(
        `CreatePaymentIntent failed, because no apiKey or redirect is configured for ${method.code}`,
        loggerCtx
      );
      throw Error(
        `Paymentmethod ${method.code} has no apiKey, sharedSecret or redirectUrl configured`
      );
    }
    return {
      apiKey: apiKey.value,
      redirectUrl: redirectUrl.value.endsWith('/')
        ? redirectUrl.value.slice(0, -1)
        : redirectUrl.value,
      method,
    };
  }
}
```

## File: packages/vendure-plugin-coinbase/src/coinbase.types.ts

```typescript
export interface Timeline {
  time: Date;
  status: string;
}
export interface Metadata {
  customer_id: string;
  customer_name: string;
}
export interface Local {
  amount: string;
  currency: string;
}
export interface Bitcoin {
  amount: string;
  currency: string;
}
export interface Ethereum {
  amount: string;
  currency: string;
}
export interface Pricing {
  local: Local;
  bitcoin: Bitcoin;
  ethereum: Ethereum;
}
export interface OverpaymentAbsoluteThreshold {
  amount: string;
  currency: string;
}
export interface UnderpaymentAbsoluteThreshold {
  amount: string;
  currency: string;
}
export interface PaymentThreshold {
  overpayment_absolute_threshold: OverpaymentAbsoluteThreshold;
  overpayment_relative_threshold: string;
  underpayment_absolute_threshold: UnderpaymentAbsoluteThreshold;
  underpayment_relative_threshold: string;
}
export interface Addresses {
  bitcoin: string;
  ethereum: string;
}
export interface Data {
  id: string;
  resource: string;
  code: string;
  name: string;
  description: string;
  logo_url: string;
  hosted_url: string;
  created_at: Date;
  expires_at: Date;
  confirmed_at: Date;
  timeline: Timeline[];
  metadata: Metadata;
  pricing_type: string;
  pricing: Pricing;
  payments: any[];
  payment_threshold: PaymentThreshold;
  addresses: Addresses;
  redirect_url: string;
  cancel_url: string;
}
export interface ChargeResult {
  data: Data;
}
export interface ChargeInput {
  name: string;
  description: string;
  local_price: {
    amount: string;
    currency: string;
  };
  metadata: {
    orderCode: string;
    channelToken: string;
  };
  pricing_type: 'fixed_price' | 'no_price';
  redirect_url: string;
}
export interface ChargeConfirmedWebhookEvent {
  event?: {
    id?: string;
    type?:
      | 'charge:created'
      | 'charge:confirmed'
      | 'charge:failed'
      | 'charge:pending';
    data?: {
      id?: string;
      code?: string;
      metadata?: {
        orderCode?: string;
        channelToken?: string;
      };
      addresses?: {
        [key: string]: string;
      };
    };
  };
}
```

## File: packages/vendure-plugin-coinbase/src/constants.ts

```typescript
export const loggerCtx = 'CoinbasePlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('COINBASE_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-coinbase/test/coinbase.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig, Order } from '@vendure/core';
import {
  createTestEnvironment,
  E2E_DEFAULT_CHANNEL_TOKEN,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { CoinbasePlugin } from '../src/coinbase.plugin';
import { coinbaseHandler } from '../src/coinbase.handler';
import {
  CreatePaymentMethod,
  LanguageCode,
} from '../../test/src/generated/admin-graphql';
import { addItem, setAddressAndShipping } from '../../test/src/shop-utils';
import nock from 'nock';
import axios, { AxiosInstance } from 'axios';
import { ChargeInput, ChargeResult } from '../src/coinbase.types';
import { getOrder } from '../../test/src/admin-utils';
import { CreatePaymentIntentMutation } from './queries';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
const mockData = {
  redirectUrl: 'https://my-storefront/order',
  apiKey: 'myApiKey',
  methodCode: `coinbase-payment-${E2E_DEFAULT_CHANNEL_TOKEN}`,
};
describe('Coinbase payments', () => {
  let shopClient: SimpleGraphQLClient;
  let adminClient: SimpleGraphQLClient;
  let httpClient: AxiosInstance;
  let server: TestServer;
  let started = false;
  let order: Order;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3107,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [CoinbasePlugin],
    });
    httpClient = axios.create({ baseURL: 'http://localhost:3107' });
    httpClient.defaults.headers.common['Content-Type'] = 'application/json';
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData,
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
    started = true;
    await adminClient.asSuperAdmin();
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
  }, 60000);
  afterAll(async () => {
    await server.destroy();
  }, 100000);
  it('Should start successfully', async () => {
    expect(started).toEqual(true);
  });
  it('Should add a Coinbase paymentMethod', async () => {
    const { createPaymentMethod } = await adminClient.query(
      CreatePaymentMethod,
      {
        input: {
          code: mockData.methodCode,
          enabled: true,
          handler: {
            code: coinbaseHandler.code,
            arguments: [
              { name: 'redirectUrl', value: mockData.redirectUrl },
              { name: 'apiKey', value: mockData.apiKey },
            ],
          },
          translations: [
            {
              name: 'Coinbase payment test',
              description: 'This is a Coinbase test payment method',
              languageCode: LanguageCode.EnUs,
            },
          ],
        },
      }
    );
    expect(createPaymentMethod.code).toBe(mockData.methodCode);
  });
  it('Should fail payment intent without shipping', async () => {
    expect.assertions(1);
    order = await addItem(shopClient, 'T_2', 2);
    await shopClient.query(CreatePaymentIntentMutation).catch((error) => {
      expect(error).toBeDefined();
    });
  });
  it('Should create payment intent', async () => {
    let payload: ChargeInput;
    nock('https://api.commerce.coinbase.com/')
      .post('/charges', (reqBody) => {
        payload = reqBody;
        return true;
      })
      .reply(200, {
        data: { hosted_url: 'https://mock-hosted-checkout/charges' },
      });
    await setAddressAndShipping(shopClient, 'T_1');
    const { createCoinbasePaymentIntent } = await shopClient.query(
      CreatePaymentIntentMutation
    );
    expect(createCoinbasePaymentIntent).toBe(
      'https://mock-hosted-checkout/charges'
    );
    const adminOrder = await getOrder(adminClient, order.id as string);
    expect(payload!.metadata.channelToken).toBe(E2E_DEFAULT_CHANNEL_TOKEN);
    expect(payload!.metadata.orderCode).toBe(adminOrder!.code);
    expect(payload!.local_price.amount).toBe(
      (adminOrder!.totalWithTax / 100).toFixed(2)
    );
  });
  it('Should fail for malicious webhook', async () => {
    nock('https://api.commerce.coinbase.com/')
      .get('/charges/coinbase-mock-id')
      .reply(200, {
        data: {
          hosted_url: 'https://mock-hosted-checkout/charges',
        },
      } as Partial<ChargeResult>);
    await httpClient.post('/payments/coinbase', {
      event: {
        type: 'charge:confirmed',
        data: {
          code: 'coinbase-mock-id',
          metadata: {
            orderCode: order.code,
            channelToken: E2E_DEFAULT_CHANNEL_TOKEN,
          },
        },
      },
    });
    const adminOrder = await getOrder(adminClient, order.id as string);
    expect(adminOrder?.state).toEqual('AddingItems');
  });
  it('Should settle order for valid webhook', async () => {
    nock('https://api.commerce.coinbase.com/')
      .get('/charges/coinbase-mock-id')
      .reply(200, {
        data: {
          confirmed_at: new Date(),
          hosted_url: 'https://mock-hosted-checkout/charges',
        },
      } as Partial<ChargeResult>);
    await httpClient.post('/payments/coinbase', {
      event: {
        type: 'charge:confirmed',
        data: {
          code: 'coinbase-mock-id',
          metadata: {
            orderCode: order.code,
            channelToken: E2E_DEFAULT_CHANNEL_TOKEN,
          },
        },
      },
    });
    const adminOrder = await getOrder(adminClient, order.id as string);
    expect(adminOrder?.state).toEqual('PaymentSettled');
  });
});
```

## File: packages/vendure-plugin-coinbase/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  mergeConfig,
  ProductVariantPrice,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { initialData } from '../../test/src/initial-data';
import { CoinbasePlugin } from '../src/coinbase.plugin';
import { Connection } from 'typeorm';
import { addItem, setAddressAndShipping } from '../../test/src/shop-utils';
import { CreatePaymentIntentMutation } from './queries';
import {
  CreatePaymentMethod,
  LanguageCode,
} from '../../test/src/generated/admin-graphql';
import { coinbaseHandler } from '../src/coinbase.handler';
import { addShippingMethod } from '../../test/src/admin-utils';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    plugins: [
      CoinbasePlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
  await adminClient.query(CreatePaymentMethod, {
    input: {
      code: 'coinbase-payment',
      enabled: true,
      handler: {
        code: coinbaseHandler.code,
        arguments: [
          { name: 'redirectUrl', value: 'https://minishop.studio/order' },
          { name: 'apiKey', value: process.env.COINBASE_APIKEY },
        ],
      },
      translations: [
        {
          name: 'Coinbase payment test',
          description: 'This is a Coinbase test payment method',
          languageCode: LanguageCode.EnUs,
        },
      ],
    },
  });
  await server.app
    .get(Connection)
    .getRepository(ProductVariantPrice)
    .update({ id: 1 }, { price: 300 });
  console.log('Set variant T_1 to 3.00');
  await addShippingMethod(adminClient, 'manual-fulfillment', '0');
  console.log('Created shippingMethod with $0');
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  let order = await addItem(shopClient, 'T_1', 1);
  await setAddressAndShipping(shopClient, 'T_3');
  console.log('Created order with item and shipping');
  const { createCoinbasePaymentIntent } = await shopClient.query(
    CreatePaymentIntentMutation
  );
  console.log(`Pay with crypto on ${createCoinbasePaymentIntent}`);
})();
```

## File: packages/vendure-plugin-coinbase/test/queries.ts

```typescript
import gql from 'graphql-tag';
export const CreatePaymentIntentMutation = gql`
  mutation createCoinbasePaymentIntent {
    createCoinbasePaymentIntent
  }
`;
```

## File: packages/vendure-plugin-customer-managed-groups/src/api/admin-graphql.ts

```typescript
import { gql } from 'graphql-tag';
import { commonSchema } from './common-graphql';
export const adminSchema = gql`
  ${commonSchema}
  extend type Mutation {
    """
    Create an empty group with the specified customer as Administrator
    """
    createCustomerManagedGroup(customerId: ID!): CustomerManagedGroup!
  }
  extend type Query {
    ordersForCustomerManagedGroup(customerManagedGroupId: ID!): OrderList!
  }
`;
```

## File: packages/vendure-plugin-customer-managed-groups/src/api/common-graphql.ts

```typescript
import { gql } from 'graphql-tag';
const scalars = gql`
  scalar DateTime
  scalar OrderList
  scalar LanguageCode
  scalar JSON
`;
export const commonSchema = gql`
  type CustomerManagedGroupMember {
    customerId: ID!
    title: String
    addresses: [CustomerManagedGroupAddress!]
    firstName: String!
    lastName: String!
    emailAddress: String!
    isGroupAdministrator: Boolean!
    customFields: JSON
  }
  type CustomerManagedGroupAddress {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    fullName: String
    company: String
    streetLine1: String!
    streetLine2: String
    city: String
    province: String
    postalCode: String
    country: CustomerManagedGroupCountry!
    phoneNumber: String
    defaultShippingAddress: Boolean
    defaultBillingAddress: Boolean
  }
  type CustomerManagedGroupCountry {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    code: String!
    name: String!
    enabled: Boolean!
    translations: [CustomerManagedGroupCountryTranslation!]!
  }
  type CustomerManagedGroupCountryTranslation {
    id: ID!
    languageCode: LanguageCode!
    name: String!
  }
  type CustomerManagedGroup {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    name: String!
    customers: [CustomerManagedGroupMember!]!
  }
  extend type Mutation {
    makeCustomerAdminOfCustomerManagedGroup(
      groupId: ID!
      customerId: ID!
    ): CustomerManagedGroup!
  }
`;
```

## File: packages/vendure-plugin-customer-managed-groups/src/api/custom-fields.ts

```typescript
import {
  CustomerGroup,
  Customer,
  CustomFields,
  LanguageCode,
} from '@vendure/core';
export interface CustomerGroupWithCustomFields extends CustomerGroup {
  customFields: {
    isCustomerManaged?: boolean;
    groupAdmins?: Customer[];
  };
}
export interface CustomerWithCustomFields extends Customer {
  groups: CustomerGroupWithCustomFields[];
}
export const customFields: CustomFields = {
  CustomerGroup: [
    {
      name: 'groupAdmins',
      list: true,
      type: 'relation',
      entity: Customer,
      graphQLType: 'Customer',
      public: true,
      nullable: true,
      eager: true,
      readonly: false,
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'Administrators of this group',
        },
      ],
    },
    {
      name: 'isCustomerManaged',
      type: 'boolean',
      public: false,
      nullable: true,
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'Is customer managed',
        },
      ],
    },
  ],
};
```

## File: packages/vendure-plugin-customer-managed-groups/src/api/customer-managed-groups.resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  ID,
  Order,
  PaginatedList,
  Permission,
  RequestContext,
} from '@vendure/core';
import { CustomerManagedGroupsService } from './customer-managed-groups.service';
import {
  CustomerManagedGroup,
  MutationCreateCustomerManagedGroupArgs,
  MutationMakeCustomerAdminOfCustomerManagedGroupArgs,
  QueryOrdersForCustomerManagedGroupArgs,
} from './generated/admin-graphql';
import {
  AddCustomerToMyCustomerManagedGroupInput,
  CustomerManagedGroupMember,
  UpdateCustomerManagedGroupMemberInput,
} from './generated/shop-graphql';
@Resolver()
export class CustomerManagedGroupsAdminResolver {
  constructor(private service: CustomerManagedGroupsService) {}
  @Query()
  @Allow(Permission.Authenticated)
  ordersForCustomerManagedGroup(
    @Ctx() ctx: RequestContext,
    @Args() args: QueryOrdersForCustomerManagedGroupArgs
  ): Promise<PaginatedList<Order>> {
    return this.service.getOrdersForCustomer(ctx, args.customerManagedGroupId);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  createCustomerManagedGroup(
    @Ctx() ctx: RequestContext,
    @Args() args: MutationCreateCustomerManagedGroupArgs
  ): Promise<CustomerManagedGroup | undefined> {
    return this.service.createCustomerManagedGroup(ctx, args.customerId);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  makeCustomerAdminOfCustomerManagedGroup(
    @Ctx() ctx: RequestContext,
    @Args() args: MutationMakeCustomerAdminOfCustomerManagedGroupArgs
  ): Promise<CustomerManagedGroup> {
    return this.service.makeAdminOfGroup(
      ctx,
      args.groupId,
      args.customerId,
      true
    );
  }
}
@Resolver()
export class CustomerManagedGroupsShopResolver {
  constructor(private service: CustomerManagedGroupsService) {}
  @Query()
  @Allow(Permission.Authenticated)
  ordersForMyCustomerManagedGroup(
    @Ctx() ctx: RequestContext
  ): Promise<PaginatedList<Order>> {
    return this.service.getOrdersForCustomer(ctx);
  }
  @Query()
  @Allow(Permission.Authenticated)
  activeCustomerManagedGroupMember(
    @Ctx() ctx: RequestContext
  ): Promise<CustomerManagedGroupMember | undefined> {
    return this.service.getActiveMember(ctx);
  }
  @Query()
  @Allow(Permission.Authenticated)
  myCustomerManagedGroup(
    @Ctx() ctx: RequestContext
  ): Promise<CustomerManagedGroup | undefined> {
    return this.service.myCustomerManagedGroup(ctx);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  createCustomerManagedGroup(
    @Ctx() ctx: RequestContext
  ): Promise<CustomerManagedGroup | undefined> {
    return this.service.createCustomerManagedGroup(ctx);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  makeCustomerAdminOfCustomerManagedGroup(
    @Ctx() ctx: RequestContext,
    @Args('groupId') groupId: ID,
    @Args('customerId') customerId: ID
  ): Promise<CustomerManagedGroup> {
    return this.service.makeAdminOfGroup(ctx, groupId, customerId);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  addCustomerToMyCustomerManagedGroup(
    @Ctx() ctx: RequestContext,
    @Args('input') input: AddCustomerToMyCustomerManagedGroupInput
  ): Promise<CustomerManagedGroup> {
    return this.service.addToGroup(ctx, input);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  updateCustomerManagedGroupMember(
    @Ctx() ctx: RequestContext,
    @Args('input') input: UpdateCustomerManagedGroupMemberInput
  ): Promise<CustomerManagedGroup> {
    return this.service.updateGroupMember(ctx, input);
  }
  @Mutation()
  @Allow(Permission.Authenticated)
  removeCustomerFromMyCustomerManagedGroup(
    @Ctx() ctx: RequestContext,
    @Args('customerId') customerId: ID
  ): Promise<CustomerManagedGroup> {
    return this.service.removeFromGroup(ctx, customerId);
  }
}
```

## File: packages/vendure-plugin-customer-managed-groups/src/api/customer-managed-groups.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import {
  Customer,
  CustomerGroup,
  CustomerGroupService,
  CustomerService,
  EntityHydrator,
  EntityNotFoundError,
  ForbiddenError,
  ID,
  idsAreEqual,
  Logger,
  Order,
  OrderService,
  PaginatedList,
  RequestContext,
  TransactionalConnection,
  User,
  UserInputError,
} from '@vendure/core';
import {
  UpdateAddressInput,
  CreateAddressInput,
} from '@vendure/common/lib/generated-types';
import { loggerCtx } from '../constants';
import {
  CustomerGroupWithCustomFields,
  CustomerWithCustomFields,
} from './custom-fields';
import {
  AddCustomerToMyCustomerManagedGroupInput,
  UpdateCustomerManagedGroupMemberInput,
} from './generated/shop-graphql';
import {
  CustomerManagedGroup,
  CustomerManagedGroupMember,
} from './generated/admin-graphql';
@Injectable()
export class CustomerManagedGroupsService {
  constructor(
    private orderService: OrderService,
    private customerService: CustomerService,
    private customerGroupService: CustomerGroupService,
    private hydrator: EntityHydrator,
    private transactionalConnection: TransactionalConnection
  ) {}
  async getOrdersForCustomer(
    ctx: RequestContext,
    customerId?: ID
  ): Promise<PaginatedList<Order>> {
    let customer;
    if (customerId) {
      customer = await this.getOrThrowCustomer(ctx, customerId);
    } else {
      const userId = this.getOrThrowUserId(ctx);
      customer = await this.getOrThrowCustomerByUserId(ctx, userId);
    }
    const customerManagedGroup = this.getCustomerManagedGroup(customer);
    if (!customerManagedGroup) {
      throw new UserInputError(`You are not in a customer managed group`);
    }
    const isAdmin = this.isAdministratorOfGroup(
      customer.user!.id,
      customerManagedGroup
    );
    const orders: Order[] = [];
    const customers = isAdmin ? customerManagedGroup.customers : [customer];
    for (const customer of customers) {
      const ordersForCustomer = await this.orderService.findByCustomerId(
        ctx,
        customer.id
      );
      Logger.info(
        `Found ${ordersForCustomer.items.length} orders for customer ${customer.emailAddress}`,
        loggerCtx
      );
      orders.push(...ordersForCustomer.items);
      if (ordersForCustomer.totalItems > ordersForCustomer.items.length) {
        throw Error(
          `Too many orders for customer ${customer.emailAddress}, pagination is not implemented yet.`
        );
      }
    }
    return {
      items: orders,
      totalItems: orders.length,
    };
  }
  async addToGroup(
    ctx: RequestContext,
    {
      emailAddress: inviteeEmailAddress,
      isGroupAdmin: inviteeIsAdmin,
    }: AddCustomerToMyCustomerManagedGroupInput
  ): Promise<CustomerManagedGroup> {
    const userId = this.getOrThrowUserId(ctx);
    let [currentCustomer, invitee] = await Promise.all([
      this.getOrThrowCustomerByUserId(ctx, userId),
      this.getOrThrowCustomerByEmail(ctx, inviteeEmailAddress),
    ]);
    let customerManagedGroup = this.getCustomerManagedGroup(currentCustomer);
    if (customerManagedGroup) {
      this.throwIfNotAdministratorOfGroup(userId, customerManagedGroup);
    }
    if (!customerManagedGroup) {
      customerManagedGroup = await this.createGroup(ctx, currentCustomer, [
        invitee.id,
      ]);
    }
    const existingAdminIds = (
      customerManagedGroup.customFields.groupAdmins || []
    ).map((admin) => admin.id);
    const adminIds = [currentCustomer.id, ...existingAdminIds];
    Logger.info(
      `Adding ${currentCustomer.emailAddress} as administrator of group`,
      loggerCtx
    );
    if (inviteeIsAdmin) {
      adminIds.push(invitee.id);
      Logger.info(
        `Adding ${invitee.emailAddress} as administrator of group`,
        loggerCtx
      );
    }
    customerManagedGroup = await this.customerGroupService.update(ctx, {
      id: customerManagedGroup.id,
      customFields: {
        groupAdmins: adminIds.map((id) => ({ id })),
      },
    });
    await this.hydrator.hydrate(ctx, customerManagedGroup, {
      relations: ['customers'],
    });
    const existingCustomersIds = customerManagedGroup.customers.map(
      (customer) => customer.id
    );
    if (!existingCustomersIds.includes(invitee.id)) {
      customerManagedGroup =
        await this.customerGroupService.addCustomersToGroup(ctx, {
          customerGroupId: customerManagedGroup.id,
          customerIds: [invitee.id, ...existingCustomersIds],
        });
      Logger.info(
        `Added ${invitee.emailAddress} as participants of group`,
        loggerCtx
      );
    }
    currentCustomer = await this.getOrThrowCustomerByUserId(ctx, userId);
    customerManagedGroup = this.getCustomerManagedGroup(currentCustomer)!;
    return this.mapToCustomerManagedGroup(customerManagedGroup);
  }
  async removeFromGroup(
    ctx: RequestContext,
    customerIdToRemove: ID
  ): Promise<CustomerManagedGroup> {
    const userId = this.getOrThrowUserId(ctx);
    let customer = await this.getOrThrowCustomerByUserId(ctx, userId);
    let customerManagedGroup = this.getCustomerManagedGroup(customer);
    if (!customerManagedGroup) {
      throw new UserInputError(`You are not in a customer managed group`);
    }
    this.throwIfNotAdministratorOfGroup(userId, customerManagedGroup);
    const customerToRemove = customerManagedGroup.customers.find(
      (c) => c.id == customerIdToRemove
    );
    if (!customerToRemove) {
      throw new UserInputError(
        `Customer '${customerIdToRemove}' is not in your group`
      );
    }
    if (idsAreEqual(customer.id, customerToRemove.id)) {
      throw new UserInputError(`You cannot remove yourself from your group`);
    }
    customerManagedGroup =
      await this.customerGroupService.removeCustomersFromGroup(ctx, {
        customerGroupId: customerManagedGroup.id,
        customerIds: [customerIdToRemove],
      });
    Logger.info(
      `Removed customer ${customerToRemove.emailAddress} from group`,
      loggerCtx
    );
    const existingAdminIds =
      customerManagedGroup.customFields.groupAdmins?.map((a) => a.id) || [];
    if (existingAdminIds.includes(customerToRemove.id)) {
      const newAdminIds = existingAdminIds.filter(
        (id) => id != customerToRemove.id
      );
      customerManagedGroup = await this.customerGroupService.update(ctx, {
        id: customerManagedGroup.id,
        customFields: {
          groupAdmins: newAdminIds.map((id) => ({ id })),
        },
      });
      Logger.info(
        `Removed ${customerToRemove.emailAddress} as group administrator`,
        loggerCtx
      );
    }
    customer = await this.getOrThrowCustomerByUserId(ctx, userId);
    customerManagedGroup = this.getCustomerManagedGroup(customer);
    return this.mapToCustomerManagedGroup(customerManagedGroup!);
  }
  async getOrThrowCustomerByUserId(
    ctx: RequestContext,
    userId: ID
  ): Promise<CustomerWithCustomFields> {
    const customerRepo = this.transactionalConnection.getRepository(
      ctx,
      Customer
    );
    const customerWithGroupsData = await customerRepo
      .createQueryBuilder('customer')
      .leftJoin('customer.channels', 'customer_channel')
      .leftJoinAndSelect('customer.user', 'user')
      .leftJoinAndSelect('customer.addresses', 'customerAddress')
      .leftJoinAndSelect('customerAddress.country', 'customerCountry')
      .leftJoinAndSelect('customer.groups', 'groups')
      .leftJoinAndSelect('groups.customers', 'customers')
      .leftJoinAndSelect('groups.customFields.groupAdmins', 'groupAdmins')
      .leftJoinAndSelect('groupAdmins.user', 'groupAdminsUser')
      .leftJoinAndSelect('groupAdmins.addresses', 'groupAdminAddresses')
      .leftJoinAndSelect('groupAdminAddresses.country', 'groupAdminCountries')
      .leftJoinAndSelect('customers.addresses', 'addresses')
      .leftJoinAndSelect('addresses.country', 'country')
      .where('user.id = :userId', { userId: userId })
      .andWhere('customer_channel.id = :customerChannelId', {
        customerChannelId: ctx.channelId,
      })
      .getOne();
    if (!customerWithGroupsData) {
      throw new UserInputError(`No customer found for user with id ${userId}`);
    }
    return customerWithGroupsData;
  }
  async getOrThrowCustomerByEmail(
    ctx: RequestContext,
    emailAddress: string
  ): Promise<Customer> {
    const customers = await this.customerService.findAll(ctx, {
      filter: {
        emailAddress: {
          eq: emailAddress,
        },
      },
    });
    if (!customers.items[0]) {
      throw new UserInputError(
        `No customer found for email adress ${emailAddress}`
      );
    }
    return customers.items[0];
  }
  getOrThrowUserId(ctx: RequestContext): ID {
    if (!ctx.activeUserId) {
      throw new ForbiddenError();
    }
    return ctx.activeUserId;
  }
  async getOrThrowCustomer(
    ctx: RequestContext,
    customerId: ID
  ): Promise<Customer> {
    const customer = await this.customerService.findOne(ctx, customerId, [
      'user',
      'groups',
      'groups.customers',
      'groups.customFields.groupAdmins',
      'groups.customFields.groupAdmins.user',
    ]);
    if (!customer) {
      throw new EntityNotFoundError('Customer', customerId);
    }
    return customer;
  }
  throwIfNotAdministratorOfGroup(
    userId: ID,
    group: CustomerGroupWithCustomFields
  ): void {
    if (!this.isAdministratorOfGroup(userId, group)) {
      throw new UserInputError('You are not administrator of your group');
    }
  }
  isAdministratorOfGroup(
    userId: ID,
    group: CustomerGroupWithCustomFields
  ): boolean {
    return !!group.customFields.groupAdmins?.find(
      (admin) => admin.user!.id == userId
    );
  }
  getCustomerManagedGroup(
    customer: CustomerWithCustomFields
  ): CustomerGroupWithCustomFields | undefined {
    if (!customer.groups) {
      throw Error(
        `Make sure to include groups in the customer query. Can not find customer managed group for customer ${customer.emailAddress}`
      );
    }
    return customer.groups.find(
      (group) => group.customFields.isCustomerManaged
    );
  }
  async getActiveMember(
    ctx: RequestContext
  ): Promise<CustomerManagedGroupMember | undefined> {
    const userId = this.getOrThrowUserId(ctx);
    const customer = await this.getOrThrowCustomerByUserId(ctx, userId);
    const customerManagedGroup = this.getCustomerManagedGroup(customer);
    if (!customerManagedGroup) {
      return;
    }
    const isAdministrator = this.isAdministratorOfGroup(
      userId,
      customerManagedGroup
    );
    return this.mapToCustomerManagedGroupMember(customer, isAdministrator);
  }
  async myCustomerManagedGroup(
    ctx: RequestContext
  ): Promise<CustomerManagedGroup | undefined> {
    let customerManagedGroup =
      await this.myCustomerManagedGroupWithCustomFields(ctx);
    if (!customerManagedGroup) {
      return undefined;
    }
    return this.mapToCustomerManagedGroup(customerManagedGroup);
  }
  async myCustomerManagedGroupWithCustomFields(
    ctx: RequestContext
  ): Promise<CustomerGroupWithCustomFields | undefined> {
    const userId = this.getOrThrowUserId(ctx);
    const customer = await this.getOrThrowCustomerByUserId(ctx, userId);
    let customerManagedGroup = this.getCustomerManagedGroup(customer);
    if (!customerManagedGroup) {
      return undefined;
    }
    return customerManagedGroup;
  }
  async createCustomerManagedGroup(
    ctx: RequestContext,
    customerId?: ID
  ): Promise<CustomerManagedGroup> {
    let customer;
    if (customerId) {
      customer = await this.getOrThrowCustomer(ctx, customerId);
    } else {
      const userId = this.getOrThrowUserId(ctx);
      customer = await this.getOrThrowCustomerByUserId(ctx, userId);
    }
    let customerManagedGroup = this.getCustomerManagedGroup(customer);
    if (customerManagedGroup) {
      throw new UserInputError(`You are already in a customer managed group`);
    }
    customerManagedGroup = await this.createGroup(ctx, customer);
    await this.hydrator.hydrate(ctx, customerManagedGroup, {
      relations: ['customers'],
    });
    return this.mapToCustomerManagedGroup(customerManagedGroup);
  }
  private createGroup(
    ctx: RequestContext,
    groupAdmin: Customer,
    additionalMembers?: ID[]
  ): Promise<CustomerGroupWithCustomFields> {
    const members = [groupAdmin.id];
    if (additionalMembers) {
      members.push(...additionalMembers);
    }
    return this.customerGroupService.create(ctx, {
      name: `${groupAdmin.lastName}'s Group`,
      customerIds: members,
      customFields: {
        isCustomerManaged: true,
        groupAdmins: [groupAdmin],
      },
    });
  }
  mapToCustomerManagedGroup(
    group: CustomerGroupWithCustomFields
  ): CustomerManagedGroup {
    const adminIds =
      group.customFields.groupAdmins?.map((admin) => admin.id) || [];
    const participants = group.customers
      .filter((customer) => !adminIds.includes(customer.id))
      .map((c) => this.mapToCustomerManagedGroupMember(c, false));
    const administrators = (group.customFields.groupAdmins || []).map((a) =>
      this.mapToCustomerManagedGroupMember(a, true)
    );
    return {
      ...group,
      customers: [...administrators, ...participants],
    };
  }
  mapToCustomerManagedGroupMember(
    customer: Customer,
    isGroupAdministrator: boolean
  ): CustomerManagedGroupMember {
    return {
      ...customer,
      addresses: customer.addresses,
      customFields: customer.customFields,
      customerId: customer.id,
      isGroupAdministrator,
    };
  }
  async updateGroupMember(
    ctx: RequestContext,
    input: UpdateCustomerManagedGroupMemberInput
  ): Promise<CustomerManagedGroup> {
    if (
      !input.title &&
      !input.firstName &&
      !input.lastName &&
      !input.emailAddress &&
      !input.addresses?.length &&
      !input.customFields
    ) {
      throw new UserInputError(`Make sure to include fields to be updated`);
    }
    if (!ctx.activeUserId) {
      throw new ForbiddenError();
    }
    const myGroup = await this.myCustomerManagedGroupWithCustomFields(ctx);
    if (!myGroup) {
      throw new UserInputError(
        `No customer managed group exists for the authenticated customer`
      );
    }
    const member = myGroup.customers.find(
      (customer) => customer.id === input.customerId
    );
    if (!member) {
      throw new UserInputError(
        `No customer with id ${input.customerId} exists in '${myGroup.name}' customer managed group`
      );
    }
    const customer = await this.customerService.findOne(ctx, member.id, [
      'user',
    ]);
    if (!customer || !customer.user) {
      throw new UserInputError(
        `No customer with id ${input.customerId} exists`
      );
    }
    if (
      !this.isAdministratorOfGroup(ctx.activeUserId, myGroup) &&
      customer.user.id !== ctx.activeUserId
    ) {
      throw new UserInputError(
        `You are not allowed to update other member's details`
      );
    }
    const userRepo = this.transactionalConnection.getRepository(ctx, User);
    if (
      input.emailAddress &&
      (await userRepo.count({
        where: { identifier: input.emailAddress },
      }))
    ) {
      throw new UserInputError('User with this email already exists');
    }
    const updateCustomerData = {
      id: customer.id,
      ...(input.title ? { title: input.title } : []),
      ...(input.firstName ? { firstName: input.firstName } : []),
      ...(input.lastName ? { lastName: input.lastName } : []),
      ...(input.emailAddress ? { emailAddress: input.emailAddress } : []),
      ...(input.customFields ? { customFields: input.customFields } : []),
    };
    await this.customerService.update(ctx, updateCustomerData);
    if (input.addresses?.length) {
      for (let addressInput of input.addresses) {
        if (addressInput?.id) {
          await this.customerService.updateAddress(
            ctx,
            addressInput as UpdateAddressInput
          );
        } else {
          await this.customerService.createAddress(
            ctx,
            customer.id,
            addressInput as CreateAddressInput
          );
        }
      }
    }
    const newGroupData = await this.myCustomerManagedGroup(ctx);
    if (!newGroupData) {
      throw Error(`Group with id ${myGroup.id} not found`);
    }
    return newGroupData!;
  }
  async makeAdminOfGroup(
    ctx: RequestContext,
    groupId: ID,
    customerId: ID,
    isAdmin?: boolean
  ): Promise<CustomerManagedGroup> {
    const customerGroup = await this.customerGroupService.findOne(
      ctx,
      groupId,
      ['customers', 'customers.user']
    );
    if (
      !customerGroup ||
      !customerGroup.customFields ||
      !(customerGroup.customFields as any).isCustomerManaged
    ) {
      throw new UserInputError(
        `No customer managed group with id ${groupId} exists`
      );
    }
    if (
      !isAdmin &&
      !(customerGroup.customFields as any).groupAdmins.find(
        (admin: Customer) => admin.user?.id === ctx.activeUserId
      )
    ) {
      throw new UserInputError(
        `You are not admin of this customer managed group`
      );
    }
    const customerInQuestion = await customerGroup.customers.find(
      (c) => c.id === customerId
    );
    if (!customerInQuestion) {
      throw new UserInputError(
        `Customer with id ${customerId} is not part of this customer managed group`
      );
    }
    if (
      (customerGroup.customFields as any).groupAdmins.find(
        (admin: Customer) => admin.id === customerId
      )
    ) {
      throw new UserInputError(
        'Customer is already admin of this customer managed group'
      );
    }
    const customerGroupRepo = this.transactionalConnection.getRepository(
      ctx,
      CustomerGroup
    );
    const partialValue = {
      id: customerGroup.id,
      customFields: {
        groupAdmins: [
          ...(customerGroup.customFields as any).groupAdmins,
          customerInQuestion,
        ],
      },
    };
    await customerGroupRepo.save(partialValue);
    return this.mapToCustomerManagedGroup(
      (await this.customerGroupService.findOne(ctx, groupId, ['customers']))!
    );
  }
}
```

## File: packages/vendure-plugin-customer-managed-groups/src/api/shop-graphql.ts

```typescript
import { gql } from 'graphql-tag';
import { commonSchema } from './common-graphql';
export const shopSchema = gql`
  ${commonSchema}
  input AddCustomerToMyCustomerManagedGroupInput {
    emailAddress: String!
    isGroupAdmin: Boolean
  }
  input UpdateCustomerManagedGroupMemberInput {
    title: String
    firstName: String
    lastName: String
    emailAddress: String
    addresses: [CustomerManagedGroupAddressInput!]
    customerId: ID!
    customFields: JSON
  }
  """
  When no ID is given, a new address will be created
  """
  input CustomerManagedGroupAddressInput {
    id: ID
    fullName: String
    company: String
    streetLine1: String
    streetLine2: String
    city: String
    province: String
    postalCode: String
    countryCode: String
    phoneNumber: String
    defaultShippingAddress: Boolean
    defaultBillingAddress: Boolean
  }
  extend type Mutation {
    """
    Creates a group with the current logged in user as administrator of the group
    """
    addCustomerToMyCustomerManagedGroup(
      input: AddCustomerToMyCustomerManagedGroupInput
    ): CustomerManagedGroup!
    """
    Create an empty group with the current user as Administrator
    """
    createCustomerManagedGroup: CustomerManagedGroup!
    removeCustomerFromMyCustomerManagedGroup(
      customerId: ID!
    ): CustomerManagedGroup!
    """
    Update a member of one's group
    """
    updateCustomerManagedGroupMember(
      input: UpdateCustomerManagedGroupMemberInput!
    ): CustomerManagedGroup!
  }
  extend type Query {
    """
    Fetch placed orders for each member of the group
    """
    ordersForMyCustomerManagedGroup: OrderList!
    """
    Fetch the current logged in group member
    """
    activeCustomerManagedGroupMember: CustomerManagedGroupMember
    myCustomerManagedGroup: CustomerManagedGroup
  }
`;
```

## File: packages/vendure-plugin-customer-managed-groups/src/constants.ts

```typescript
export const loggerCtx = 'CustomerManagedGroupsPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-customer-managed-groups/src/customer-managed-groups.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { shopSchema } from './api/shop-graphql';
import { adminSchema } from './api/admin-graphql';
import { customFields } from './api/custom-fields';
import { CustomerManagedGroupsService } from './api/customer-managed-groups.service';
import {
  CustomerManagedGroupsAdminResolver,
  CustomerManagedGroupsShopResolver,
} from './api/customer-managed-groups.resolver';
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [CustomerManagedGroupsService],
  adminApiExtensions: {
    resolvers: [CustomerManagedGroupsAdminResolver],
    schema: adminSchema,
  },
  shopApiExtensions: {
    resolvers: [CustomerManagedGroupsShopResolver],
    schema: shopSchema,
  },
  configuration: (config) => {
    config.customFields = {
      ...config.customFields,
      ...customFields,
    };
    return config;
  },
  compatibility: '>=2.2.0',
})
export class CustomerManagedGroupsPlugin {}
```

## File: packages/vendure-plugin-customer-managed-groups/src/index.ts

```typescript
export * from './customer-managed-groups.plugin';
export * from './api/customer-managed-groups.service';
export * from './api/shop-graphql';
export * from './api/admin-graphql';
export * from './api/custom-fields';
```

## File: packages/vendure-plugin-customer-managed-groups/test/customer-managed-groups.spec.ts

```typescript
import fs from 'fs';
import path from 'path';
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { CustomerManagedGroupsPlugin } from '../src';
import {
  activeCustomerManagedGroupMemberQuery,
  adminCreateCustomerManagedGroupMutation,
  addCustomer,
  createCustomerManagedGroupMutation,
  getOrdersForMyCustomerManagedGroup,
  makeCustomerAdminOfCustomerManagedGroupMutation,
  myCustomerManagedGroupQuery,
  removeCustomerFromGroupMutation,
  updateCustomerManagedGroupMemberMutation,
  adminCustomerManagedGroupQuery,
  adminMakeCustomerAdminOfGroupMutation,
  addCustomerToMyCustomerManagedGroupMutation,
  adminAddCustomersToGroupMutation,
  customers,
  adminGetOrdersForCustomerManagedGroup,
} from './test-helpers';
import { createSettledOrder } from '../../test/src/shop-utils';
import { Address } from '../../test/src/generated/shop-graphql';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
describe('Customer managed groups', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [CustomerManagedGroupsPlugin],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
      customFields: {
        Order: [
          {
            name: 'testing',
            type: 'string',
            defaultValue: 'just a test',
            public: true,
          },
        ],
        Customer: [
          {
            name: 'birthday',
            type: 'string',
            defaultValue: '',
            public: false,
          },
        ],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    try {
      await server.init({
        initialData: {
          ...initialData,
          paymentMethods: [
            {
              name: testPaymentMethod.code,
              handler: { code: testPaymentMethod.code, arguments: [] },
            },
          ],
        },
        productsCsvPath: '../test/src/products-import.csv',
        customerCount: 5,
      });
    } catch (err) {
      console.log('Error init server', err);
    }
  }, 60000);
  function authorizeAsGroupAdmin(): Promise<void> {
    return shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
  }
  function authorizeAsGroupParticipant(): Promise<void> {
    return shopClient.asUserWithCredentials('eliezer56@yahoo.com', 'test');
  }
  it('Should start successfully', async () => {
    expect(server.app.getHttpServer).toBeDefined();
  });
  it('Fails for unauthenticated calls', async () => {
    expect.assertions(1);
    try {
      await shopClient.query(addCustomerToMyCustomerManagedGroupMutation, {
        input: {
          emailAddress: 'marques.sawayn@hotmail.com',
        },
      });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        'You are not currently authorized to perform this action'
      );
    }
  });
  it('Returns undefined for myCustomerManagedGroup when not in a group', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    expect(group).toBe(null);
  });
  it('Returns undefined for activeCustomerManagedGroupMember when not in a group', async () => {
    await authorizeAsGroupAdmin();
    const { activeCustomerManagedGroupMember: member } = await shopClient.query(
      activeCustomerManagedGroupMemberQuery
    );
    expect(member).toBe(null);
  });
  it('Adds a customer to my group', async () => {
    await authorizeAsGroupAdmin();
    const { addCustomerToMyCustomerManagedGroup: group } =
      await shopClient.query(addCustomerToMyCustomerManagedGroupMutation, {
        input: {
          emailAddress: 'marques.sawayn@hotmail.com',
        },
      });
    const hayden = group.customers.find(
      (c: any) => c.emailAddress === 'hayden.zieme12@hotmail.com'
    );
    const marques = group.customers.find(
      (c: any) => c.emailAddress === 'marques.sawayn@hotmail.com'
    );
    expect(group.name).toBe("Zieme's Group");
    expect(hayden.isGroupAdministrator).toBe(true);
    expect(marques.isGroupAdministrator).toBe(false);
  });
  it('Returns active member when in a group', async () => {
    await authorizeAsGroupAdmin();
    const { activeCustomerManagedGroupMember: member } = await shopClient.query(
      activeCustomerManagedGroupMemberQuery
    );
    expect(member.isGroupAdministrator).toBe(true);
  });
  it('Returns my group', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    expect(group.name).toBe("Zieme's Group");
  });
  it('Adds another customer to my group', async () => {
    await authorizeAsGroupAdmin();
    const { addCustomerToMyCustomerManagedGroup: group } =
      await shopClient.query(addCustomerToMyCustomerManagedGroupMutation, {
        input: {
          emailAddress: 'eliezer56@yahoo.com',
        },
      });
    const marques = group.customers.find(
      (c: any) => c.emailAddress === 'marques.sawayn@hotmail.com'
    );
    const eliezer = group.customers.find(
      (c: any) => c.emailAddress === 'eliezer56@yahoo.com'
    );
    expect(marques.isGroupAdministrator).toBe(false);
    expect(eliezer.isGroupAdministrator).toBe(false);
  });
  it('Fails to create a group if user is already in a group', async () => {
    expect.assertions(1);
    await authorizeAsGroupAdmin();
    try {
      await shopClient.query(createCustomerManagedGroupMutation);
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        'You are already in a customer managed group'
      );
    }
  });
  it('Fails when a participant tries to add customers', async () => {
    expect.assertions(1);
    await authorizeAsGroupParticipant();
    try {
      await shopClient.query(addCustomerToMyCustomerManagedGroupMutation, {
        input: {
          emailAddress: 'marques.sawayn@hotmail.com',
        },
      });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        'You are not administrator of your group'
      );
    }
  });
  it('Places an order for the group participant', async () => {
    await authorizeAsGroupParticipant();
    const order = await createSettledOrder(shopClient, 1, false);
    expect(order.code).toBeDefined();
  });
  it('Places an order for the group admin', async () => {
    await authorizeAsGroupAdmin();
    const order = await createSettledOrder(shopClient, 1, false);
    expect(order.code).toBeDefined();
  });
  it('Fails to fetch orders when unauthenticated', async () => {
    expect.assertions(1);
    await shopClient.asAnonymousUser();
    try {
      await shopClient.query(getOrdersForMyCustomerManagedGroup);
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        'You are not currently authorized to perform this action'
      );
    }
  });
  it('Fetches 2 orders for the group admin', async () => {
    await authorizeAsGroupAdmin();
    const orders = await shopClient.query(getOrdersForMyCustomerManagedGroup);
    expect(orders.ordersForMyCustomerManagedGroup.totalItems).toBe(2);
    expect(orders.ordersForMyCustomerManagedGroup.items[0].code).toBeDefined();
    expect(orders.ordersForMyCustomerManagedGroup.items[1].code).toBeDefined();
    expect(
      orders.ordersForMyCustomerManagedGroup.items[1].lines.length
    ).toBeGreaterThan(0);
    expect(
      orders.ordersForMyCustomerManagedGroup.items[1].payments.length
    ).toBeGreaterThan(0);
    expect(
      orders.ordersForMyCustomerManagedGroup.items[1].customFields.testing
    ).toBe('just a test');
  });
  it('Fetches 1 order for the group participant', async () => {
    await authorizeAsGroupParticipant();
    const orders = await shopClient.query(getOrdersForMyCustomerManagedGroup);
    expect(orders.ordersForMyCustomerManagedGroup.totalItems).toBe(1);
  });
  it('Fails to remove as group participant', async () => {
    expect.assertions(1);
    await authorizeAsGroupParticipant();
    try {
      await shopClient.query(removeCustomerFromGroupMutation, {
        customerId: '3',
      });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        'You are not administrator of your group'
      );
    }
  });
  it('Removes customer', async () => {
    await authorizeAsGroupAdmin();
    const { removeCustomerFromMyCustomerManagedGroup: group } =
      await shopClient.query(removeCustomerFromGroupMutation, {
        customerId: '3',
      });
    const marques = group.customers.find(
      (c: any) => c.emailAddress === 'marques.sawayn@hotmail.com'
    );
    expect(marques).toBeUndefined();
  });
  it('You cannot remove yourself from your group', async () => {
    expect.assertions(1);
    await authorizeAsGroupAdmin();
    try {
      await shopClient.query(removeCustomerFromGroupMutation, {
        customerId: '1',
      });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        'You cannot remove yourself from your group'
      );
    }
  });
  it('Adds another group admin to my group', async () => {
    await authorizeAsGroupAdmin();
    const { addCustomerToMyCustomerManagedGroup: group } =
      await shopClient.query(addCustomerToMyCustomerManagedGroupMutation, {
        input: {
          emailAddress: 'marques.sawayn@hotmail.com',
          isGroupAdmin: true,
        },
      });
    const marques = group.customers.find(
      (c: any) => c.emailAddress === 'marques.sawayn@hotmail.com'
    );
    expect(marques.isGroupAdministrator).toBe(true);
  });
  it('Removes an admin from the group', async () => {
    await authorizeAsGroupAdmin();
    const { removeCustomerFromMyCustomerManagedGroup: group } =
      await shopClient.query(removeCustomerFromGroupMutation, {
        customerId: '3',
      });
    const marques = group.customers.find(
      (c: any) => c.emailAddress === 'marques.sawayn@hotmail.com'
    );
    expect(marques).toBeUndefined();
  });
  it('Members can update their own profiles with this query', async () => {
    await authorizeAsGroupParticipant();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const authorizedCustomer = group.customers.find(
      (c: any) => c.emailAddress === 'eliezer56@yahoo.com'
    );
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          lastName: 'Teklu',
          customerId: authorizedCustomer.customerId,
        },
      });
    const authorizedCustomerUpdated = newGroup.customers.find(
      (c: any) => c.emailAddress === 'eliezer56@yahoo.com'
    );
    expect(authorizedCustomerUpdated.lastName).toBe('Teklu');
  });
  it('Members can not update any other profiles ', async () => {
    await authorizeAsGroupParticipant();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const unAuthorizedCustomer = group.customers.find(
      (c: any) => c.emailAddress === 'hayden.zieme12@hotmail.com'
    );
    try {
      const { updateCustomerManagedGroupMember: newGroup } =
        await shopClient.query(updateCustomerManagedGroupMemberMutation, {
          input: {
            lastName: 'Teklu',
            customerId: unAuthorizedCustomer.customerId,
          },
        });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        `You are not allowed to update other member's details`
      );
    }
  });
  it('Unauthenticated users can not update any profiles', async () => {
    await shopClient.asAnonymousUser();
    try {
      const { updateCustomerManagedGroupMember: newGroup } =
        await shopClient.query(updateCustomerManagedGroupMemberMutation, {
          input: {
            lastName: 'Teklu',
            customerId: 1,
          },
        });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        `You are not currently authorized to perform this action`
      );
    }
  });
  it('Administrators can update their own profiles ', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const groupAdmin = group.customers.find((c: any) => c.isGroupAdministrator);
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          firstName: 'Semahegn',
          customerId: groupAdmin.customerId,
        },
      });
    const authorizedCustomerUpdated = newGroup.customers.find(
      (c: any) => c.isGroupAdministrator
    );
    expect(authorizedCustomerUpdated.firstName).toBe('Semahegn');
  });
  it('Administrators can update members of their group ', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const groupMember = group.customers.find(
      (c: any) => c.emailAddress === 'eliezer56@yahoo.com'
    );
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          emailAddress: 'mohammed.salah@gmail.com',
          customerId: groupMember.customerId,
        },
      });
    const updatedGroupMember = newGroup.customers.find(
      (c: any) => c.customerId === groupMember.customerId
    );
    expect(updatedGroupMember.emailAddress).toBe('mohammed.salah@gmail.com');
  });
  it('Administrators can not update members of other groups ', async () => {
    await shopClient.asUserWithCredentials(
      'stewart.lindgren@gmail.com',
      'test'
    );
    const { createCustomerManagedGroup: groupData } = await shopClient.query(
      createCustomerManagedGroupMutation
    );
    try {
      const { updateCustomerManagedGroupMember: newGroup } =
        await shopClient.query(updateCustomerManagedGroupMemberMutation, {
          input: {
            lastName: 'Teklu',
            customerId: 1,
          },
        });
    } catch (e) {
      expect((e as any).response.errors[0].message).toBe(
        `No customer with id 1 exists in '${groupData.name}' customer managed group`
      );
    }
  });
  it('Administrators can assign other members as administrators ', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const { makeCustomerAdminOfCustomerManagedGroup: updatedGroup } =
      await shopClient.query(makeCustomerAdminOfCustomerManagedGroupMutation, {
        groupId: group.id,
        customerId: 4,
      });
    const updatedCustomer = updatedGroup.customers.find(
      (c: any) => c.customerId === 'T_4'
    );
    expect(updatedCustomer.isGroupAdministrator).toBe(true);
  });
  it('Administrators can also update other administrators in their group ', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const updatedCustomer = group.customers.find(
      (c: any) => c.customerId === 'T_4'
    );
    expect(updatedCustomer.isGroupAdministrator).toBe(true);
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          emailAddress: 'selam.lalem@gmail.com',
          customerId: updatedCustomer.customerId,
        },
      });
    const updatedGroupMember = newGroup.customers.find(
      (c: any) => c.customerId === updatedCustomer.customerId
    );
    expect(updatedGroupMember.emailAddress).toBe('selam.lalem@gmail.com');
  });
  it('Administrators can create new addresses for themselves', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const groupAdmin = group.customers.find((c: any) => c.isGroupAdministrator);
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          addresses: [
            {
              streetLine1: 'Selam Street',
              countryCode: 'US',
            },
          ],
          customerId: groupAdmin.customerId,
        },
      });
    const authorizedCustomerUpdated = newGroup.customers.find(
      (c: any) => c.isGroupAdministrator
    );
    expect(authorizedCustomerUpdated.addresses).toBeDefined();
    expect(
      authorizedCustomerUpdated.addresses.find(
        (a: Address) =>
          a.streetLine1 === 'Selam Street' && a.country.code === 'US'
      )
    ).toBeDefined();
  });
  it('Administrators can update their addresses', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const groupAdmin = group.customers.find((c: any) => c.isGroupAdministrator);
    const addressTobeUpdated: Address = groupAdmin.addresses[0];
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          addresses: [
            {
              id: addressTobeUpdated.id,
              streetLine2: 'Melkam Menged',
              phoneNumber: '+251963215487',
            },
          ],
          customerId: groupAdmin.customerId,
        },
      });
    const authorizedCustomerUpdated = newGroup.customers.find(
      (c: any) => c.isGroupAdministrator
    );
    expect(authorizedCustomerUpdated.addresses?.length).toBe(2);
    expect(
      authorizedCustomerUpdated.addresses.find(
        (a: Address) =>
          a.id === addressTobeUpdated.id &&
          a.streetLine2 === 'Melkam Menged' &&
          a.phoneNumber === '+251963215487' &&
          a.fullName === addressTobeUpdated.fullName &&
          a.company === addressTobeUpdated.company &&
          a.streetLine1 === addressTobeUpdated.streetLine1 &&
          a.city === addressTobeUpdated.city &&
          a.province === addressTobeUpdated.province &&
          a.postalCode === addressTobeUpdated.postalCode &&
          a.defaultBillingAddress ===
            addressTobeUpdated.defaultBillingAddress &&
          a.defaultShippingAddress === addressTobeUpdated.defaultShippingAddress
      )
    ).toBeDefined();
  });
  it('Administrators can update custom fields', async () => {
    await authorizeAsGroupAdmin();
    const { myCustomerManagedGroup: group } = await shopClient.query(
      myCustomerManagedGroupQuery
    );
    const groupAdmin = group.customers.find((c: any) => c.isGroupAdministrator);
    const adminBirthDay = new Date().toISOString();
    const { updateCustomerManagedGroupMember: newGroup } =
      await shopClient.query(updateCustomerManagedGroupMemberMutation, {
        input: {
          customerId: groupAdmin.customerId,
          customFields: {
            birthday: adminBirthDay,
          },
        },
      });
    const authorizedCustomerUpdated = newGroup.customers.find(
      (c: any) => c.isGroupAdministrator
    );
    expect(authorizedCustomerUpdated.customFields.birthday).toBe(adminBirthDay);
  });
  it('Admin: creates customer managed group', async () => {
    await adminClient.asSuperAdmin();
    const { createCustomer } = await adminClient.query(addCustomer, {
      input: {
        firstName: 'test',
        lastName: 'last',
        emailAddress: `test${Math.floor(Math.random() * 1000) + 1}@hotmail.com`,
      },
    });
    const { createCustomerManagedGroup: group } = await adminClient.query(
      adminCreateCustomerManagedGroupMutation,
      {
        customerId: createCustomer.id,
      }
    );
    const customer = group.customers.find(
      (c: any) => c.customerId === createCustomer.id
    );
    expect(customer).toBeDefined();
    expect(customer.isGroupAdministrator).toBe(true);
  });
  it('Admin: get customer managed group', async () => {
    await adminClient.asSuperAdmin();
    const { createCustomer } = await adminClient.query(addCustomer, {
      input: {
        firstName: 'test',
        lastName: 'last',
        emailAddress: `test${Math.floor(Math.random() * 1000) + 1}@hotmail.com`,
      },
    });
    const { createCustomerManagedGroup: group } = await adminClient.query(
      adminCreateCustomerManagedGroupMutation,
      {
        customerId: createCustomer.id,
      }
    );
    const { customerGroup } = await adminClient.query(
      adminCustomerManagedGroupQuery,
      {
        id: group.id,
      }
    );
    expect(customerGroup).toMatchObject({
      id: group.id,
    });
  });
  it('Admin: add customer to customer managed group', async () => {
    await adminClient.asSuperAdmin();
    const { createCustomer } = await adminClient.query(addCustomer, {
      input: {
        firstName: 'test',
        lastName: 'last',
        emailAddress: `test${Math.floor(Math.random() * 1000) + 1}@hotmail.com`,
      },
    });
    const { createCustomer: customer2 } = await adminClient.query(addCustomer, {
      input: {
        firstName: 'child',
        lastName: 'last',
        emailAddress: `test${Math.floor(Math.random() * 1000) + 1}@hotmail.com`,
      },
    });
    expect(createCustomer).toMatchObject({
      id: expect.anything(),
    });
    const { createCustomerManagedGroup: group } = await adminClient.query(
      adminCreateCustomerManagedGroupMutation,
      {
        customerId: createCustomer.id,
      }
    );
    const { addCustomersToGroup: updatedGroup } = await adminClient.query(
      adminAddCustomersToGroupMutation,
      {
        customerGroupId: group.id,
        customerIds: [customer2.id],
      }
    );
    expect(updatedGroup.customers.items).toHaveLength(2);
  });
  it('Admin: make customer admin of customer managed group', async () => {
    await adminClient.asSuperAdmin();
    const { createCustomer } = await adminClient.query(addCustomer, {
      input: {
        firstName: 'test',
        lastName: 'last',
        emailAddress: `test${Math.floor(Math.random() * 1000) + 1}@hotmail.com`,
      },
    });
    const { createCustomer: customer2 } = await adminClient.query(addCustomer, {
      input: {
        firstName: 'child',
        lastName: 'last',
        emailAddress: `test${Math.floor(Math.random() * 1000) + 1}@hotmail.com`,
      },
    });
    expect(createCustomer).toMatchObject({
      id: expect.anything(),
    });
    const { createCustomerManagedGroup: group } = await adminClient.query(
      adminCreateCustomerManagedGroupMutation,
      {
        customerId: createCustomer.id,
      }
    );
    await adminClient.query(adminAddCustomersToGroupMutation, {
      customerGroupId: group.id,
      customerIds: [customer2.id],
    });
    const { makeCustomerAdminOfCustomerManagedGroup: updatedGroup } =
      await adminClient.query(adminMakeCustomerAdminOfGroupMutation, {
        groupId: group.id,
        customerId: customer2.id,
      });
    const updatedCustomer = updatedGroup.customers.find(
      (c: any) => c.customerId === customer2.id
    );
    expect(updatedCustomer).toBeDefined();
    expect(updatedCustomer.isGroupAdministrator).toBeTruthy();
  });
  it('Admin: gets orders for customer managed group', async () => {
    await adminClient.asSuperAdmin();
    const customersRes = await adminClient.query(customers, {
      filter: {
        emailAddress: {
          eq: 'hayden.zieme12@hotmail.com',
        },
      },
    });
    const hayden = customersRes.customers.items[0];
    expect(hayden).toBeDefined();
    const group = hayden.groups.find(
      (g: any) => g.customFields.isCustomerManaged
    );
    expect(group).toBeDefined();
    const { ordersForCustomerManagedGroup } = await adminClient.query(
      adminGetOrdersForCustomerManagedGroup,
      {
        customerManagedGroupId: group.id,
      }
    );
    expect(ordersForCustomerManagedGroup.totalItems).toBe(2);
    expect(ordersForCustomerManagedGroup.items[0].code).toBeDefined();
    expect(ordersForCustomerManagedGroup.items[0].lines.length).toBeGreaterThan(
      0
    );
    expect(
      ordersForCustomerManagedGroup.items[0].payments.length
    ).toBeGreaterThan(0);
    expect(ordersForCustomerManagedGroup.items[0].customFields.testing).toBe(
      'just a test'
    );
  });
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-customer-managed-groups/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { AssetServerPlugin } from '@vendure/asset-server-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  MysqlInitializer,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { CustomerManagedGroupsPlugin } from '../src';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AssetServerPlugin.init({
        assetUploadDir: path.join(__dirname, '__data__/assets'),
        route: 'assets',
      }),
      CustomerManagedGroupsPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [],
          devMode: true,
        }),
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    authOptions: {
      tokenMethod: 'bearer',
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 5,
  });
})();
```

## File: packages/vendure-plugin-customer-managed-groups/test/test-helpers.ts

```typescript
import { gql } from 'graphql-tag';
export const addressFragment = gql`
  fragment AddressFragment on CustomerManagedGroupAddress {
    id
    createdAt
    updatedAt
    fullName
    company
    streetLine1
    streetLine2
    city
    province
    postalCode
    country {
      code
    }
    phoneNumber
    defaultShippingAddress
    defaultBillingAddress
  }
`;
export const customerManagedGroupFragment = gql`
  ${addressFragment}
  fragment CustomerManagedGroupFragment on CustomerManagedGroup {
    id
    createdAt
    updatedAt
    name
    customers {
      customerId
      title
      firstName
      lastName
      emailAddress
      customFields
      addresses {
        ...AddressFragment
      }
      isGroupAdministrator
    }
  }
`;
export const adminGetOrdersForCustomerManagedGroup = gql`
  query ordersForCustomerManagedGroup($customerManagedGroupId: ID!) {
    ordersForCustomerManagedGroup(
      customerManagedGroupId: $customerManagedGroupId
    ) {
      items {
        id
        code
        customer {
          emailAddress
        }
        payments {
          id
          transactionId
          state
          errorMessage
        }
        lines {
          id
          unitPriceWithTax
          linePriceWithTax
        }
        customFields {
          testing
        }
      }
      totalItems
    }
  }
`;
export const customers = gql`
  query customers($options: CustomerListOptions) {
    customers(options: $options) {
      items {
        id
        groups {
          id
          customFields {
            groupAdmins {
              id
            }
            isCustomerManaged
          }
        }
      }
    }
  }
`;
export const addCustomer = gql`
  mutation createCustomer($input: CreateCustomerInput!, $password: String) {
    createCustomer(input: $input, password: $password) {
      ... on Customer {
        id
        groups {
          id
          customFields {
            groupAdmins {
              id
            }
            isCustomerManaged
          }
        }
      }
      ... on ErrorResult {
        errorCode
      }
    }
  }
`;
export const adminGetCustomerGroupQuery = gql`
  query customerGroup($id: ID!) {
    customerGroup(id: $id) {
      id
      name
      customers {
        items {
          id
        }
      }
      customFields {
        groupAdmins {
          id
        }
        isCustomerManaged
      }
    }
  }
`;
export const adminCreateCustomerManagedGroupMutation = gql`
  ${customerManagedGroupFragment}
  mutation createCustomerManagedGroup($customerId: ID!) {
    createCustomerManagedGroup(customerId: $customerId) {
      ...CustomerManagedGroupFragment
    }
  }
`;
export const adminAddCustomersToGroupMutation = gql`
  mutation AddCustomersToGroup($customerGroupId: ID!, $customerIds: [ID!]!) {
    addCustomersToGroup(
      customerGroupId: $customerGroupId
      customerIds: $customerIds
    ) {
      id
      name
      customers {
        items {
          id
        }
      }
      customFields {
        groupAdmins {
          id
        }
        isCustomerManaged
      }
    }
  }
`;
export const adminMakeCustomerAdminOfGroupMutation = gql`
  ${customerManagedGroupFragment}
  mutation makeCustomerAdminOfCustomerManagedGroup(
    $groupId: ID!
    $customerId: ID!
  ) {
    makeCustomerAdminOfCustomerManagedGroup(
      groupId: $groupId
      customerId: $customerId
    ) {
      ...CustomerManagedGroupFragment
    }
  }
`;
export const myCustomerManagedGroupQuery = gql`
  ${customerManagedGroupFragment}
  query myCustomerManagedGroup {
    myCustomerManagedGroup {
      ...CustomerManagedGroupFragment
    }
  }
`;
export const adminCustomerManagedGroupQuery = gql`
  query customerGroup($id: ID!) {
    customerGroup(id: $id) {
      id
      name
      customFields {
        groupAdmins {
          id
        }
        isCustomerManaged
      }
    }
  }
`;
export const activeCustomerManagedGroupMemberQuery = gql`
  query activeCustomerManagedGroupMember {
    activeCustomerManagedGroupMember {
      customerId
      title
      firstName
      lastName
      emailAddress
      isGroupAdministrator
    }
  }
`;
export const removeCustomerFromGroupMutation = gql`
  ${customerManagedGroupFragment}
  mutation RemoveCustomerFromGroup($customerId: ID!) {
    removeCustomerFromMyCustomerManagedGroup(customerId: $customerId) {
      ...CustomerManagedGroupFragment
    }
  }
`;
export const createCustomerManagedGroupMutation = gql`
  ${customerManagedGroupFragment}
  mutation createCustomerManagedGroup {
    createCustomerManagedGroup {
      ...CustomerManagedGroupFragment
    }
  }
`;
export const addCustomerToMyCustomerManagedGroupMutation = gql`
  mutation addCustomerToMyCustomerManagedGroup(
    $input: AddCustomerToMyCustomerManagedGroupInput!
  ) {
    addCustomerToMyCustomerManagedGroup(input: $input) {
      id
      name
      customers {
        customerId
        emailAddress
        isGroupAdministrator
      }
    }
  }
`;
export const getOrdersForMyCustomerManagedGroup = gql`
  query {
    ordersForMyCustomerManagedGroup {
      items {
        id
        code
        customer {
          emailAddress
        }
        payments {
          id
          transactionId
          state
          errorMessage
        }
        lines {
          id
          unitPriceWithTax
          linePriceWithTax
        }
        customFields {
          testing
        }
      }
      totalItems
    }
  }
`;
export const updateCustomerManagedGroupMemberMutation = gql`
  ${customerManagedGroupFragment}
  mutation updateCustomerManagedGroupMember(
    $input: UpdateCustomerManagedGroupMemberInput!
  ) {
    updateCustomerManagedGroupMember(input: $input) {
      ...CustomerManagedGroupFragment
    }
  }
`;
export const makeCustomerAdminOfCustomerManagedGroupMutation = gql`
  ${customerManagedGroupFragment}
  mutation makeCustomerAdminOfCustomerManagedGroup(
    $groupId: ID!
    $customerId: ID!
  ) {
    makeCustomerAdminOfCustomerManagedGroup(
      groupId: $groupId
      customerId: $customerId
    ) {
      ...CustomerManagedGroupFragment
    }
  }
`;
```

## File: packages/vendure-plugin-customer-managed-groups/vitest.config.ts

```typescript
import path from 'path';
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    include: ['./test/customer-managed-groups.spec.ts'],
    typecheck: {
      tsconfig: path.join(__dirname, './test/tsconfig.e2e.json'),
    },
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-drop-off-points/src/api/api-extensions.ts

```typescript
import gql from 'graphql-tag';
const _scalar = gql`
  scalar Order
  scalar JSON
`;
export const shopApiExtensions = gql`
  input ParcelDropOffPointSearchInput {
    """
    Specify the carrier to search for. E.g. PostNL, DHL etc
    """
    carrier: String!
    postalCode: String!
    houseNumber: String
  }
  type ParcelDropOffPoint {
    token: String!
    """
    The carrier assigned ID of the drop off point
    """
    dropOffPointId: String!
    name: String!
    streetLine1: String!
    streetLine2: String
    postalCode: String!
    houseNumber: String!
    houseNumberSuffix: String
    city: String!
    country: String!
    latitude: Float
    longitude: Float
    distanceInKm: Float
    cutOffTime: String
    additionalData: JSON
  }
  extend type Query {
    parcelDropOffPoints(
      input: ParcelDropOffPointSearchInput!
    ): [ParcelDropOffPoint!]!
  }
  extend type Mutation {
    setParcelDropOffPoint(token: String!): Order!
    unsetParcelDropOffPoint: Order!
  }
`;
```

## File: packages/vendure-plugin-drop-off-points/src/api/drop-off-points-shop.resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { Ctx, Order, RequestContext } from '@vendure/core';
import { DropOffPointsService } from '../services/drop-off-points.service';
import {
  MutationSetParcelDropOffPointArgs,
  ParcelDropOffPoint,
  QueryParcelDropOffPointsArgs,
} from '../types-generated-graphql';
@Resolver()
export class DropOffPointsShopResolver {
  constructor(private dropOffPointsService: DropOffPointsService) {}
  @Query()
  async parcelDropOffPoints(
    @Ctx() ctx: RequestContext,
    @Args() args: QueryParcelDropOffPointsArgs
  ): Promise<ParcelDropOffPoint[]> {
    return await this.dropOffPointsService.getDropOffPoints(ctx, args.input);
  }
  @Mutation()
  async setParcelDropOffPoint(
    @Ctx() ctx: RequestContext,
    @Args() { token }: MutationSetParcelDropOffPointArgs
  ): Promise<Order> {
    return await this.dropOffPointsService.setDropOffPointOnOrder(ctx, token);
  }
  @Mutation()
  async unsetParcelDropOffPoint(@Ctx() ctx: RequestContext): Promise<Order> {
    return await this.dropOffPointsService.unsetDropOffPoint(ctx);
  }
}
```

## File: packages/vendure-plugin-drop-off-points/src/carriers/dhl-carrier.ts

```typescript
import { RequestContext } from '@vendure/core';
import { DropOffPoint, DropOffPointCarrier } from '../types';
import { ParcelDropOffPointSearchInput } from '../types-generated-graphql';
export class DHLCarrier implements DropOffPointCarrier {
  readonly name = 'DHL';
  constructor(private readonly countryCode = 'NL') {}
  async getDropOffPoints(
    ctx: RequestContext,
    input: ParcelDropOffPointSearchInput
  ): Promise<DropOffPoint[]> {
    let url = `https://api-gw.dhlparcel.nl/parcel-shop-locations/${
      this.countryCode
    }?limit=10&postalCode=${encodeURIComponent(
      input.postalCode
    )}&showUnavailable=false`;
    if (input.houseNumber) {
      url += `&houseNumber=${input.houseNumber}`;
    }
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch DHL drop-off points: [${response.status}] ${response.statusText}`
      );
    }
    const points: DHLDropOffPoint[] = (await response.json()) as any;
    return points.map((point) => ({
      dropOffPointId: point.id,
      name: point.name,
      houseNumber: point.address.number,
      houseNumberSuffix: point.address.addition,
      streetLine1: point.address.street,
      streetLine2: undefined,
      postalCode: point.address.postalCode,
      city: point.address.city,
      country: point.address.countryCode,
      cutOffTime: point.collectionSchedule.time,
      latitude: point.geoLocation.latitude,
      longitude: point.geoLocation.longitude,
      distanceInKm: point.distance,
    }));
  }
}
interface DHLDropOffPoint {
  id: string;
  harmonisedId: string;
  psfKey: string;
  shopType: string;
  name: string;
  keyword: string;
  address: Address;
  geoLocation: GeoLocation;
  distance: number;
  openingTimes: OpeningTime[];
  collectionSchedule: CollectionSchedule;
  serviceTypes: string[];
  depotCode: string;
  allowNrParcels: string;
  servicepointFormat: string;
}
interface Address {
  countryCode: string;
  zipCode: string;
  city: string;
  street: string;
  number: string;
  addition?: string;
  isBusiness: boolean;
  postalCode: string;
}
interface GeoLocation {
  latitude: number;
  longitude: number;
}
interface OpeningTime {
  timeFrom: string;
  timeTo: string;
  weekDay: number;
}
interface CollectionSchedule {
  frequency: string;
  time: string;
}
```

## File: packages/vendure-plugin-drop-off-points/src/services/drop-off-points.service.ts

```typescript
import { Inject, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  ActiveOrderService,
  assertFound,
  Injector,
  Order,
  OrderService,
  RequestContext,
  UserInputError,
} from '@vendure/core';
import { DROP_OFF_POINTS_PLUGIN_OPTIONS } from '../constants';
import { PluginInitOptions, SavedDropOffPoint } from '../types';
import { asError } from 'catch-unknown';
import {
  ParcelDropOffPoint,
  ParcelDropOffPointSearchInput,
} from '../types-generated-graphql';
@Injectable()
export class DropOffPointsService {
  private readonly injector: Injector;
  constructor(
    @Inject(DROP_OFF_POINTS_PLUGIN_OPTIONS)
    private readonly options: PluginInitOptions,
    private readonly moduleRef: ModuleRef,
    private readonly activeOrderService: ActiveOrderService,
    private readonly orderService: OrderService
  ) {
    this.injector = new Injector(this.moduleRef);
  }
  async getDropOffPoints(
    ctx: RequestContext,
    input: ParcelDropOffPointSearchInput
  ): Promise<ParcelDropOffPoint[]> {
    const carrier = this.options.carriers.find((c) => c.name === input.carrier);
    if (!carrier) {
      throw new UserInputError(`Carrier '${input.carrier}' not found`);
    }
    const dropOffPoints = await carrier.getDropOffPoints(ctx, input);
    return dropOffPoints.map((point) => {
      const savedPoint: SavedDropOffPoint = {
        carrier: input.carrier,
        id: point.dropOffPointId,
        name: point.name,
        houseNumber: point.houseNumber,
        houseNumberSuffix: point.houseNumberSuffix ?? undefined,
        streetLine1: point.streetLine1,
        streetLine2: point.streetLine2 ?? undefined,
        postalCode: point.postalCode,
        city: point.city,
        country: point.country,
        additionalData: point.additionalData,
      };
      const token = Buffer.from(JSON.stringify(savedPoint)).toString('base64');
      return {
        ...point,
        token,
      };
    });
  }
  async setDropOffPointOnOrder(
    ctx: RequestContext,
    token: string
  ): Promise<Order> {
    const point = this.getSavedPointFromToken(token);
    const activeOrder = await this.activeOrderService.getActiveOrder(
      ctx,
      undefined,
      true
    );
    if (this.options.customMutations?.setDropOffPointOnOrder) {
      const updatedOrder =
        await this.options.customMutations.setDropOffPointOnOrder(
          ctx,
          activeOrder,
          point
        );
      await this.orderService.updateCustomFields(ctx, activeOrder.id, {
        ...updatedOrder.customFields,
      });
    } else {
      await this.orderService.updateCustomFields(ctx, activeOrder.id, {
        dropOffPointCarrier: point.carrier,
        dropOffPointId: point.id,
        dropOffPointName: point.name,
        dropOffPointStreetLine1: point.streetLine1,
        dropOffPointStreetLine2: point.streetLine2,
        dropOffPointHouseNumber: point.houseNumber,
        dropOffPointHouseNumberSuffix: point.houseNumberSuffix,
        dropOffPointPostalCode: point.postalCode,
        dropOffPointCity: point.city,
        dropOffPointCountry: point.country,
      });
    }
    return await assertFound(this.orderService.findOne(ctx, activeOrder.id));
  }
  async unsetDropOffPoint(ctx: RequestContext): Promise<Order> {
    const activeOrder = await this.activeOrderService.getActiveOrder(
      ctx,
      undefined,
      true
    );
    if (this.options.customMutations?.unsetDropOffPoint) {
      const updatedOrder = await this.options.customMutations.unsetDropOffPoint(
        ctx,
        activeOrder
      );
      await this.orderService.updateCustomFields(ctx, activeOrder.id, {
        ...updatedOrder.customFields,
      });
    } else {
      await this.orderService.updateCustomFields(ctx, activeOrder.id, {
        dropOffPointCarrier: null,
        dropOffPointId: null,
        dropOffPointName: null,
        dropOffPointStreetLine1: null,
        dropOffPointStreetLine2: null,
        dropOffPointHouseNumber: null,
        dropOffPointHouseNumberSuffix: null,
        dropOffPointPostalCode: null,
        dropOffPointCity: null,
        dropOffPointCountry: null,
      });
    }
    return await assertFound(this.orderService.findOne(ctx, activeOrder.id));
  }
  private getSavedPointFromToken(token: string): SavedDropOffPoint {
    try {
      const point: SavedDropOffPoint = JSON.parse(
        Buffer.from(token, 'base64').toString()
      );
      if (
        !point.id ||
        !point.name ||
        !point.postalCode ||
        !point.city ||
        !point.country
      ) {
        throw new Error('Invalid drop off point data in encoded token');
      }
      return point;
    } catch (e) {
      throw new UserInputError(
        `Invalid drop off point token: ${asError(e).message}`
      );
    }
  }
}
```

## File: packages/vendure-plugin-drop-off-points/src/constants.ts

```typescript
export const DROP_OFF_POINTS_PLUGIN_OPTIONS = Symbol(
  'DROP_OFF_POINTS_PLUGIN_OPTIONS'
);
export const loggerCtx = 'DropOffPointsPlugin';
```

## File: packages/vendure-plugin-drop-off-points/src/custom-fields.ts

```typescript
import { CustomFieldConfig, LanguageCode } from '@vendure/core';
const uiTab = 'Drop Off Point';
export const customOrderFields: CustomFieldConfig[] = [
  {
    name: 'dropOffPointCarrier',
    type: 'string',
    label: [{ value: 'Carrier', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointId',
    type: 'string',
    label: [{ value: 'Drop Off Point Id', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointName',
    type: 'string',
    label: [{ value: 'Name', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointStreetLine1',
    type: 'string',
    label: [{ value: 'Street Line 1', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointStreetLine2',
    type: 'string',
    label: [{ value: 'Street Line 2', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointHouseNumber',
    type: 'string',
    label: [{ value: 'House Number', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointHouseNumberSuffix',
    type: 'string',
    label: [
      {
        value: 'House Number Suffix',
        languageCode: LanguageCode.en,
      },
    ],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointPostalCode',
    type: 'string',
    label: [{ value: 'Postal Code', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointCity',
    type: 'string',
    label: [{ value: 'City', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
  {
    name: 'dropOffPointCountry',
    type: 'string',
    label: [{ value: 'Country', languageCode: LanguageCode.en }],
    ui: { tab: uiTab },
  },
];
```

## File: packages/vendure-plugin-drop-off-points/src/drop-off-points.plugin.ts

```typescript
import { PluginCommonModule, Type, VendurePlugin } from '@vendure/core';
import { DROP_OFF_POINTS_PLUGIN_OPTIONS, loggerCtx } from './constants';
import { PluginInitOptions } from './types';
import { DropOffPointsService } from './services/drop-off-points.service';
import { shopApiExtensions } from './api/api-extensions';
import { DropOffPointsShopResolver } from './api/drop-off-points-shop.resolver';
import { customOrderFields } from './custom-fields';
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    {
      provide: DROP_OFF_POINTS_PLUGIN_OPTIONS,
      useFactory: () => DropOffPointsPlugin.options,
    },
    DropOffPointsService,
  ],
  configuration: (config) => {
    if (!DropOffPointsPlugin.options.customMutations) {
      config.customFields.Order.push(...customOrderFields);
    }
    return config;
  },
  compatibility: '>=2.2.0',
  shopApiExtensions: {
    schema: shopApiExtensions,
    resolvers: [DropOffPointsShopResolver],
  },
})
export class DropOffPointsPlugin {
  static options: PluginInitOptions;
  static init(options: PluginInitOptions): Type<DropOffPointsPlugin> {
    const carrierNames = options.carriers.map((p) => p.name);
    const duplicateCarrierNames = carrierNames.filter(
      (name, index) => carrierNames.indexOf(name) !== index
    );
    if (duplicateCarrierNames.length) {
      throw new Error(
        `[${loggerCtx}] Carrier name should be unique, but found the following names more than once: ${duplicateCarrierNames.join(
          ','
        )}`
      );
    }
    this.options = options;
    return DropOffPointsPlugin;
  }
}
```

## File: packages/vendure-plugin-drop-off-points/src/index.ts

```typescript
export * from './drop-off-points.plugin';
export * from './types';
export * from './types-generated-graphql';
export * from './carriers/dhl-carrier';
```

## File: packages/vendure-plugin-drop-off-points/src/types-generated-graphql.ts

```typescript
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  JSON: any;
  Order: any;
};
export type Mutation = {
  __typename?: 'Mutation';
  setParcelDropOffPoint: Scalars['Order'];
  unsetParcelDropOffPoint: Scalars['Order'];
};
export type MutationSetParcelDropOffPointArgs = {
  token: Scalars['String'];
};
export type ParcelDropOffPoint = {
  __typename?: 'ParcelDropOffPoint';
  additionalData?: Maybe<Scalars['JSON']>;
  city: Scalars['String'];
  country: Scalars['String'];
  cutOffTime?: Maybe<Scalars['String']>;
  distanceInKm?: Maybe<Scalars['Float']>;
  dropOffPointId: Scalars['String'];
  houseNumber: Scalars['String'];
  houseNumberSuffix?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  name: Scalars['String'];
  postalCode: Scalars['String'];
  streetLine1: Scalars['String'];
  streetLine2?: Maybe<Scalars['String']>;
  token: Scalars['String'];
};
export type ParcelDropOffPointSearchInput = {
  carrier: Scalars['String'];
  houseNumber?: InputMaybe<Scalars['String']>;
  postalCode: Scalars['String'];
};
export type Query = {
  __typename?: 'Query';
  parcelDropOffPoints: Array<ParcelDropOffPoint>;
};
export type QueryParcelDropOffPointsArgs = {
  input: ParcelDropOffPointSearchInput;
};
```

## File: packages/vendure-plugin-drop-off-points/src/types.ts

```typescript
import { Order, RequestContext } from '@vendure/core';
import {
  ParcelDropOffPoint,
  ParcelDropOffPointSearchInput,
} from './types-generated-graphql';
import { CustomOrderFields } from '@vendure/core/dist/entity/custom-entity-fields';
export interface PluginInitOptions {
  carriers: DropOffPointCarrier[];
  customMutations?: {
    setDropOffPointOnOrder?: (
      ctx: RequestContext,
      activeOrder: Order,
      dropOffPoint: SavedDropOffPoint
    ) => Promise<Order> | Order;
    unsetDropOffPoint?: (
      ctx: RequestContext,
      activeOrder: Order
    ) => Promise<Order> | Order;
  };
}
export type DropOffPoint = Omit<ParcelDropOffPoint, 'token'>;
export interface DropOffPointCarrier {
  name: string;
  getDropOffPoints: (
    ctx: RequestContext,
    input: ParcelDropOffPointSearchInput
  ) => Promise<DropOffPoint[]>;
}
export interface SavedDropOffPoint {
  carrier: string;
  id: string;
  name: string;
  streetLine1: string;
  streetLine2?: string;
  houseNumber: string;
  houseNumberSuffix?: string;
  postalCode: string;
  city: string;
  country: string;
  additionalData?: unknown;
}
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomOrderFields {
    dropOffPointCarrier?: string;
    dropOffPointId?: string;
    dropOffPointName?: string;
    dropOffPointStreetLine1?: string;
    dropOffPointStreetLine2?: string;
    dropOffPointHouseNumber: string;
    dropOffPointHouseNumberSuffix: string;
    dropOffPointPostalCode: string;
    dropOffPointCity: string;
  }
}
```

## File: packages/vendure-plugin-drop-off-points/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { DropOffPointsPlugin } from '../src';
import { DHLCarrier } from '../src/carriers/dhl-carrier';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    plugins: [
      DropOffPointsPlugin.init({
        carriers: [new DHLCarrier()],
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-drop-off-points/test/e2e.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import { gql } from 'graphql-tag';
import { afterAll, beforeAll, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import {
  DropOffPointsPlugin,
  Mutation,
  MutationSetParcelDropOffPointArgs,
  QueryParcelDropOffPointsArgs,
} from '../src';
import { MockCarrier } from './mock-carrier';
import { addItem } from '../../test/src/shop-utils';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: console,
    plugins: [
      DropOffPointsPlugin.init({
        carriers: [new MockCarrier()],
      }),
    ],
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
}, 30000);
afterAll(async () => {
  await server.destroy();
}, 100000);
it('Started the server', () => {
  expect(server.app.getHttpServer()).toBeDefined();
});
let dropOffPointToken: string;
it('Fetches drop off points', async () => {
  const { parcelDropOffPoints } = await shopClient.query<
    any,
    QueryParcelDropOffPointsArgs
  >(getDropOffPointsQuery, {
    input: {
      carrier: 'mock',
      postalCode: '1234AB',
      houseNumber: '1',
    },
  });
  dropOffPointToken = parcelDropOffPoints[0].token;
  expect(parcelDropOffPoints[0].token).toBeDefined();
  expect(parcelDropOffPoints[0].name).toBe('mock drop off point 𝓧');
  expect(parcelDropOffPoints[0].postalCode).toBe('1234AB');
  expect(parcelDropOffPoints[0].houseNumber).toBe('1');
});
it('Set drop off point on order', async () => {
  await addItem(shopClient, '1', 1);
  const { setParcelDropOffPoint: order } = await shopClient.query<
    any,
    MutationSetParcelDropOffPointArgs
  >(setDropOffPointMutation, {
    token: dropOffPointToken,
  });
  expect(order.customFields.dropOffPointCarrier).toBe('mock');
  expect(order.customFields.dropOffPointName).toBe('mock drop off point 𝓧');
  expect(order.customFields.dropOffPointStreetLine1).toBe('mock street');
  expect(order.customFields.dropOffPointStreetLine2).toBe('mock street 2');
  expect(order.customFields.dropOffPointPostalCode).toBe('1234AB');
  expect(order.customFields.dropOffPointHouseNumber).toBe('1');
  expect(order.customFields.dropOffPointCity).toBe('mock city');
  expect(order.customFields.dropOffPointCountry).toBe('NL');
});
it('Unset drop off point', async () => {
  const { unsetParcelDropOffPoint: order } = await shopClient.query(
    unsetDropOffPointMutation
  );
  expect(order.customFields.dropOffPointCarrier).toBeNull();
  expect(order.customFields.dropOffPointName).toBeNull();
  expect(order.customFields.dropOffPointStreetLine1).toBeNull();
  expect(order.customFields.dropOffPointStreetLine2).toBeNull();
  expect(order.customFields.dropOffPointPostalCode).toBeNull();
  expect(order.customFields.dropOffPointHouseNumber).toBeNull();
  expect(order.customFields.dropOffPointCity).toBeNull();
  expect(order.customFields.dropOffPointCountry).toBeNull();
});
const getDropOffPointsQuery = gql`
  query parcelDropOffPoints($input: ParcelDropOffPointSearchInput!) {
    parcelDropOffPoints(input: $input) {
      token
      dropOffPointId
      name
      streetLine1
      streetLine2
      postalCode
      houseNumber
      houseNumberSuffix
      city
      country
      latitude
      longitude
      distanceInKm
      cutOffTime
      additionalData
    }
  }
`;
const setDropOffPointMutation = gql`
  mutation setParcelDropOffPoint($token: String!) {
    setParcelDropOffPoint(token: $token) {
      id
      code
      customFields {
        dropOffPointCarrier
        dropOffPointId
        dropOffPointName
        dropOffPointStreetLine1
        dropOffPointStreetLine2
        dropOffPointHouseNumber
        dropOffPointHouseNumberSuffix
        dropOffPointPostalCode
        dropOffPointCity
        dropOffPointCountry
      }
    }
  }
`;
const unsetDropOffPointMutation = gql`
  mutation unsetParcelDropOffPoint {
    unsetParcelDropOffPoint {
      id
      code
      customFields {
        dropOffPointCarrier
        dropOffPointId
        dropOffPointName
        dropOffPointStreetLine1
        dropOffPointStreetLine2
        dropOffPointHouseNumber
        dropOffPointHouseNumberSuffix
        dropOffPointPostalCode
        dropOffPointCity
        dropOffPointCountry
      }
    }
  }
`;
```

## File: packages/vendure-plugin-drop-off-points/test/mock-carrier.ts

```typescript
import { RequestContext } from '@vendure/core';
import {
  DropOffPoint,
  DropOffPointCarrier,
  ParcelDropOffPointSearchInput,
} from '../src';
export class MockCarrier implements DropOffPointCarrier {
  name = 'mock';
  async getDropOffPoints(
    ctx: RequestContext,
    input: ParcelDropOffPointSearchInput
  ): Promise<DropOffPoint[]> {
    return [
      {
        dropOffPointId: 'mock-id',
        name: 'mock drop off point 𝓧',
        houseNumber: input.houseNumber ?? 'mock nr',
        streetLine1: 'mock street',
        streetLine2: 'mock street 2',
        postalCode: input.postalCode,
        city: 'mock city',
        country: 'NL',
      },
    ];
  }
}
```

## File: packages/vendure-plugin-dutch-postalcode/src/dutch-postal-code.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { PostalCodeResolver } from './postal-code.resolver';
@VendurePlugin({
  imports: [PluginCommonModule],
  shopApiExtensions: {
    schema: PostalCodeResolver.schema,
    resolvers: [PostalCodeResolver],
  },
  compatibility: '>=2.2.0',
})
export class DutchPostalCodePlugin {
  static apiKey: string;
  static init(apiKey: string): typeof DutchPostalCodePlugin {
    this.apiKey = apiKey;
    return DutchPostalCodePlugin;
  }
}
```

## File: packages/vendure-plugin-dutch-postalcode/src/postal-code.resolver.ts

```typescript
import { Args, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Permission,
  RequestContext,
  UnauthorizedError,
} from '@vendure/core';
import gql from 'graphql-tag';
import { DutchPostalCodePlugin } from './dutch-postal-code.plugin';
import fetch from 'node-fetch';
interface DutchAddressLookupResult {
  postalCode: string;
  houseNumber: string;
  street: string;
  city: string;
  municipality?: string;
  province?: string;
  lat?: number;
  lon?: number;
}
@Resolver()
export class PostalCodeResolver {
  static schema = gql`
    extend type Query {
      dutchAddressLookup(input: DutchPostalCodeInput!): DutchAddressLookupResult
    }
    input DutchPostalCodeInput {
      postalCode: String!
      houseNumber: String!
    }
    type DutchAddressLookupResult {
      postalCode: String!
      houseNumber: String!
      street: String!
      city: String!
      municipality: String
      province: String
      lat: Float
      lon: Float
    }
  `;
  headers = {};
  constructor() {
    if (!DutchPostalCodePlugin.apiKey) {
      throw Error(
        `DutchPostalCodePlugin needs an apiKey. Use DutchPostalCodePlugin.init('yourkey') to set an apiKey`
      );
    }
    this.headers = {
      Authorization: `Bearer ${DutchPostalCodePlugin.apiKey}`,
    };
  }
  @Query()
  @Allow(Permission.Public)
  async dutchAddressLookup(
    @Ctx() ctx: RequestContext,
    @Args('input') input: { postalCode: string; houseNumber: string }
  ): Promise<DutchAddressLookupResult | undefined> {
    if (!ctx.channelId || !ctx.session?.token) {
      throw new UnauthorizedError();
    }
    const { postalCode, houseNumber } = input;
    const result = await fetch(
      `https://postcode.tech/api/v1/postcode/full?postcode=${postalCode}&number=${houseNumber}`,
      { headers: this.headers }
    );
    const jsonResult = await result.json();
    if (!jsonResult.street) {
      return undefined;
    }
    return {
      postalCode: jsonResult.postcode,
      houseNumber: jsonResult.number,
      street: jsonResult.street,
      city: jsonResult.city,
      municipality: jsonResult.municipality,
      province: jsonResult.province,
      lat: jsonResult.geo?.lat,
      lon: jsonResult.geo?.lon,
    };
  }
}
```

## File: packages/vendure-plugin-dutch-postalcode/test/dev-server.ts

```typescript
require('dotenv').config();
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { DutchPostalCodePlugin } from '../src/dutch-postal-code.plugin';
(async () => {
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      DutchPostalCodePlugin.init(process.env.APIKEY as string),
      DefaultSearchPlugin,
    ],
    apiOptions: {
      shopApiPlayground: {},
    },
  });
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const { server } = createTestEnvironment(config);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-dutch-postalcode/test/e2e.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import {
  DefaultLogger,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { TestServer } from '@vendure/testing/lib/test-server';
import { DutchPostalCodePlugin } from '../src/dutch-postal-code.plugin';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
describe('Dutch PostalCode plugin', () => {
  let testServer: TestServer;
  it('Server should start', async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3101,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [DutchPostalCodePlugin.init('your-apikey')],
    });
    const { server } = createTestEnvironment(config);
    testServer = server;
    const serverStart = server.init({
      initialData: initialData as InitialData,
      productsCsvPath: '../test/src/products-import.csv',
    });
    await expect(serverStart).resolves.toEqual(undefined);
  }, 60000);
  afterAll(() => {
    return testServer.destroy();
  });
});
```

## File: packages/vendure-plugin-dutch-postalcode/vitest.config.ts

```typescript
import path from 'path';
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    include: ['./test/e2e.spec.ts'],
    testTimeout: 10000,
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-e-boekhouden/src/api/e-boekhouden-config.entity.ts

```typescript
import { Column, Entity } from 'typeorm';
import { DeepPartial, VendureEntity } from '@vendure/core';
@Entity('e_boekhouden_config')
export class EBoekhoudenConfigEntity extends VendureEntity {
  constructor(input?: DeepPartial<EBoekhoudenConfigEntity>) {
    super(input);
  }
  @Column({ unique: true })
  channelToken!: string;
  @Column({ nullable: false })
  enabled!: boolean;
  @Column({ nullable: false })
  username!: string;
  @Column({ nullable: false })
  secret1!: string;
  @Column({ nullable: false })
  secret2!: string;
  @Column({ nullable: false })
  account!: string;
  @Column({ nullable: false })
  contraAccount!: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/api/e-boekhouden.adapter.ts

```typescript
import { CMutatieRegel, OMut } from '../client';
import { Logger, Order } from '@vendure/core';
import { EBoekhoudenConfigEntity } from './e-boekhouden-config.entity';
import { loggerCtx } from '../constants';
import { OrderTaxSummary } from '@vendure/common/lib/generated-types';
const toPrice = (price: number) => (Math.round(price) / 100).toFixed(2);
export const recalculateTaxFromTotalIncVAT = (summary: OrderTaxSummary) => {
  const taxMultiplier = summary.taxRate / 100 + 1;
  const totalIncVAT = summary.taxBase + summary.taxTotal;
  const totalExVAT = totalIncVAT / taxMultiplier;
  const totalTax = totalIncVAT - totalExVAT;
  return {
    totalIncVAT,
    totalExVAT,
    totalTax,
  };
};
export class EBoekhoudenAdapter {
  static toMutation(order: Order, config: EBoekhoudenConfigEntity): OMut {
    const description = `Order ${order.code} - ${order.customer?.firstName} ${order.customer?.lastName} (${order.customer?.emailAddress})`;
    const cMutatieRegel = order.taxSummary.map((summary) =>
      this.toMutationLine(summary, config)
    );
    return {
      Soort: 'GeldOntvangen',
      Datum: this.toDateString(order.orderPlacedAt || order.updatedAt),
      Rekening: config.account,
      Omschrijving: description,
      InExBTW: 'IN',
      MutatieRegels: {
        cMutatieRegel,
      },
    };
  }
  static toMutationLine(
    tax: OrderTaxSummary,
    config: EBoekhoudenConfigEntity
  ): CMutatieRegel {
    const recalculatedTax = recalculateTaxFromTotalIncVAT(tax);
    return {
      BedragExclBTW: toPrice(recalculatedTax.totalExVAT),
      BedragInclBTW: toPrice(recalculatedTax.totalIncVAT),
      BedragBTW: toPrice(recalculatedTax.totalTax),
      BTWPercentage: String(tax.taxRate),
      TegenrekeningCode: config.contraAccount,
      BTWCode: this.getTax(tax.taxRate, tax.description),
      BedragInvoer: toPrice(recalculatedTax.totalIncVAT),
    };
  }
  static getTax(
    value: number,
    reference: string
  ): 'LAAG_VERK_9' | 'HOOG_VERK_21' | 'AFW' | 'GEEN' {
    if (value === 9) {
      return 'LAAG_VERK_9';
    } else if (value === 21) {
      return 'HOOG_VERK_21';
    } else if (value === 0) {
      return 'GEEN';
    } else {
      Logger.error(
        `Unknown taxValue ${value} for ${reference}. Used 21 as default`,
        loggerCtx
      );
      return 'HOOG_VERK_21';
    }
  }
  static toDateString(date: Date): string {
    const dateString = date.toISOString();
    return dateString.substr(0, 10);
  }
}
```

## File: packages/vendure-plugin-e-boekhouden/src/api/e-boekhouden.resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { Allow, Ctx, RequestContext } from '@vendure/core';
import { EBoekhoudenService } from './e-boekhouden.service';
import { PermissionDefinition } from '@vendure/core';
import {
  EBoekhoudenConfig,
  EBoekhoudenConfigInput,
} from '../ui/generated/graphql';
export const eBoekhoudenPermission = new PermissionDefinition({
  name: 'eBoekhouden',
  description: 'Allows enabling e-Boekhouden plugin',
});
@Resolver()
export class EBoekhoudenResolver {
  constructor(private service: EBoekhoudenService) {}
  @Query()
  @Allow(eBoekhoudenPermission.Permission)
  async eBoekhoudenConfig(
    @Ctx() ctx: RequestContext
  ): Promise<EBoekhoudenConfig | null> {
    return this.service.getConfig(ctx.channel.token);
  }
  @Mutation()
  @Allow(eBoekhoudenPermission.Permission)
  async updateEBoekhoudenConfig(
    @Ctx() ctx: RequestContext,
    @Args('input') input: EBoekhoudenConfigInput
  ): Promise<EBoekhoudenConfig | null> {
    return this.service.upsertConfig(ctx.channel.token, input);
  }
}
```

## File: packages/vendure-plugin-e-boekhouden/src/api/e-boekhouden.service.ts

```typescript
import {
  ChannelService,
  EventBus,
  JobQueue,
  JobQueueService,
  Logger,
  OrderPlacedEvent,
  OrderService,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import {
  Injectable,
  OnApplicationBootstrap,
  OnModuleInit,
} from '@nestjs/common';
import { EBoekhoudenConfigEntity } from './e-boekhouden-config.entity';
import { EBoekhoudenConfigInput } from '../ui/generated/graphql';
import { createClientAsync, EBoekhoudenWsdlClient, ErrorMsg } from '../client';
import { loggerCtx } from '../constants';
import { EBoekhoudenAdapter } from './e-boekhouden.adapter';
interface JobData {
  channelToken: string;
  orderCode: string;
}
@Injectable()
export class EBoekhoudenService
  implements OnApplicationBootstrap, OnModuleInit
{
  client!: EBoekhoudenWsdlClient;
  jobQueue!: JobQueue<JobData>;
  constructor(
    private connection: TransactionalConnection,
    private orderService: OrderService,
    private channelService: ChannelService,
    private eventBus: EventBus,
    private jobQueueService: JobQueueService
  ) {}
  async onModuleInit(): Promise<void> {
    const url = 'https://soap.e-boekhouden.nl/soap.asmx?wsdl';
    const options = {
      envelopeKey: 'soap',
      wsdl_options: {
        xmlKey: '$xml',
        overrideRootElement: {
          namespace: 'xmlns:soap',
        },
      },
    };
    this.client = await createClientAsync(url, options);
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'push-orders-to-e-boekhouden',
      process: async (job) => await this.pushOrder(job.data),
    });
  }
  async onApplicationBootstrap(): Promise<void> {
    this.eventBus.ofType(OrderPlacedEvent).subscribe(
      async (event) =>
        await this.jobQueue.add({
          channelToken: event.ctx.channel.token,
          orderCode: event.order.code,
        })
    );
  }
  async upsertConfig(
    channelToken: string,
    input: EBoekhoudenConfigInput
  ): Promise<EBoekhoudenConfigEntity> {
    const existing = await this.connection
      .getRepository(EBoekhoudenConfigEntity)
      .findOne({ where: { channelToken } });
    if (existing) {
      await this.connection
        .getRepository(EBoekhoudenConfigEntity)
        .update(existing.id, input);
    } else {
      await this.connection
        .getRepository(EBoekhoudenConfigEntity)
        .insert({ ...input, channelToken });
    }
    return this.connection
      .getRepository(EBoekhoudenConfigEntity)
      .findOneOrFail({ where: { channelToken } });
  }
  async getConfig(
    channelToken: string
  ): Promise<EBoekhoudenConfigEntity | null> {
    return this.connection
      .getRepository(EBoekhoudenConfigEntity)
      .findOne({ where: { channelToken }, cache: 60000 });
  }
  async getConfigs(): Promise<EBoekhoudenConfigEntity[]> {
    return this.connection
      .getRepository(EBoekhoudenConfigEntity)
      .find({ cache: 60000 });
  }
  async pushOrder({ orderCode, channelToken }: JobData): Promise<void> {
    const config = await this.getConfig(channelToken);
    if (!config?.enabled) {
      return;
    }
    const channel = await this.channelService.getChannelFromToken(channelToken);
    const ctx = new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      channel,
      authorizedAsOwnerOnly: false,
    });
    const order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      Logger.error(
        `No order with code ${orderCode} found. Not retrying this job`,
        loggerCtx
      );
      return;
    }
    let sessionId: string | undefined;
    try {
      sessionId = await this.openSession(config);
      const mutation = EBoekhoudenAdapter.toMutation(order, config);
      const result = await this.client.AddMutatieAsync({
        SessionID: sessionId,
        SecurityCode2: config.secret2,
        oMut: mutation,
      });
      this.validate(result[0].AddMutatieResult);
      Logger.info(
        `Successfully send order ${orderCode} to e-boekhouden with mutationNr ${result?.[0]?.AddMutatieResult?.Mutatienummer}`,
        loggerCtx
      );
    } catch (e: any) {
      Logger.error(
        `Failed to push order ${order.code} for channel ${config.channelToken} to account ${config.username}: ${e?.message}`,
        loggerCtx,
        e
      );
      throw e;
    } finally {
      if (sessionId) {
        await this.closeSession(sessionId);
      }
    }
  }
  private async openSession(config: EBoekhoudenConfigEntity): Promise<string> {
    const openSession = await this.client.OpenSessionAsync({
      SecurityCode1: config.secret1,
      SecurityCode2: config.secret2,
      Username: config.username,
    });
    this.validate(openSession[0].OpenSessionResult);
    const sessionId = openSession[0].OpenSessionResult?.SessionID;
    if (!sessionId) {
      throw Error(
        `No SessionID from OpenSession for account ${config.username}`
      );
    }
    return sessionId;
  }
  async closeSession(sessionId: string): Promise<void> {
    await this.client.CloseSessionAsync({ SessionID: sessionId });
  }
  private validate(res?: { ErrorMsg?: ErrorMsg }) {
    if (res?.ErrorMsg?.LastErrorDescription || res?.ErrorMsg?.LastErrorCode) {
      throw Error(
        `${res.ErrorMsg?.LastErrorCode} - ${res.ErrorMsg?.LastErrorDescription}`
      );
    }
  }
}
```

## File: packages/vendure-plugin-e-boekhouden/src/api/schema.graphql.ts

```typescript
import gql from 'graphql-tag';
export const schema = gql`
  input EBoekhoudenConfigInput {
    enabled: Boolean!
    username: String!
    secret1: String!
    secret2: String!
    account: String!
    contraAccount: String!
  }
  type EBoekhoudenConfig {
    enabled: Boolean!
    username: String!
    secret1: String!
    secret2: String!
    account: String!
    contraAccount: String!
  }
  extend type Mutation {
    updateEBoekhoudenConfig(input: EBoekhoudenConfigInput!): EBoekhoudenConfig
  }
  extend type Query {
    eBoekhoudenConfig: EBoekhoudenConfig
  }
`;
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddFactuur.ts

```typescript
import { OFact } from './OFact';
export interface AddFactuur {
  SessionID?: string;
  SecurityCode2?: string;
  oFact?: OFact;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddFactuurResponse.ts

```typescript
import { AddFactuurResult } from './AddFactuurResult';
export interface AddFactuurResponse {
  AddFactuurResult?: AddFactuurResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddFactuurResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface AddFactuurResult {
  ErrorMsg?: ErrorMsg;
  Factuurnummer?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddGrootboekrekening.ts

```typescript
import { OGb } from './OGb';
export interface AddGrootboekrekening {
  SessionID?: string;
  SecurityCode2?: string;
  oGb?: OGb;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddGrootboekrekeningResponse.ts

```typescript
import { AddGrootboekrekeningResult } from './AddGrootboekrekeningResult';
export interface AddGrootboekrekeningResponse {
  AddGrootboekrekeningResult?: AddGrootboekrekeningResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddGrootboekrekeningResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface AddGrootboekrekeningResult {
  ErrorMsg?: ErrorMsg;
  Gb_ID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddMutatie.ts

```typescript
import { OMut } from './OMut';
export interface AddMutatie {
  SessionID?: string;
  SecurityCode2?: string;
  oMut?: OMut;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddMutatieResponse.ts

```typescript
import { AddMutatieResult } from './AddMutatieResult';
export interface AddMutatieResponse {
  AddMutatieResult?: AddMutatieResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddMutatieResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface AddMutatieResult {
  ErrorMsg?: ErrorMsg;
  Mutatienummer?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddRelatie.ts

```typescript
import { ORel } from './ORel';
export interface AddRelatie {
  SessionID?: string;
  SecurityCode2?: string;
  oRel?: ORel;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddRelatieResponse.ts

```typescript
import { AddRelatieResult } from './AddRelatieResult';
export interface AddRelatieResponse {
  AddRelatieResult?: AddRelatieResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AddRelatieResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface AddRelatieResult {
  ErrorMsg?: ErrorMsg;
  Rel_ID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Administraties.ts

```typescript
import { CAdministratie } from './CAdministratie';
export interface Administraties {
  cAdministratie?: Array<CAdministratie>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Artikelen.ts

```typescript
import { CArtikel } from './CArtikel';
export interface Artikelen {
  cArtikel?: Array<CArtikel>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AutoLogin.ts

```typescript
export interface AutoLogin {
  Username?: string;
  SessionID?: string;
  SecurityCode2?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AutoLoginResponse.ts

```typescript
import { AutoLoginResult } from './AutoLoginResult';
export interface AutoLoginResponse {
  AutoLoginResult?: AutoLoginResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/AutoLoginResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface AutoLoginResult {
  ErrorMsg?: ErrorMsg;
  Token?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CAdministratie.ts

```typescript
export interface CAdministratie {
  Bedrijf?: string;
  Plaats?: string;
  Guid?: string;
  StartBoekjaar?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CArtikel.ts

```typescript
export interface CArtikel {
  ArtikelID?: string;
  ArtikelOmschrijving?: string;
  ArtikelCode?: string;
  GroepOmschrijving?: string;
  GroepCode?: string;
  Eenheid?: string;
  InkoopprijsExclBTW?: string;
  VerkoopprijsExclBTW?: string;
  VerkoopprijsInclBTW?: string;
  BTWCode?: string;
  TegenrekeningCode?: string;
  BtwPercentage?: string;
  KostenplaatsID?: string;
  Actief?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFactuurList.ts

```typescript
import { Relatiecode } from './Relatiecode';
import { Regels } from './Regels';
export interface CFactuurList {
  Factuurnummer?: string;
  Relatiecode?: Relatiecode;
  Datum?: string;
  Betalingstermijn?: string;
  TotaalExclBTW?: string;
  TotaalBTW?: string;
  TotaalInclBTW?: string;
  TotaalOpenstaand?: string;
  URLPDFBestand?: string;
  Regels?: Regels;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFactuurRegel.ts

```typescript
export interface CFactuurRegel {
  Aantal?: string;
  Eenheid?: string;
  Code?: string;
  Omschrijving?: string;
  PrijsPerEenheid?: string;
  BTWCode?: string;
  TegenrekeningCode?: string;
  KostenplaatsID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter.ts

```typescript
export interface CFilter {
  GbCode?: string;
  KostenPlaatsId?: string;
  DatumVan?: string;
  DatumTot?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter1.ts

```typescript
export interface CFilter1 {
  KostenPlaatsId?: string;
  DatumVan?: string;
  DatumTot?: string;
  Categorie?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter2.ts

```typescript
export interface CFilter2 {
  Factuurnummer?: string;
  Relatiecode?: string;
  DatumVan?: string;
  DatumTm?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter3.ts

```typescript
export interface CFilter3 {
  MutatieNr?: string;
  MutatieNrVan?: string;
  MutatieNrTm?: string;
  Factuurnummer?: string;
  DatumVan?: string;
  DatumTm?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter4.ts

```typescript
export interface CFilter4 {
  ID?: string;
  Code?: string;
  Categorie?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter5.ts

```typescript
export interface CFilter5 {
  Trefwoord?: string;
  Code?: string;
  ID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter6.ts

```typescript
export interface CFilter6 {
  KostenplaatsID?: string;
  KostenplaatsParentID?: string;
  Omschrijving?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CFilter7.ts

```typescript
export interface CFilter7 {
  ArtikelID?: string;
  ArtikelOmschrijving?: string;
  ArtikelCode?: string;
  GroepOmschrijving?: string;
  GroepCode?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CKostenplaats.ts

```typescript
export interface CKostenplaats {
  KostenplaatsId?: string;
  Omschrijving?: string;
  KostenplaatsParentId?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CloseSession.ts

```typescript
export interface CloseSession {
  SessionID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CloseSessionResponse.ts

```typescript
export interface CloseSessionResponse {}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CMutatieList.ts

```typescript
import { MutatieRegels1 } from './MutatieRegels1';
export interface CMutatieList {
  MutatieNr?: string;
  Soort?: string;
  Datum?: string;
  Rekening?: string;
  RelatieCode?: string;
  Factuurnummer?: string;
  Boekstuk?: string;
  Omschrijving?: string;
  Betalingstermijn?: string;
  InExBTW?: string;
  MutatieRegels?: MutatieRegels1;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CMutatieListRegel.ts

```typescript
export interface CMutatieListRegel {
  BedragInvoer?: string;
  BedragExclBTW?: string;
  BedragBTW?: string;
  BedragInclBTW?: string;
  BTWCode?: string;
  BTWPercentage?: string;
  Factuurnummer?: string;
  TegenrekeningCode?: string;
  KostenplaatsID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CMutatieRegel.ts

```typescript
export interface CMutatieRegel {
  BedragInvoer?: string;
  BedragExclBTW?: string;
  BedragBTW?: string;
  BedragInclBTW?: string;
  BTWCode?: string;
  BTWPercentage?: string;
  TegenrekeningCode?: string;
  KostenplaatsID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/COpenPost.ts

```typescript
export interface COpenPost {
  MutDatum?: string;
  MutFactuur?: string;
  RelCode?: string;
  RelBedrijf?: string;
  Bedrag?: string;
  Voldaan?: string;
  Openstaand?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/CSaldo.ts

```typescript
export interface CSaldo {
  ID?: string;
  Code?: string;
  Categorie?: string;
  Saldo?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/ErrorMsg.ts

```typescript
export interface ErrorMsg {
  LastErrorCode?: string;
  LastErrorDescription?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Facturen.ts

```typescript
import { CFactuurList } from './CFactuurList';
export interface Facturen {
  cFactuurList?: Array<CFactuurList>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetAdministraties.ts

```typescript
export interface GetAdministraties {
  SessionID?: string;
  SecurityCode2?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetAdministratiesResponse.ts

```typescript
import { GetAdministratiesResult } from './GetAdministratiesResult';
export interface GetAdministratiesResponse {
  GetAdministratiesResult?: GetAdministratiesResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetAdministratiesResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Administraties } from './Administraties';
export interface GetAdministratiesResult {
  ErrorMsg?: ErrorMsg;
  Administraties?: Administraties;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetArtikelen.ts

```typescript
import { CFilter7 } from './CFilter7';
export interface GetArtikelen {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter7;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetArtikelenResponse.ts

```typescript
import { GetArtikelenResult } from './GetArtikelenResult';
export interface GetArtikelenResponse {
  GetArtikelenResult?: GetArtikelenResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetArtikelenResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Artikelen } from './Artikelen';
export interface GetArtikelenResult {
  ErrorMsg?: ErrorMsg;
  Artikelen?: Artikelen;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetFacturen.ts

```typescript
import { CFilter2 } from './CFilter2';
export interface GetFacturen {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter2;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetFacturenResponse.ts

```typescript
import { GetFacturenResult } from './GetFacturenResult';
export interface GetFacturenResponse {
  GetFacturenResult?: GetFacturenResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetFacturenResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Facturen } from './Facturen';
export interface GetFacturenResult {
  ErrorMsg?: ErrorMsg;
  Facturen?: Facturen;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetGrootboekrekeningen.ts

```typescript
import { CFilter4 } from './CFilter4';
export interface GetGrootboekrekeningen {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter4;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetGrootboekrekeningenResponse.ts

```typescript
import { GetGrootboekrekeningenResult } from './GetGrootboekrekeningenResult';
export interface GetGrootboekrekeningenResponse {
  GetGrootboekrekeningenResult?: GetGrootboekrekeningenResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetGrootboekrekeningenResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Rekeningen } from './Rekeningen';
export interface GetGrootboekrekeningenResult {
  ErrorMsg?: ErrorMsg;
  Rekeningen?: Rekeningen;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetKostenplaatsen.ts

```typescript
import { CFilter6 } from './CFilter6';
export interface GetKostenplaatsen {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter6;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetKostenplaatsenResponse.ts

```typescript
import { GetKostenplaatsenResult } from './GetKostenplaatsenResult';
export interface GetKostenplaatsenResponse {
  GetKostenplaatsenResult?: GetKostenplaatsenResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetKostenplaatsenResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Kostenplaatsen } from './Kostenplaatsen';
export interface GetKostenplaatsenResult {
  ErrorMsg?: ErrorMsg;
  Kostenplaatsen?: Kostenplaatsen;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetMutaties.ts

```typescript
import { CFilter3 } from './CFilter3';
export interface GetMutaties {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter3;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetMutatiesResponse.ts

```typescript
import { GetMutatiesResult } from './GetMutatiesResult';
export interface GetMutatiesResponse {
  GetMutatiesResult?: GetMutatiesResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetMutatiesResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Mutaties } from './Mutaties';
export interface GetMutatiesResult {
  ErrorMsg?: ErrorMsg;
  Mutaties?: Mutaties;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetOpenPosten.ts

```typescript
export interface GetOpenPosten {
  SessionID?: string;
  SecurityCode2?: string;
  OpSoort?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetOpenPostenResponse.ts

```typescript
import { GetOpenPostenResult } from './GetOpenPostenResult';
export interface GetOpenPostenResponse {
  GetOpenPostenResult?: GetOpenPostenResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetOpenPostenResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Openposten } from './Openposten';
export interface GetOpenPostenResult {
  ErrorMsg?: ErrorMsg;
  Openposten?: Openposten;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetRelaties.ts

```typescript
import { CFilter5 } from './CFilter5';
export interface GetRelaties {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter5;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetRelatiesResponse.ts

```typescript
import { GetRelatiesResult } from './GetRelatiesResult';
export interface GetRelatiesResponse {
  GetRelatiesResult?: GetRelatiesResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetRelatiesResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Relaties } from './Relaties';
export interface GetRelatiesResult {
  ErrorMsg?: ErrorMsg;
  Relaties?: Relaties;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetSaldi.ts

```typescript
import { CFilter1 } from './CFilter1';
export interface GetSaldi {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter1;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetSaldiResponse.ts

```typescript
import { GetSaldiResult } from './GetSaldiResult';
export interface GetSaldiResponse {
  GetSaldiResult?: GetSaldiResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetSaldiResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
import { Saldi } from './Saldi';
export interface GetSaldiResult {
  ErrorMsg?: ErrorMsg;
  Saldi?: Saldi;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetSaldo.ts

```typescript
import { CFilter } from './CFilter';
export interface GetSaldo {
  SessionID?: string;
  SecurityCode2?: string;
  cFilter?: CFilter;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetSaldoResponse.ts

```typescript
import { GetSaldoResult } from './GetSaldoResult';
export interface GetSaldoResponse {
  GetSaldoResult?: GetSaldoResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/GetSaldoResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface GetSaldoResult {
  ErrorMsg?: ErrorMsg;
  Saldo?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Kostenplaatsen.ts

```typescript
import { CKostenplaats } from './CKostenplaats';
export interface Kostenplaatsen {
  cKostenplaats?: Array<CKostenplaats>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/MutatieRegels.ts

```typescript
import { CMutatieRegel } from './CMutatieRegel';
export interface MutatieRegels {
  cMutatieRegel?: Array<CMutatieRegel>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/MutatieRegels1.ts

```typescript
import { CMutatieListRegel } from './CMutatieListRegel';
export interface MutatieRegels1 {
  cMutatieListRegel?: Array<CMutatieListRegel>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Mutaties.ts

```typescript
import { CMutatieList } from './CMutatieList';
export interface Mutaties {
  cMutatieList?: Array<CMutatieList>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OFact.ts

```typescript
import { Regels } from './Regels';
export interface OFact {
  Factuurnummer?: string;
  Relatiecode?: string;
  Datum?: string;
  Betalingstermijn?: string;
  Factuursjabloon?: string;
  PerEmailVerzenden?: string;
  EmailOnderwerp?: string;
  EmailBericht?: string;
  EmailVanAdres?: string;
  EmailVanNaam?: string;
  AutomatischeIncasso?: string;
  IncassoIBAN?: string;
  IncassoMachtigingSoort?: string;
  IncassoMachtigingID?: string;
  IncassoMachtigingDatumOndertekening?: string;
  IncassoMachtigingFirst?: string;
  IncassoRekeningNummer?: string;
  IncassoTnv?: string;
  IncassoPlaats?: string;
  IncassoOmschrijvingRegel1?: string;
  IncassoOmschrijvingRegel2?: string;
  IncassoOmschrijvingRegel3?: string;
  InBoekhoudingPlaatsen?: string;
  BoekhoudmutatieOmschrijving?: string;
  Regels?: Regels;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OGb.ts

```typescript
export interface OGb {
  ID?: string;
  Code?: string;
  Omschrijving?: string;
  Categorie?: string;
  Groep?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OMut.ts

```typescript
import { MutatieRegels } from './MutatieRegels';
export interface OMut {
  MutatieNr?: string;
  Soort?: string;
  Datum?: string;
  Rekening?: string;
  RelatieCode?: string;
  Factuurnummer?: string;
  Boekstuk?: string;
  Omschrijving?: string;
  Betalingstermijn?: string;
  Betalingskenmerk?: string;
  InExBTW?: string;
  MutatieRegels?: MutatieRegels;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Openposten.ts

```typescript
import { COpenPost } from './COpenPost';
export interface Openposten {
  cOpenPost?: Array<COpenPost>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OpenSession.ts

```typescript
export interface OpenSession {
  Username?: string;
  SecurityCode1?: string;
  SecurityCode2?: string;
  Source?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OpenSessionResponse.ts

```typescript
import { OpenSessionResult } from './OpenSessionResult';
export interface OpenSessionResponse {
  OpenSessionResult?: OpenSessionResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OpenSessionResult.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface OpenSessionResult {
  ErrorMsg?: ErrorMsg;
  SessionID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OpenSessionSub.ts

```typescript
export interface OpenSessionSub {
  Username?: string;
  SecurityCode1?: string;
  SecurityCode2?: string;
  Source?: string;
  AdministratieGUID?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/OpenSessionSubResponse.ts

```typescript
import { OpenSessionResult } from './OpenSessionResult';
export interface OpenSessionSubResponse {
  OpenSessionSubResult?: OpenSessionResult;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/ORel.ts

```typescript
export interface ORel {
  ID?: string;
  AddDatum?: string;
  Code?: string;
  Bedrijf?: string;
  Contactpersoon?: string;
  Geslacht?: string;
  Adres?: string;
  Postcode?: string;
  Plaats?: string;
  Land?: string;
  Adres2?: string;
  Postcode2?: string;
  Plaats2?: string;
  Land2?: string;
  Telefoon?: string;
  GSM?: string;
  FAX?: string;
  Email?: string;
  Site?: string;
  Notitie?: string;
  Bankrekening?: string;
  Girorekening?: string;
  BTWNummer?: string;
  KvkNummer?: string;
  Aanhef?: string;
  IBAN?: string;
  BIC?: string;
  BP?: string;
  Def1?: string;
  Def2?: string;
  Def3?: string;
  Def4?: string;
  Def5?: string;
  Def6?: string;
  Def7?: string;
  Def8?: string;
  Def9?: string;
  Def10?: string;
  LA?: string;
  Gb_ID?: string;
  GeenEmail?: string;
  NieuwsbriefgroepenCount?: string;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Regels.ts

```typescript
import { CFactuurRegel } from './CFactuurRegel';
export interface Regels {
  cFactuurRegel?: Array<CFactuurRegel>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Rekeningen.ts

```typescript
import { OGb } from './OGb';
export interface Rekeningen {
  cGrootboekrekening?: Array<OGb>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Relatiecode.ts

```typescript
export interface Relatiecode {}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Relaties.ts

```typescript
import { ORel } from './ORel';
export interface Relaties {
  cRelatie?: Array<ORel>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/Saldi.ts

```typescript
import { CSaldo } from './CSaldo';
export interface Saldi {
  cSaldo?: Array<CSaldo>;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/UpdateGrootboekrekening.ts

```typescript
import { OGb } from './OGb';
export interface UpdateGrootboekrekening {
  SessionID?: string;
  SecurityCode2?: string;
  oGb?: OGb;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/UpdateGrootboekrekeningResponse.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface UpdateGrootboekrekeningResponse {
  UpdateGrootboekrekeningResult?: ErrorMsg;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/UpdateRelatie.ts

```typescript
import { ORel } from './ORel';
export interface UpdateRelatie {
  SessionID?: string;
  SecurityCode2?: string;
  oRel?: ORel;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/definitions/UpdateRelatieResponse.ts

```typescript
import { ErrorMsg } from './ErrorMsg';
export interface UpdateRelatieResponse {
  UpdateRelatieResult?: ErrorMsg;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/ports/SoapAppSoap.ts

```typescript
import { GetAdministraties } from '../definitions/GetAdministraties';
import { GetAdministratiesResponse } from '../definitions/GetAdministratiesResponse';
import { GetSaldo } from '../definitions/GetSaldo';
import { GetSaldoResponse } from '../definitions/GetSaldoResponse';
import { GetSaldi } from '../definitions/GetSaldi';
import { GetSaldiResponse } from '../definitions/GetSaldiResponse';
import { AddFactuur } from '../definitions/AddFactuur';
import { AddFactuurResponse } from '../definitions/AddFactuurResponse';
import { GetFacturen } from '../definitions/GetFacturen';
import { GetFacturenResponse } from '../definitions/GetFacturenResponse';
import { AddMutatie } from '../definitions/AddMutatie';
import { AddMutatieResponse } from '../definitions/AddMutatieResponse';
import { GetMutaties } from '../definitions/GetMutaties';
import { GetMutatiesResponse } from '../definitions/GetMutatiesResponse';
import { AddGrootboekrekening } from '../definitions/AddGrootboekrekening';
import { AddGrootboekrekeningResponse } from '../definitions/AddGrootboekrekeningResponse';
import { UpdateGrootboekrekening } from '../definitions/UpdateGrootboekrekening';
import { UpdateGrootboekrekeningResponse } from '../definitions/UpdateGrootboekrekeningResponse';
import { GetGrootboekrekeningen } from '../definitions/GetGrootboekrekeningen';
import { GetGrootboekrekeningenResponse } from '../definitions/GetGrootboekrekeningenResponse';
import { AddRelatie } from '../definitions/AddRelatie';
import { AddRelatieResponse } from '../definitions/AddRelatieResponse';
import { UpdateRelatie } from '../definitions/UpdateRelatie';
import { UpdateRelatieResponse } from '../definitions/UpdateRelatieResponse';
import { GetRelaties } from '../definitions/GetRelaties';
import { GetRelatiesResponse } from '../definitions/GetRelatiesResponse';
import { GetOpenPosten } from '../definitions/GetOpenPosten';
import { GetOpenPostenResponse } from '../definitions/GetOpenPostenResponse';
import { OpenSession } from '../definitions/OpenSession';
import { OpenSessionResponse } from '../definitions/OpenSessionResponse';
import { OpenSessionSub } from '../definitions/OpenSessionSub';
import { OpenSessionSubResponse } from '../definitions/OpenSessionSubResponse';
import { CloseSession } from '../definitions/CloseSession';
import { CloseSessionResponse } from '../definitions/CloseSessionResponse';
import { AutoLogin } from '../definitions/AutoLogin';
import { AutoLoginResponse } from '../definitions/AutoLoginResponse';
import { GetKostenplaatsen } from '../definitions/GetKostenplaatsen';
import { GetKostenplaatsenResponse } from '../definitions/GetKostenplaatsenResponse';
import { GetArtikelen } from '../definitions/GetArtikelen';
import { GetArtikelenResponse } from '../definitions/GetArtikelenResponse';
export interface SoapAppSoap {
  GetAdministraties(
    getAdministraties: GetAdministraties,
    callback: (
      err: any,
      result: GetAdministratiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetSaldo(
    getSaldo: GetSaldo,
    callback: (
      err: any,
      result: GetSaldoResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetSaldi(
    getSaldi: GetSaldi,
    callback: (
      err: any,
      result: GetSaldiResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddFactuur(
    addFactuur: AddFactuur,
    callback: (
      err: any,
      result: AddFactuurResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetFacturen(
    getFacturen: GetFacturen,
    callback: (
      err: any,
      result: GetFacturenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddMutatie(
    addMutatie: AddMutatie,
    callback: (
      err: any,
      result: AddMutatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetMutaties(
    getMutaties: GetMutaties,
    callback: (
      err: any,
      result: GetMutatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddGrootboekrekening(
    addGrootboekrekening: AddGrootboekrekening,
    callback: (
      err: any,
      result: AddGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  UpdateGrootboekrekening(
    updateGrootboekrekening: UpdateGrootboekrekening,
    callback: (
      err: any,
      result: UpdateGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetGrootboekrekeningen(
    getGrootboekrekeningen: GetGrootboekrekeningen,
    callback: (
      err: any,
      result: GetGrootboekrekeningenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddRelatie(
    addRelatie: AddRelatie,
    callback: (
      err: any,
      result: AddRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  UpdateRelatie(
    updateRelatie: UpdateRelatie,
    callback: (
      err: any,
      result: UpdateRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetRelaties(
    getRelaties: GetRelaties,
    callback: (
      err: any,
      result: GetRelatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetOpenPosten(
    getOpenPosten: GetOpenPosten,
    callback: (
      err: any,
      result: GetOpenPostenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  OpenSession(
    openSession: OpenSession,
    callback: (
      err: any,
      result: OpenSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  OpenSessionSub(
    openSessionSub: OpenSessionSub,
    callback: (
      err: any,
      result: OpenSessionSubResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  CloseSession(
    closeSession: CloseSession,
    callback: (
      err: any,
      result: CloseSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AutoLogin(
    autoLogin: AutoLogin,
    callback: (
      err: any,
      result: AutoLoginResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetKostenplaatsen(
    getKostenplaatsen: GetKostenplaatsen,
    callback: (
      err: any,
      result: GetKostenplaatsenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetArtikelen(
    getArtikelen: GetArtikelen,
    callback: (
      err: any,
      result: GetArtikelenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/ports/SoapAppSoap12.ts

```typescript
import { GetAdministraties } from '../definitions/GetAdministraties';
import { GetAdministratiesResponse } from '../definitions/GetAdministratiesResponse';
import { GetSaldo } from '../definitions/GetSaldo';
import { GetSaldoResponse } from '../definitions/GetSaldoResponse';
import { GetSaldi } from '../definitions/GetSaldi';
import { GetSaldiResponse } from '../definitions/GetSaldiResponse';
import { AddFactuur } from '../definitions/AddFactuur';
import { AddFactuurResponse } from '../definitions/AddFactuurResponse';
import { GetFacturen } from '../definitions/GetFacturen';
import { GetFacturenResponse } from '../definitions/GetFacturenResponse';
import { AddMutatie } from '../definitions/AddMutatie';
import { AddMutatieResponse } from '../definitions/AddMutatieResponse';
import { GetMutaties } from '../definitions/GetMutaties';
import { GetMutatiesResponse } from '../definitions/GetMutatiesResponse';
import { AddGrootboekrekening } from '../definitions/AddGrootboekrekening';
import { AddGrootboekrekeningResponse } from '../definitions/AddGrootboekrekeningResponse';
import { UpdateGrootboekrekening } from '../definitions/UpdateGrootboekrekening';
import { UpdateGrootboekrekeningResponse } from '../definitions/UpdateGrootboekrekeningResponse';
import { GetGrootboekrekeningen } from '../definitions/GetGrootboekrekeningen';
import { GetGrootboekrekeningenResponse } from '../definitions/GetGrootboekrekeningenResponse';
import { AddRelatie } from '../definitions/AddRelatie';
import { AddRelatieResponse } from '../definitions/AddRelatieResponse';
import { UpdateRelatie } from '../definitions/UpdateRelatie';
import { UpdateRelatieResponse } from '../definitions/UpdateRelatieResponse';
import { GetRelaties } from '../definitions/GetRelaties';
import { GetRelatiesResponse } from '../definitions/GetRelatiesResponse';
import { GetOpenPosten } from '../definitions/GetOpenPosten';
import { GetOpenPostenResponse } from '../definitions/GetOpenPostenResponse';
import { OpenSession } from '../definitions/OpenSession';
import { OpenSessionResponse } from '../definitions/OpenSessionResponse';
import { OpenSessionSub } from '../definitions/OpenSessionSub';
import { OpenSessionSubResponse } from '../definitions/OpenSessionSubResponse';
import { CloseSession } from '../definitions/CloseSession';
import { CloseSessionResponse } from '../definitions/CloseSessionResponse';
import { AutoLogin } from '../definitions/AutoLogin';
import { AutoLoginResponse } from '../definitions/AutoLoginResponse';
import { GetKostenplaatsen } from '../definitions/GetKostenplaatsen';
import { GetKostenplaatsenResponse } from '../definitions/GetKostenplaatsenResponse';
import { GetArtikelen } from '../definitions/GetArtikelen';
import { GetArtikelenResponse } from '../definitions/GetArtikelenResponse';
export interface SoapAppSoap12 {
  GetAdministraties(
    getAdministraties: GetAdministraties,
    callback: (
      err: any,
      result: GetAdministratiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetSaldo(
    getSaldo: GetSaldo,
    callback: (
      err: any,
      result: GetSaldoResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetSaldi(
    getSaldi: GetSaldi,
    callback: (
      err: any,
      result: GetSaldiResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddFactuur(
    addFactuur: AddFactuur,
    callback: (
      err: any,
      result: AddFactuurResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetFacturen(
    getFacturen: GetFacturen,
    callback: (
      err: any,
      result: GetFacturenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddMutatie(
    addMutatie: AddMutatie,
    callback: (
      err: any,
      result: AddMutatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetMutaties(
    getMutaties: GetMutaties,
    callback: (
      err: any,
      result: GetMutatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddGrootboekrekening(
    addGrootboekrekening: AddGrootboekrekening,
    callback: (
      err: any,
      result: AddGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  UpdateGrootboekrekening(
    updateGrootboekrekening: UpdateGrootboekrekening,
    callback: (
      err: any,
      result: UpdateGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetGrootboekrekeningen(
    getGrootboekrekeningen: GetGrootboekrekeningen,
    callback: (
      err: any,
      result: GetGrootboekrekeningenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AddRelatie(
    addRelatie: AddRelatie,
    callback: (
      err: any,
      result: AddRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  UpdateRelatie(
    updateRelatie: UpdateRelatie,
    callback: (
      err: any,
      result: UpdateRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetRelaties(
    getRelaties: GetRelaties,
    callback: (
      err: any,
      result: GetRelatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetOpenPosten(
    getOpenPosten: GetOpenPosten,
    callback: (
      err: any,
      result: GetOpenPostenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  OpenSession(
    openSession: OpenSession,
    callback: (
      err: any,
      result: OpenSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  OpenSessionSub(
    openSessionSub: OpenSessionSub,
    callback: (
      err: any,
      result: OpenSessionSubResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  CloseSession(
    closeSession: CloseSession,
    callback: (
      err: any,
      result: CloseSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  AutoLogin(
    autoLogin: AutoLogin,
    callback: (
      err: any,
      result: AutoLoginResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetKostenplaatsen(
    getKostenplaatsen: GetKostenplaatsen,
    callback: (
      err: any,
      result: GetKostenplaatsenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
  GetArtikelen(
    getArtikelen: GetArtikelen,
    callback: (
      err: any,
      result: GetArtikelenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ) => void
  ): void;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/services/SoapApp.ts

```typescript
import { SoapAppSoap } from '../ports/SoapAppSoap';
import { SoapAppSoap12 } from '../ports/SoapAppSoap12';
export interface SoapApp {
  readonly SoapAppSoap: SoapAppSoap;
  readonly SoapAppSoap12: SoapAppSoap12;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/client.ts

```typescript
import {
  Client as SoapClient,
  createClientAsync as soapCreateClientAsync,
} from 'soap';
import { GetAdministraties } from './definitions/GetAdministraties';
import { GetAdministratiesResponse } from './definitions/GetAdministratiesResponse';
import { GetSaldo } from './definitions/GetSaldo';
import { GetSaldoResponse } from './definitions/GetSaldoResponse';
import { GetSaldi } from './definitions/GetSaldi';
import { GetSaldiResponse } from './definitions/GetSaldiResponse';
import { AddFactuur } from './definitions/AddFactuur';
import { AddFactuurResponse } from './definitions/AddFactuurResponse';
import { GetFacturen } from './definitions/GetFacturen';
import { GetFacturenResponse } from './definitions/GetFacturenResponse';
import { AddMutatie } from './definitions/AddMutatie';
import { AddMutatieResponse } from './definitions/AddMutatieResponse';
import { GetMutaties } from './definitions/GetMutaties';
import { GetMutatiesResponse } from './definitions/GetMutatiesResponse';
import { AddGrootboekrekening } from './definitions/AddGrootboekrekening';
import { AddGrootboekrekeningResponse } from './definitions/AddGrootboekrekeningResponse';
import { UpdateGrootboekrekening } from './definitions/UpdateGrootboekrekening';
import { UpdateGrootboekrekeningResponse } from './definitions/UpdateGrootboekrekeningResponse';
import { GetGrootboekrekeningen } from './definitions/GetGrootboekrekeningen';
import { GetGrootboekrekeningenResponse } from './definitions/GetGrootboekrekeningenResponse';
import { AddRelatie } from './definitions/AddRelatie';
import { AddRelatieResponse } from './definitions/AddRelatieResponse';
import { UpdateRelatie } from './definitions/UpdateRelatie';
import { UpdateRelatieResponse } from './definitions/UpdateRelatieResponse';
import { GetRelaties } from './definitions/GetRelaties';
import { GetRelatiesResponse } from './definitions/GetRelatiesResponse';
import { GetOpenPosten } from './definitions/GetOpenPosten';
import { GetOpenPostenResponse } from './definitions/GetOpenPostenResponse';
import { OpenSession } from './definitions/OpenSession';
import { OpenSessionResponse } from './definitions/OpenSessionResponse';
import { OpenSessionSub } from './definitions/OpenSessionSub';
import { OpenSessionSubResponse } from './definitions/OpenSessionSubResponse';
import { CloseSession } from './definitions/CloseSession';
import { CloseSessionResponse } from './definitions/CloseSessionResponse';
import { AutoLogin } from './definitions/AutoLogin';
import { AutoLoginResponse } from './definitions/AutoLoginResponse';
import { GetKostenplaatsen } from './definitions/GetKostenplaatsen';
import { GetKostenplaatsenResponse } from './definitions/GetKostenplaatsenResponse';
import { GetArtikelen } from './definitions/GetArtikelen';
import { GetArtikelenResponse } from './definitions/GetArtikelenResponse';
import { SoapApp } from './services/SoapApp';
export interface EBoekhoudenWsdlClient extends SoapClient {
  SoapApp: SoapApp;
  GetAdministratiesAsync(
    getAdministraties: GetAdministraties
  ): Promise<
    [
      result: GetAdministratiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetSaldoAsync(
    getSaldo: GetSaldo
  ): Promise<
    [
      result: GetSaldoResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetSaldiAsync(
    getSaldi: GetSaldi
  ): Promise<
    [
      result: GetSaldiResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddFactuurAsync(
    addFactuur: AddFactuur
  ): Promise<
    [
      result: AddFactuurResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetFacturenAsync(
    getFacturen: GetFacturen
  ): Promise<
    [
      result: GetFacturenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddMutatieAsync(
    addMutatie: AddMutatie
  ): Promise<
    [
      result: AddMutatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetMutatiesAsync(
    getMutaties: GetMutaties
  ): Promise<
    [
      result: GetMutatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddGrootboekrekeningAsync(
    addGrootboekrekening: AddGrootboekrekening
  ): Promise<
    [
      result: AddGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  UpdateGrootboekrekeningAsync(
    updateGrootboekrekening: UpdateGrootboekrekening
  ): Promise<
    [
      result: UpdateGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetGrootboekrekeningenAsync(
    getGrootboekrekeningen: GetGrootboekrekeningen
  ): Promise<
    [
      result: GetGrootboekrekeningenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddRelatieAsync(
    addRelatie: AddRelatie
  ): Promise<
    [
      result: AddRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  UpdateRelatieAsync(
    updateRelatie: UpdateRelatie
  ): Promise<
    [
      result: UpdateRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetRelatiesAsync(
    getRelaties: GetRelaties
  ): Promise<
    [
      result: GetRelatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetOpenPostenAsync(
    getOpenPosten: GetOpenPosten
  ): Promise<
    [
      result: GetOpenPostenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  OpenSessionAsync(
    openSession: OpenSession
  ): Promise<
    [
      result: OpenSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  OpenSessionSubAsync(
    openSessionSub: OpenSessionSub
  ): Promise<
    [
      result: OpenSessionSubResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  CloseSessionAsync(
    closeSession: CloseSession
  ): Promise<
    [
      result: CloseSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AutoLoginAsync(
    autoLogin: AutoLogin
  ): Promise<
    [
      result: AutoLoginResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetKostenplaatsenAsync(
    getKostenplaatsen: GetKostenplaatsen
  ): Promise<
    [
      result: GetKostenplaatsenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetArtikelenAsync(
    getArtikelen: GetArtikelen
  ): Promise<
    [
      result: GetArtikelenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetAdministratiesAsync(
    getAdministraties: GetAdministraties
  ): Promise<
    [
      result: GetAdministratiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetSaldoAsync(
    getSaldo: GetSaldo
  ): Promise<
    [
      result: GetSaldoResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetSaldiAsync(
    getSaldi: GetSaldi
  ): Promise<
    [
      result: GetSaldiResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddFactuurAsync(
    addFactuur: AddFactuur
  ): Promise<
    [
      result: AddFactuurResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetFacturenAsync(
    getFacturen: GetFacturen
  ): Promise<
    [
      result: GetFacturenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddMutatieAsync(
    addMutatie: AddMutatie
  ): Promise<
    [
      result: AddMutatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetMutatiesAsync(
    getMutaties: GetMutaties
  ): Promise<
    [
      result: GetMutatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddGrootboekrekeningAsync(
    addGrootboekrekening: AddGrootboekrekening
  ): Promise<
    [
      result: AddGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  UpdateGrootboekrekeningAsync(
    updateGrootboekrekening: UpdateGrootboekrekening
  ): Promise<
    [
      result: UpdateGrootboekrekeningResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetGrootboekrekeningenAsync(
    getGrootboekrekeningen: GetGrootboekrekeningen
  ): Promise<
    [
      result: GetGrootboekrekeningenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AddRelatieAsync(
    addRelatie: AddRelatie
  ): Promise<
    [
      result: AddRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  UpdateRelatieAsync(
    updateRelatie: UpdateRelatie
  ): Promise<
    [
      result: UpdateRelatieResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetRelatiesAsync(
    getRelaties: GetRelaties
  ): Promise<
    [
      result: GetRelatiesResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetOpenPostenAsync(
    getOpenPosten: GetOpenPosten
  ): Promise<
    [
      result: GetOpenPostenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  OpenSessionAsync(
    openSession: OpenSession
  ): Promise<
    [
      result: OpenSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  OpenSessionSubAsync(
    openSessionSub: OpenSessionSub
  ): Promise<
    [
      result: OpenSessionSubResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  CloseSessionAsync(
    closeSession: CloseSession
  ): Promise<
    [
      result: CloseSessionResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  AutoLoginAsync(
    autoLogin: AutoLogin
  ): Promise<
    [
      result: AutoLoginResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetKostenplaatsenAsync(
    getKostenplaatsen: GetKostenplaatsen
  ): Promise<
    [
      result: GetKostenplaatsenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
  GetArtikelenAsync(
    getArtikelen: GetArtikelen
  ): Promise<
    [
      result: GetArtikelenResponse,
      rawResponse: any,
      soapHeader: any,
      rawRequest: any
    ]
  >;
}
export function createClientAsync(
  ...args: Parameters<typeof soapCreateClientAsync>
): Promise<EBoekhoudenWsdlClient> {
  return soapCreateClientAsync(args[0], args[1], args[2]) as any;
}
```

## File: packages/vendure-plugin-e-boekhouden/src/client/eboekhoudenwsdl/index.ts

```typescript
export { GetAdministraties } from './definitions/GetAdministraties';
export { GetAdministratiesResponse } from './definitions/GetAdministratiesResponse';
export { GetAdministratiesResult } from './definitions/GetAdministratiesResult';
export { ErrorMsg } from './definitions/ErrorMsg';
export { Administraties } from './definitions/Administraties';
export { CAdministratie } from './definitions/CAdministratie';
export { GetSaldo } from './definitions/GetSaldo';
export { CFilter } from './definitions/CFilter';
export { GetSaldoResponse } from './definitions/GetSaldoResponse';
export { GetSaldoResult } from './definitions/GetSaldoResult';
export { GetSaldi } from './definitions/GetSaldi';
export { CFilter1 } from './definitions/CFilter1';
export { GetSaldiResponse } from './definitions/GetSaldiResponse';
export { GetSaldiResult } from './definitions/GetSaldiResult';
export { Saldi } from './definitions/Saldi';
export { CSaldo } from './definitions/CSaldo';
export { AddFactuur } from './definitions/AddFactuur';
export { OFact } from './definitions/OFact';
export { Regels } from './definitions/Regels';
export { CFactuurRegel } from './definitions/CFactuurRegel';
export { AddFactuurResponse } from './definitions/AddFactuurResponse';
export { AddFactuurResult } from './definitions/AddFactuurResult';
export { GetFacturen } from './definitions/GetFacturen';
export { CFilter2 } from './definitions/CFilter2';
export { GetFacturenResponse } from './definitions/GetFacturenResponse';
export { GetFacturenResult } from './definitions/GetFacturenResult';
export { Facturen } from './definitions/Facturen';
export { CFactuurList } from './definitions/CFactuurList';
export { Relatiecode } from './definitions/Relatiecode';
export { AddMutatie } from './definitions/AddMutatie';
export { OMut } from './definitions/OMut';
export { MutatieRegels } from './definitions/MutatieRegels';
export { CMutatieRegel } from './definitions/CMutatieRegel';
export { AddMutatieResponse } from './definitions/AddMutatieResponse';
export { AddMutatieResult } from './definitions/AddMutatieResult';
export { GetMutaties } from './definitions/GetMutaties';
export { CFilter3 } from './definitions/CFilter3';
export { GetMutatiesResponse } from './definitions/GetMutatiesResponse';
export { GetMutatiesResult } from './definitions/GetMutatiesResult';
export { Mutaties } from './definitions/Mutaties';
export { CMutatieList } from './definitions/CMutatieList';
export { MutatieRegels1 } from './definitions/MutatieRegels1';
export { CMutatieListRegel } from './definitions/CMutatieListRegel';
export { AddGrootboekrekening } from './definitions/AddGrootboekrekening';
export { OGb } from './definitions/OGb';
export { AddGrootboekrekeningResponse } from './definitions/AddGrootboekrekeningResponse';
export { AddGrootboekrekeningResult } from './definitions/AddGrootboekrekeningResult';
export { UpdateGrootboekrekening } from './definitions/UpdateGrootboekrekening';
export { UpdateGrootboekrekeningResponse } from './definitions/UpdateGrootboekrekeningResponse';
export { GetGrootboekrekeningen } from './definitions/GetGrootboekrekeningen';
export { CFilter4 } from './definitions/CFilter4';
export { GetGrootboekrekeningenResponse } from './definitions/GetGrootboekrekeningenResponse';
export { GetGrootboekrekeningenResult } from './definitions/GetGrootboekrekeningenResult';
export { Rekeningen } from './definitions/Rekeningen';
export { AddRelatie } from './definitions/AddRelatie';
export { ORel } from './definitions/ORel';
export { AddRelatieResponse } from './definitions/AddRelatieResponse';
export { AddRelatieResult } from './definitions/AddRelatieResult';
export { UpdateRelatie } from './definitions/UpdateRelatie';
export { UpdateRelatieResponse } from './definitions/UpdateRelatieResponse';
export { GetRelaties } from './definitions/GetRelaties';
export { CFilter5 } from './definitions/CFilter5';
export { GetRelatiesResponse } from './definitions/GetRelatiesResponse';
export { GetRelatiesResult } from './definitions/GetRelatiesResult';
export { Relaties } from './definitions/Relaties';
export { GetOpenPosten } from './definitions/GetOpenPosten';
export { GetOpenPostenResponse } from './definitions/GetOpenPostenResponse';
export { GetOpenPostenResult } from './definitions/GetOpenPostenResult';
export { Openposten } from './definitions/Openposten';
export { COpenPost } from './definitions/COpenPost';
export { OpenSession } from './definitions/OpenSession';
export { OpenSessionResponse } from './definitions/OpenSessionResponse';
export { OpenSessionResult } from './definitions/OpenSessionResult';
export { OpenSessionSub } from './definitions/OpenSessionSub';
export { OpenSessionSubResponse } from './definitions/OpenSessionSubResponse';
export { CloseSession } from './definitions/CloseSession';
export { CloseSessionResponse } from './definitions/CloseSessionResponse';
export { AutoLogin } from './definitions/AutoLogin';
export { AutoLoginResponse } from './definitions/AutoLoginResponse';
export { AutoLoginResult } from './definitions/AutoLoginResult';
export { GetKostenplaatsen } from './definitions/GetKostenplaatsen';
export { CFilter6 } from './definitions/CFilter6';
export { GetKostenplaatsenResponse } from './definitions/GetKostenplaatsenResponse';
export { GetKostenplaatsenResult } from './definitions/GetKostenplaatsenResult';
export { Kostenplaatsen } from './definitions/Kostenplaatsen';
export { CKostenplaats } from './definitions/CKostenplaats';
export { GetArtikelen } from './definitions/GetArtikelen';
export { CFilter7 } from './definitions/CFilter7';
export { GetArtikelenResponse } from './definitions/GetArtikelenResponse';
export { GetArtikelenResult } from './definitions/GetArtikelenResult';
export { Artikelen } from './definitions/Artikelen';
export { CArtikel } from './definitions/CArtikel';
export { createClientAsync, EBoekhoudenWsdlClient } from './client';
export { SoapApp } from './services/SoapApp';
export { SoapAppSoap } from './ports/SoapAppSoap';
export { SoapAppSoap12 } from './ports/SoapAppSoap12';
```

## File: packages/vendure-plugin-e-boekhouden/src/client/index.ts

```typescript
export * from './eboekhoudenwsdl';
```

## File: packages/vendure-plugin-e-boekhouden/src/ui/e-boekhouden-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
@NgModule({
  imports: [SharedModule],
  providers: [
    addNavMenuItem(
      {
        id: 'e-boekhouden',
        label: 'e-Boekhouden',
        routerLink: ['/extensions/e-boekhouden'],
        icon: 'dollar-bill',
        requiresPermission: 'eBoekhouden',
      },
      'settings'
    ),
  ],
})
export class EBoekhoudenNavModule {}
```

## File: packages/vendure-plugin-e-boekhouden/src/ui/e-boekhouden.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { DataService, NotificationService } from '@vendure/admin-ui/core';
import {
  eBoekhoudenConfigQuery,
  updateEBoekhoudenConfigMutation,
} from './queries.graphql';
import {
  EBoekhoudenConfig,
  UpdateEBoekhoudenConfigMutation,
  UpdateEBoekhoudenConfigMutationVariables,
} from './generated/graphql';
@Component({
  selector: 'e-boekhouden-component',
  template: `
    <form class="form" [formGroup]="form">
      <section class="form-block">
        <vdr-form-field label="Enabled" for="enabled">
          <input
            type="checkbox"
            name="enabled"
            clrCheckbox
            formControlName="enabled"
          />
        </vdr-form-field>
        <vdr-form-field label="Username" for="username">
          <input id="username" type="text" formControlName="username" />
        </vdr-form-field>
        <vdr-form-field label="Secret 1" for="secret1">
          <input id="secret1" type="text" formControlName="secret1" />
        </vdr-form-field>
        <vdr-form-field label="Secret 2" for="secret2">
          <input id="secret2" type="text" formControlName="secret2" />
        </vdr-form-field>
        <vdr-form-field label="Account" for="account">
          <input id="account" type="text" formControlName="account" />
        </vdr-form-field>
        <vdr-form-field label="Contra account" for="contraAccount">
          <input
            id="contraAccount"
            type="text"
            formControlName="contraAccount"
          />
        </vdr-form-field>
        <button
          class="btn btn-primary"
          (click)="save()"
          [disabled]="form.invalid || form.pristine"
        >
          Save
        </button>
      </section>
    </form>
  `,
})
export class EBoekhoudenComponent implements OnInit {
  form: FormGroup;
  testFailed?: string;
  testResultName?: string;
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService
  ) {
    this.form = this.formBuilder.group({
      enabled: ['enabled'],
      username: ['username'],
      secret1: ['secret1'],
      secret2: ['secret2'],
      account: ['account'],
      contraAccount: ['contraAccount'],
    });
  }
  async ngOnInit(): Promise<void> {
    await this.dataService
      .query(eBoekhoudenConfigQuery)
      .mapStream((result: any) => result.eBoekhoudenConfig)
      .subscribe((config) => this.setValues(config));
  }
  async save(): Promise<void> {
    try {
      if (this.form.dirty) {
        const formValue = this.form.value;
        const updateEBoekhoudenConfigRresult = await this.dataService
          .mutate<
            UpdateEBoekhoudenConfigMutation,
            UpdateEBoekhoudenConfigMutationVariables
          >(updateEBoekhoudenConfigMutation, {
            input: {
              ...formValue,
            },
          })
          .toPromise();
        this.setValues(updateEBoekhoudenConfigRresult?.updateEBoekhoudenConfig);
      }
      this.form.markAsPristine();
      this.changeDetector.markForCheck();
      this.notificationService.success('common.notify-update-success', {
        entity: 'Eboekhouden config',
      });
    } catch (e) {
      this.notificationService.error('common.notify-update-error', {
        entity: 'Eboekhouden config',
      });
    }
  }
  private setValues(values?: EBoekhoudenConfig | null): void {
    this.form.controls['enabled'].setValue(values?.enabled);
    this.form.controls['username'].setValue(values?.username);
    this.form.controls['secret1'].setValue(values?.secret1);
    this.form.controls['secret2'].setValue(values?.secret2);
    this.form.controls['account'].setValue(values?.account);
    this.form.controls['contraAccount'].setValue(values?.contraAccount);
  }
}
```

## File: packages/vendure-plugin-e-boekhouden/src/ui/e-boekhouden.module.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
import { EBoekhoudenComponent } from './e-boekhouden.component';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: EBoekhoudenComponent,
        data: { breadcrumb: 'e-Boekhouden' },
      },
    ]),
  ],
  providers: [],
  declarations: [EBoekhoudenComponent],
})
export class EBoekhoudenModule {}
```

## File: packages/vendure-plugin-e-boekhouden/src/ui/queries.graphql.ts

```typescript
import gql from 'graphql-tag';
export const updateEBoekhoudenConfigMutation = gql`
  mutation updateEBoekhoudenConfig($input: EBoekhoudenConfigInput!) {
    updateEBoekhoudenConfig(input: $input) {
      enabled
      username
      secret1
      secret2
      account
      contraAccount
    }
  }
`;
export const eBoekhoudenConfigQuery = gql`
  query eBoekhoudenConfig {
    eBoekhoudenConfig {
      enabled
      username
      secret1
      secret2
      account
      contraAccount
    }
  }
`;
```

## File: packages/vendure-plugin-e-boekhouden/src/constants.ts

```typescript
export const loggerCtx = 'EBoekhoudenPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('EBOEKHOUDEN_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-e-boekhouden/src/e-boekhouden.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import path from 'path';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { EBoekhoudenService } from './api/e-boekhouden.service';
import { EBoekhoudenConfigEntity } from './api/e-boekhouden-config.entity';
import { schema } from './api/schema.graphql';
import {
  EBoekhoudenResolver,
  eBoekhoudenPermission,
} from './api/e-boekhouden.resolver';
@VendurePlugin({
  imports: [PluginCommonModule],
  entities: [EBoekhoudenConfigEntity],
  providers: [EBoekhoudenService],
  adminApiExtensions: {
    schema,
    resolvers: [EBoekhoudenResolver],
  },
  configuration: (config) => {
    config.authOptions.customPermissions.push(eBoekhoudenPermission);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class EBoekhoudenPlugin {
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'e-boekhouden',
        ngModuleFileName: 'e-boekhouden.module.ts',
        ngModuleName: 'EBoekhoudenModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'e-boekhouden-nav.module.ts',
        ngModuleName: 'EBoekhoudenNavModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-e-boekhouden/src/index.ts

```typescript
export * from './ui/generated/graphql';
export * from './e-boekhouden.plugin';
export { recalculateTaxFromTotalIncVAT } from './api/e-boekhouden.adapter';
```

## File: packages/vendure-plugin-e-boekhouden/test/dev-server.ts

```typescript
require('dotenv').config();
import {
  createTestEnvironment,
  E2E_DEFAULT_CHANNEL_TOKEN,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  ChannelService,
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  mergeConfig,
  PaymentMethodService,
  RequestContext,
  LanguageCode,
  TaxRateService,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { EBoekhoudenPlugin } from '../src';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  addItem,
  addPaymentToOrder,
  proceedToArrangingPayment,
} from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { EBoekhoudenService } from '../src/api/e-boekhouden.service';
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    plugins: [
      EBoekhoudenPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  const channel = await server.app.get(ChannelService).getDefaultChannel();
  const ctx = new RequestContext({
    apiType: 'admin',
    isAuthorized: true,
    authorizedAsOwnerOnly: false,
    channel,
  });
  await server.app.get(PaymentMethodService).create(ctx, {
    code: 'test-payment-method',
    enabled: true,
    handler: {
      code: 'test-payment-method',
      arguments: [],
    },
    translations: [
      {
        languageCode: LanguageCode.en_US,
        description: '',
        name: 'test',
      },
    ],
  });
  await server.app.get(TaxRateService).update(ctx, { id: 2, value: 21 });
  await server.app
    .get(EBoekhoudenService)
    .upsertConfig(E2E_DEFAULT_CHANNEL_TOKEN, {
      enabled: true,
      account: '1010',
      contraAccount: '8010',
      username: process.env.EBOEKHOUDEN_USERNAME!,
      secret1: process.env.EBOEKHOUDEN_SECRET1!,
      secret2: process.env.EBOEKHOUDEN_SECRET2!,
    });
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await addItem(shopClient, 'T_1', 1);
  await addItem(shopClient, 'T_2', 1);
  await proceedToArrangingPayment(shopClient, 1, {
    input: {
      fullName: 'Martinho Pinelabio',
      streetLine1: 'Verzetsstraat',
      streetLine2: '12a',
      city: 'Liwwa',
      postalCode: '8923CP',
      countryCode: 'NL',
    },
  });
  await addPaymentToOrder(shopClient, testPaymentMethod.code);
})();
```

## File: packages/vendure-plugin-e-boekhouden/test/e-boekhouden.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import {
  DefaultLogger,
  LogLevel,
  mergeConfig,
  RequestContext,
  TaxRateService,
} from '@vendure/core';
import { TestServer } from '@vendure/testing/lib/test-server';
import {
  EBoekhoudenConfig,
  EBoekhoudenConfigQuery,
  EBoekhoudenPlugin,
  UpdateEBoekhoudenConfigMutation,
  UpdateEBoekhoudenConfigMutationVariables,
} from '../src';
import {
  eBoekhoudenConfigQuery,
  updateEBoekhoudenConfigMutation,
} from '../src/ui/queries.graphql';
import nock from 'nock';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { createSettledOrder } from '../../test/src/shop-utils';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
import path from 'path';
import * as fs from 'fs';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
describe('E-boekhouden plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  const eBoekhoudenConfig: EBoekhoudenConfig = {
    contraAccount: '8010',
    account: '1010',
    enabled: true,
    secret1: 'secret1234',
    secret2: 'secret456',
    username: 'testUsername',
  };
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        adminListQueryLimit: 10000,
        port: 3105,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [EBoekhoudenPlugin],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
  }, 60000);
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Should have 21% tax', async () => {
    const { value } = await server.app
      .get(TaxRateService)
      .update(RequestContext.empty(), { id: 2, value: 21 });
    expect(value).toBe(21);
  });
  it('Should get null', async () => {
    const { eBoekhoudenConfig: result } =
      await adminClient.query<EBoekhoudenConfigQuery>(eBoekhoudenConfigQuery);
    expect(result).toBeNull();
  });
  it('Should save config', async () => {
    const { updateEBoekhoudenConfig: result } = await adminClient.query<
      UpdateEBoekhoudenConfigMutation,
      UpdateEBoekhoudenConfigMutationVariables
    >(updateEBoekhoudenConfigMutation, { input: eBoekhoudenConfig });
    expect(result?.enabled).toBe(eBoekhoudenConfig.enabled);
    expect(result?.secret1).toBe(eBoekhoudenConfig.secret1);
    expect(result?.secret2).toBe(eBoekhoudenConfig.secret2);
    expect(result?.username).toBe(eBoekhoudenConfig.username);
    expect(result?.contraAccount).toBe(eBoekhoudenConfig.contraAccount);
    expect(result?.account).toBe(eBoekhoudenConfig.account);
  });
  it('Should get config', async () => {
    const { eBoekhoudenConfig: result } =
      await adminClient.query<EBoekhoudenConfigQuery>(eBoekhoudenConfigQuery);
    expect(result?.enabled).toBe(eBoekhoudenConfig.enabled);
    expect(result?.secret1).toBe(eBoekhoudenConfig.secret1);
    expect(result?.secret2).toBe(eBoekhoudenConfig.secret2);
    expect(result?.username).toBe(eBoekhoudenConfig.username);
  });
  it('Should send order to e-Boekhouden', async () => {
    const payloads: any = [];
    const savePayload = (body: any) => {
      payloads.push(body);
      return true;
    };
    nock(`http://soap.e-boekhouden.nl`)
      .post(/.*/, savePayload)
      .reply(200, openSessionMock);
    nock(`http://soap.e-boekhouden.nl`)
      .post(/.*/, savePayload)
      .reply(200, addMutatieMock);
    nock(`http://soap.e-boekhouden.nl`).post(/.*/, savePayload).reply(200);
    await createSettledOrder(shopClient, 1);
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(payloads.length).toBe(3);
    expect(payloads[1]).toContain('4957.37');
    expect(payloads[1]).toContain('4097.00');
    expect(payloads[1]).toContain('HOOG_VERK_21');
    expect(payloads[1]).toContain(eBoekhoudenConfig.account);
    expect(payloads[1]).toContain(eBoekhoudenConfig.contraAccount);
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        EBoekhoudenPlugin.ui
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
const openSessionMock = `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <soap:Body>
        <OpenSessionResponse xmlns="http://www.e-boekhouden.nl/soap">
            <OpenSessionResult>
                <ErrorMsg>
                    <LastErrorCode />
                    <LastErrorDescription />
                </ErrorMsg>
                <SessionID>{some-bogus-sessionId}</SessionID>
            </OpenSessionResult>
        </OpenSessionResponse>
    </soap:Body>
</soap:Envelope>`;
const addMutatieMock = `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <soap:Body>
        <AddMutatieResponse xmlns="http://www.e-boekhouden.nl/soap">
            <AddMutatieResult>
                <ErrorMsg>
                    <LastErrorCode/>
                    <LastErrorDescription/>
                </ErrorMsg>
                <Mutatienummer>12</Mutatienummer>
            </AddMutatieResult>
        </AddMutatieResponse>
    </soap:Body>
</soap:Envelope>`;
```

## File: packages/vendure-plugin-facet-suggestions/src/api/admin.resolver.ts

```typescript
import { Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Facet,
  Permission,
  RequestContext,
  TransactionalConnection,
  TranslatorService,
} from '@vendure/core';
@Resolver()
export class AdminResolver {
  constructor(
    private readonly connection: TransactionalConnection,
    private readonly translator: TranslatorService
  ) {}
  @Query()
  @Allow(Permission.ReadFacet, Permission.ReadCatalog, Permission.ReadProduct)
  async requiredFacets(@Ctx() ctx: RequestContext): Promise<Facet[]> {
    const qb = this.connection
      .getRepository(ctx, Facet)
      .createQueryBuilder('facet')
      .leftJoinAndSelect('facet.values', 'value')
      .leftJoinAndSelect(
        'facet.customFields.showOnProductDetailIf',
        'dependencies'
      )
      .leftJoinAndSelect('facet.translations', 'ft')
      .leftJoinAndSelect('value.translations', 'vt')
      .leftJoinAndSelect('value.facet', 'value_facet')
      .leftJoinAndSelect('value_facet.translations', 'vft')
      .groupBy('facet.id')
      .addGroupBy('value.id')
      .addGroupBy('value_facet.id')
      .addGroupBy('ft.id')
      .addGroupBy('vt.id')
      .addGroupBy('vft.id')
      .addGroupBy('dependencies.id')
      .having('count(dependencies.id) > 0')
      .orHaving('facet.customFields.showOnProductDetail = true');
    return await qb.getMany().then((facets) => {
      for (const facet of facets) {
        this.translator.translate(facet, ctx, ['values', ['values', 'facet']]);
      }
      return facets;
    });
  }
}
```

## File: packages/vendure-plugin-facet-suggestions/src/api/schema.graphql.ts

```typescript
import { gql } from 'graphql-tag';
export const adminApiExtensions = gql`
  extend type Query {
    requiredFacets: [Facet!]!
  }
`;
```

## File: packages/vendure-plugin-facet-suggestions/src/ui/suggested-facets-component/queries.graphql.ts

```typescript
import { gql } from 'graphql-tag';
export const GET_REQUIRED_FACETS = gql`
  query GetRequiredFacets {
    requiredFacets {
      id
      name
      customFields {
        showOnProductDetail
        showOnProductDetailIf {
          id
        }
      }
      values {
        id
        name
        facet {
          id
          name
        }
      }
    }
  }
`;
```

## File: packages/vendure-plugin-facet-suggestions/src/ui/suggested-facets-component/suggested-facets.component.ts

```typescript
import {
  CustomDetailComponent,
  DataService,
  SharedModule,
} from '@vendure/admin-ui/core';
import { FormGroup } from '@angular/forms';
import { combineLatest, Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { Component, OnInit } from '@angular/core';
import { unique } from '@vendure/common/lib/unique';
import { Facet } from '@vendure/common/lib/generated-types';
import { shareReplay } from 'rxjs/operators';
import { GET_REQUIRED_FACETS } from './queries.graphql';
import { FacetValue } from '@vendure/core';
type RequiredFacetValueStatus = 'complete' | 'incomplete';
@Component({
  imports: [SharedModule],
  standalone: true,
  selector: 'suggested-facets',
  templateUrl: `./suggested-facets.component.html`,
  styleUrls: [`./suggested-facets.component.scss`],
})
export class SuggestedFacetsComponent implements CustomDetailComponent, OnInit {
  detailForm: FormGroup;
  entity$: Observable<any>;
  status$: Observable<RequiredFacetValueStatus>;
  requiredFacets$: Observable<
    Array<{
      facet: Facet;
      selectedValues: FacetValue[];
    }>
  >;
  constructor(private dataService: DataService) {}
  ngOnInit() {
    const selectedFacetValueIds$ = this.detailForm
      .get(['facetValueIds'])!
      .valueChanges.pipe(
        startWith(this.detailForm.get(['facetValueIds'])!.value)
      );
    const possiblyRequiredFacets$ = this.dataService
      .query<any, any>(GET_REQUIRED_FACETS, {}, 'cache-first')
      .single$.pipe(
        map(({ requiredFacets }) =>
          requiredFacets.filter(
            ({ customFields }) =>
              customFields?.showOnProductDetail === true ||
              customFields?.showOnProductDetailIf?.length
          )
        )
      );
    this.requiredFacets$ = combineLatest([
      possiblyRequiredFacets$,
      selectedFacetValueIds$,
    ]).pipe(
      shareReplay(1),
      map(([facets, selectedFacetValueIds]) => {
        return facets
          .filter(
            ({ customFields }) =>
              customFields?.showOnProductDetail === true ||
              customFields?.showOnProductDetailIf?.find((f) =>
                selectedFacetValueIds.includes(f.id)
              )
          )
          .map((facet) => ({
            facet,
            selectedValues: facet.values.filter((value) =>
              selectedFacetValueIds.includes(value.id)
            ),
          }));
      })
    );
    this.status$ = this.requiredFacets$.pipe(
      map((items) =>
        items.every((i) => 0 < i.selectedValues.length)
          ? 'complete'
          : 'incomplete'
      )
    );
  }
  addFacetValue(facetValue: FacetValue) {
    const productGroup = this.getProductFormGroup();
    const currentFacetValueIds: string[] = productGroup.value.facetValueIds;
    productGroup.patchValue({
      facetValueIds: unique([...currentFacetValueIds, facetValue.id]),
    });
    productGroup.markAsDirty();
    productGroup.controls.facetValueIds.markAsDirty();
  }
  removeFacetValue(facetValue: FacetValue) {
    const productGroup = this.getProductFormGroup();
    const currentFacetValueIds: string[] = productGroup.value.facetValueIds;
    productGroup.patchValue({
      facetValueIds: unique([
        ...currentFacetValueIds.filter((id) => id !== facetValue.id),
      ]),
    });
    productGroup.markAsDirty();
    productGroup.controls.facetValueIds.markAsDirty();
  }
  private getProductFormGroup(): FormGroup {
    return this.detailForm as FormGroup;
  }
}
```

## File: packages/vendure-plugin-facet-suggestions/src/ui/providers.ts

```typescript
import { registerCustomDetailComponent } from '@vendure/admin-ui/core';
import { SuggestedFacetsComponent } from './suggested-facets-component/suggested-facets.component';
export default [
  registerCustomDetailComponent({
    locationId: 'product-detail',
    component: SuggestedFacetsComponent,
  }),
];
```

## File: packages/vendure-plugin-facet-suggestions/src/facet-suggestions.plugin.ts

```typescript
import {
  FacetValue,
  LanguageCode,
  PluginCommonModule,
  VendurePlugin,
} from '@vendure/core';
import { adminApiExtensions } from './api/schema.graphql';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { AdminResolver } from './api/admin.resolver';
@VendurePlugin({
  imports: [PluginCommonModule],
  configuration: (config) => {
    config.customFields.Facet.push(
      {
        name: 'showOnProductDetail',
        label: [
          {
            languageCode: LanguageCode.en,
            value: 'Show on product detail page',
          },
        ],
        description: [
          {
            languageCode: LanguageCode.en,
            value:
              'Always show this facet as suggestion on product detail pages',
          },
        ],
        type: 'boolean',
        nullable: true,
        public: false,
        ui: { tab: 'Show on product detail' },
      },
      {
        name: 'showOnProductDetailIf',
        label: [
          {
            languageCode: LanguageCode.en,
            value: 'Show if product has facets',
          },
        ],
        description: [
          {
            languageCode: LanguageCode.en,
            value:
              'Show as suggestion on product detail pages when the product has these facets',
          },
        ],
        type: 'relation',
        entity: FacetValue,
        list: true,
        public: false,
        ui: {
          component: 'facet-value-form-input',
          tab: 'Show on product detail',
        },
      }
    );
    return config;
  },
  adminApiExtensions: {
    schema: adminApiExtensions,
    resolvers: [AdminResolver],
  },
  compatibility: '>=2.2.0',
})
export class FacetSuggestionsPlugin {
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    providers: ['providers.ts'],
  };
}
```

## File: packages/vendure-plugin-facet-suggestions/src/index.ts

```typescript
export * from './facet-suggestions.plugin';
export * from './api/admin.resolver';
```

## File: packages/vendure-plugin-facet-suggestions/test/dev-server.ts

```typescript
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  dummyPaymentHandler,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { FacetSuggestionsPlugin } from '../src/';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { initialData } from '../../test/src/initial-data';
(async () => {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  const serverStarted = false;
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: true,
      shopApiPlayground: true,
    },
    plugins: [
      FacetSuggestionsPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [FacetSuggestionsPlugin.ui],
          devMode: true,
        }),
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [dummyPaymentHandler],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})().catch((err) => {
  console.error(err);
});
```

## File: packages/vendure-plugin-facet-suggestions/test/e2e.spec.ts

```typescript
import {
  DefaultLogger,
  Facet,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import nock from 'nock';
import { afterAll, afterEach, beforeAll, expect, it } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { initialData } from '../../test/src/initial-data';
import { FacetSuggestionsPlugin } from '../src';
import { GET_REQUIRED_FACETS } from '../src/ui/suggested-facets-component/queries.graphql';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let serverStarted = false;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [FacetSuggestionsPlugin],
  });
  ({ server, adminClient } = createTestEnvironment(config));
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  serverStarted = true;
}, 60000);
afterEach(() => nock.cleanAll());
it('Should start successfully', async () => {
  await expect(serverStarted).toBe(true);
});
it('Fetches required facets', async () => {
  await adminClient.asSuperAdmin();
  const { requiredFacets } = await adminClient.query(GET_REQUIRED_FACETS);
  await expect(requiredFacets).toEqual([]);
});
if (process.env.TEST_ADMIN_UI) {
  it('Should compile admin', async () => {
    const files = await getFilesInAdminUiFolder(
      __dirname,
      FacetSuggestionsPlugin.ui
    );
    expect(files?.length).toBeGreaterThan(0);
  }, 200000);
}
afterAll(async () => {
  await server.destroy();
}, 100000);
```

## File: packages/vendure-plugin-facet-suggestions/types.ts

```typescript
import { FacetValue } from '@vendure/core';
import { CustomFacetFields } from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomFacetFields {
    showOnProductDetail: boolean;
    showOnProductDetailIf: FacetValue[];
  }
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/api/api-extensions.ts

```typescript
import gql from 'graphql-tag';
export const adminApiExtensions = gql`
  type FrequentlyBoughtTogetherPreview {
    """
    The max memory used during the calculation.
    Make sure this doesn't exceed your worker's memory limit.
    process.memoryUsage().rss is used to calculate this.
    """
    maxMemoryUsedInMB: Int!
    """
    The total number of sets found.
    """
    totalItemSets: Int!
    """
    The number of unique products for which a related product was found
    """
    uniqueProducts: Int!
    """
    The item sets with the most support
    """
    bestItemSets: [FrequentlyBoughtTogetherItemSet!]!
    """
    The item sets with the worst support. If these make sense, the others probably do too.
    """
    worstItemSets: [FrequentlyBoughtTogetherItemSet!]!
  }
  """
  An item set with a support value.
  An item set is a combination of products which are frequently bought together, e.g. ['product-1', 'product-2', 'product-3']
  Support is the number of orders this combination was in
  """
  type FrequentlyBoughtTogetherItemSet {
    items: [String!]!
    support: Int!
  }
  extend type Query {
    """
    Preview the frequently bought together item sets,
    to check what level of support is reasonable for your data set
    """
    previewFrequentlyBoughtTogether(
      support: Float!
    ): FrequentlyBoughtTogetherPreview!
  }
  extend type Mutation {
    """
    Trigger the job to calculate and set frequently bought together products.
    """
    triggerFrequentlyBoughtTogetherCalculation: Boolean!
  }
`;
export const shopApiExtensions = gql`
  extend type Product {
    frequentlyBoughtWith: [Product!]!
  }
`;
```

## File: packages/vendure-plugin-frequently-bought-together/src/api/frequently-bought-together-admin.resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { Inject } from '@nestjs/common';
import { FrequentlyBoughtTogetherService } from '../services/frequently-bought-together.service';
import {
  FrequentlyBoughtTogetherPreview,
  QueryPreviewFrequentlyBoughtTogetherArgs,
} from '../generated-graphql-types';
import {
  Allow,
  Ctx,
  Permission,
  RequestContext,
  UserInputError,
} from '@vendure/core';
import { PluginInitOptions } from '../types';
import { FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS } from '../constants';
@Resolver()
export class FrequentlyBoughtTogetherAdminResolver {
  constructor(
    @Inject(FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS)
    private options: PluginInitOptions,
    private frequentlyBoughtTogetherService: FrequentlyBoughtTogetherService
  ) {}
  @Query()
  async previewFrequentlyBoughtTogether(
    @Ctx() ctx: RequestContext,
    @Args() { support }: QueryPreviewFrequentlyBoughtTogetherArgs
  ): Promise<FrequentlyBoughtTogetherPreview> {
    if (!this.options.experimentMode) {
      throw new UserInputError(
        `This query is only available in experiment mode. Set 'experementMode: true' in plugin's init()`
      );
    }
    return await this.frequentlyBoughtTogetherService.previewItemSets(
      ctx,
      support
    );
  }
  @Mutation()
  @Allow(Permission.UpdateSystem)
  async triggerFrequentlyBoughtTogetherCalculation(
    @Ctx() ctx: RequestContext
  ): Promise<boolean> {
    return await this.frequentlyBoughtTogetherService.triggerCalculation(ctx);
  }
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/api/frequently-bought-together-shop.resolver.ts

```typescript
import { Inject } from '@nestjs/common';
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { Ctx, Logger, Product, RequestContext } from '@vendure/core';
import {
  FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS,
  loggerCtx,
} from '../constants';
import { FrequentlyBoughtTogetherService } from '../services/frequently-bought-together.service';
import { PluginInitOptions } from '../types';
@Resolver()
export class FrequentlyBoughtTogetherShopResolver {
  constructor(
    @Inject(FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS)
    private options: PluginInitOptions,
    private frequentlyBoughtTogetherService: FrequentlyBoughtTogetherService
  ) {}
  @ResolveField('frequentlyBoughtWith')
  @Resolver('Product')
  async frequentlyBoughtWith(
    @Ctx() ctx: RequestContext,
    @Parent() product: Product
  ): Promise<Product[]> {
    const products =
      await this.frequentlyBoughtTogetherService.getSortedProducts(
        ctx,
        product
      );
    if (!this.options.hasValidLicense) {
      Logger.error(
        `Invalid license key, only returning the top 2 most frequently bought together products`,
        loggerCtx
      );
      return products.slice(0, 2);
    }
    return products;
  }
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/services/frequently-bought-together.service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import {
  EntityHydrator,
  ID,
  JobQueue,
  JobQueueService,
  Logger,
  OrderLine,
  Product,
  ProductService,
  RequestContext,
  SerializedRequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { asError } from 'catch-unknown';
import { FPGrowth } from 'node-fpgrowth';
import {
  FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS,
  loggerCtx,
} from '../constants';
import { FrequentlyBoughtTogetherPreview } from '../generated-graphql-types';
import {
  FrequentlyBoughtTogetherCalculationResult,
  PluginInitOptions,
  Support,
} from '../types';
import { getRelatedProductsPerProduct } from './util';
@Injectable()
export class FrequentlyBoughtTogetherService implements OnApplicationBootstrap {
  private jobQueue!: JobQueue<{
    ctx: SerializedRequestContext;
  }>;
  constructor(
    private connection: TransactionalConnection,
    @Inject(FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS)
    private options: PluginInitOptions,
    private jobQueueService: JobQueueService,
    private productService: ProductService,
    private entityHydrator: EntityHydrator
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'frequently-bought-together-calculation',
      process: async (job) =>
        this.createFrequentlyBoughtTogetherRelations(
          RequestContext.deserialize(job.data.ctx)
        ).catch((e) => {
          Logger.error(
            `Failed to calculate frequently bought together relations: ${
              asError(e).message
            }`,
            loggerCtx
          );
          throw e;
        }),
    });
  }
  async createFrequentlyBoughtTogetherRelations(
    ctx: RequestContext
  ): Promise<number> {
    const support =
      typeof this.options.supportLevel === 'function'
        ? this.options.supportLevel(ctx)
        : this.options.supportLevel;
    const { itemSets, uniqueProducts } = await this.getItemSets(ctx, support);
    const relatedProductsPerProduct = getRelatedProductsPerProduct(
      itemSets,
      this.options.maxRelatedProducts
    );
    for (const [
      productId,
      supportPerProduct,
    ] of relatedProductsPerProduct.entries()) {
      await this.connection.getRepository(ctx, Product).save({
        id: productId,
        customFields: {
          frequentlyBoughtWith: supportPerProduct.map((s) => ({
            id: s.productId,
          })),
          frequentlyBoughtWithSupport: JSON.stringify(supportPerProduct),
        },
      });
      Logger.debug(
        `Set frequently bought together products for '${productId}' to [${supportPerProduct
          .map((s) => s.productId)
          .join(',')}]`,
        loggerCtx
      );
    }
    Logger.info(
      `Set frequently bought together relations for ${relatedProductsPerProduct.size} products`,
      loggerCtx
    );
    return uniqueProducts;
  }
  async previewItemSets(
    ctx: RequestContext,
    support: number
  ): Promise<FrequentlyBoughtTogetherPreview> {
    const { itemSets, maxMemoryUsedInMB, uniqueProducts } =
      await this.getItemSets(ctx, support);
    const best = itemSets.slice(0, 10);
    const worst = itemSets.slice(-10);
    const bestAndWorstProductIds = [
      ...best.map((i) => i.items).flat(),
      ...worst.map((i) => i.items).flat(),
    ];
    const allProducts = bestAndWorstProductIds.length
      ? await this.productService.findByIds(ctx, bestAndWorstProductIds)
      : [];
    const bestItemSets = best.map((is) => ({
      items: is.items.map(
        (id) => allProducts.find((v) => v.id === id)?.name || String(id)
      ),
      support: is.support,
    }));
    const worstItemSets = worst.map((is) => ({
      items: is.items.map(
        (id) => allProducts.find((v) => v.id === id)?.name || String(id)
      ),
      support: is.support,
    }));
    return {
      maxMemoryUsedInMB,
      uniqueProducts,
      totalItemSets: itemSets.length,
      bestItemSets,
      worstItemSets,
    };
  }
  async getSortedProducts(
    ctx: RequestContext,
    product: Product
  ): Promise<Product[]> {
    await this.entityHydrator.hydrate(ctx, product, {
      relations: ['customFields.frequentlyBoughtWith'],
    });
    if (!product.customFields.frequentlyBoughtWith) {
      return [];
    }
    try {
      const supportPerProduct: Partial<Support>[] = JSON.parse(
        product.customFields.frequentlyBoughtWithSupport || '[]'
      );
      if (!Array.isArray(supportPerProduct)) {
        Logger.error(
          `product.customFields.frequentlyBoughtWithSupport for product '${product.id}' is not an array`,
          loggerCtx
        );
        return [];
      }
      return product.customFields.frequentlyBoughtWith?.sort((a, b) => {
        const supportA =
          supportPerProduct.find((s) => s.productId === a.id)?.support || 0;
        const supportB =
          supportPerProduct.find((s) => s.productId === b.id)?.support || 0;
        return supportB - supportA;
      });
    } catch (e) {
      Logger.error(
        `Failed to get sorted products: ${asError(e).message}`,
        loggerCtx
      );
      return [];
    }
  }
  private async getItemSets(
    ctx: RequestContext,
    support: number
  ): Promise<FrequentlyBoughtTogetherCalculationResult> {
    const rss = [0];
    rss.push(process.memoryUsage().rss);
    const result: Array<{ orderId: ID; productVariant_productId: ID }> =
      await this.connection
        .getRepository(ctx, OrderLine)
        .createQueryBuilder('orderLine')
        .innerJoin('orderLine.order', 'order')
        .innerJoin('orderLine.productVariant', 'productVariant')
        .innerJoin('order.channels', 'channel')
        .where('order.orderPlacedAt IS NOT NULL')
        .andWhere('channel.id = :channelId', { channelId: ctx.channelId })
        .andWhere('productVariant.deletedAt IS NULL')
        .select(['orderLine.orderId', 'productVariant.productId'])
        .orderBy('order.orderPlacedAt', 'DESC')
        .limit(500000)
        .getRawMany();
    rss.push(process.memoryUsage().rss);
    const transactions = new Map<ID, ID[]>();
    result.forEach((row) => {
      const transactionsForOrder = transactions.get(row.orderId) || [];
      const productId = row['productVariant_productId'];
      if (!transactionsForOrder.includes(productId)) {
        transactionsForOrder.push(productId);
        transactions.set(row.orderId, transactionsForOrder);
      }
    });
    rss.push(process.memoryUsage().rss);
    const matrix = Array.from(transactions.values());
    rss.push(process.memoryUsage().rss);
    const fpgrowth = new FPGrowth<ID>(support);
    rss.push(process.memoryUsage().rss);
    const itemSets = (await fpgrowth.exec(matrix))
      .filter((is) => is.items.length > 1)
      .sort((a, b) => b.support - a.support);
    rss.push(process.memoryUsage().rss);
    const totalUniqueProducts = new Set<ID>();
    itemSets.forEach((itemSet) => {
      itemSet.items.forEach((item) => {
        totalUniqueProducts.add(item);
      });
    });
    rss.push(process.memoryUsage().rss);
    const maxMemoryUsedInMB = Math.round(Math.max(...rss) / 1024 / 1024);
    Logger.info(
      `Found ${itemSets.length} item sets for ${totalUniqueProducts.size} products from ${matrix.length} orders and ${result.length} order lines. Max memory used: ${maxMemoryUsedInMB}MB`,
      loggerCtx
    );
    return {
      itemSets,
      maxMemoryUsedInMB,
      uniqueProducts: totalUniqueProducts.size,
    };
  }
  async triggerCalculation(ctx: RequestContext): Promise<boolean> {
    await this.jobQueue.add({ ctx: ctx.serialize() }, { retries: 5 });
    return true;
  }
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/services/util.spec.ts

```typescript
import { describe, it, expect } from 'vitest';
import { getRelatedProductsPerProduct } from './util';
describe('getRelatedProductsPerProduct', () => {
  const itemSets = [
    {
      support: 1,
      items: [1, 2, 3],
    },
    {
      support: 99,
      items: [2, 3, 4],
    },
    {
      support: 3,
      items: [1, 3, 4],
    },
  ];
  it('should return related products for a given product', () => {
    const result = getRelatedProductsPerProduct(itemSets, 3);
    expect(result.get(1)).toEqual([
      { productId: 3, support: 3 },
      { productId: 4, support: 3 },
      { productId: 2, support: 1 },
    ]);
    expect(result.get(2)).toEqual([
      { productId: 3, support: 99 },
      { productId: 4, support: 99 },
      { productId: 1, support: 1 },
    ]);
    expect(result.get(3)).toEqual([
      { productId: 2, support: 99 },
      { productId: 4, support: 99 },
      { productId: 1, support: 3 },
    ]);
    expect(result.get(4)).toEqual([
      { productId: 2, support: 99 },
      { productId: 3, support: 99 },
      { productId: 1, support: 3 },
    ]);
  });
  it('adheres to max related products', () => {
    const result = getRelatedProductsPerProduct(itemSets, 2);
    expect(result.get(1)).toEqual([
      { productId: 3, support: 3 },
      { productId: 4, support: 3 },
    ]);
  });
});
```

## File: packages/vendure-plugin-frequently-bought-together/src/services/util.ts

```typescript
import { ID } from '@vendure/core';
import { Itemset } from 'node-fpgrowth';
import { Support } from '../types';
export function getRelatedProductsPerProduct(
  itemSets: Itemset<ID>[],
  maxRelatedProducts: number
): Map<ID, Support[]> {
  itemSets.sort((a, b) => b.support - a.support);
  const relatedProductsPerProduct = new Map<ID, Support[]>();
  for (const itemSet of itemSets) {
    for (const productId of itemSet.items) {
      const relations = relatedProductsPerProduct.get(productId) || [];
      itemSet.items.forEach((itemId) => {
        const alreadyHasProduct = relations.some((r) => r.productId === itemId);
        if (alreadyHasProduct) {
          return;
        }
        if (itemId === productId) {
          return;
        }
        if (relations.length >= maxRelatedProducts) {
          return;
        }
        relations.push({ productId: itemId, support: itemSet.support });
      });
      relatedProductsPerProduct.set(productId, relations);
    }
  }
  return relatedProductsPerProduct;
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/ui/providers.ts

```typescript
import {
  addActionBarDropdownMenuItem,
  ModalService,
} from '@vendure/admin-ui/core';
import gql from 'graphql-tag';
export default [
  addActionBarDropdownMenuItem({
    id: 'generate-frequently-bought-together',
    label: 'Calculate frequently-bought-together relations',
    locationId: 'product-list',
    icon: 'switch',
    onClick: async (event, { dataService, notificationService, injector }) => {
      dataService
        .mutate(
          gql`
            mutation TriggerFrequentlyBoughtTogetherCalculation {
              triggerFrequentlyBoughtTogetherCalculation
            }
          `
        )
        .subscribe({
          next: () => {
            notificationService.success('Calculation triggered');
          },
          error: (err) => {
            notificationService.error(
              `Error starting calculation: ${err.message}`
            );
          },
        });
    },
  }),
];
```

## File: packages/vendure-plugin-frequently-bought-together/src/constants.ts

```typescript
export const FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS = Symbol(
  'FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS'
);
export const loggerCtx = 'FrequentlyBoughtTogetherPlugin';
```

## File: packages/vendure-plugin-frequently-bought-together/src/custom-fields-types.ts

```typescript
import { Product } from '@vendure/core';
import { CustomProductFields } from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core' {
  interface CustomProductFields {
    frequentlyBoughtWith?: Product[];
    frequentlyBoughtWithSupport?: string;
  }
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/frequently-bought-together.plugin.ts

```typescript
import {
  LanguageCode,
  Logger,
  PluginCommonModule,
  Product,
  Type,
  VendurePlugin,
} from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import {
  FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS,
  loggerCtx,
} from './constants';
import { FrequentlyBoughtTogetherService } from './services/frequently-bought-together.service';
import { PluginInitOptions } from './types';
import path from 'path';
import { adminApiExtensions, shopApiExtensions } from './api/api-extensions';
import { FrequentlyBoughtTogetherAdminResolver } from './api/frequently-bought-together-admin.resolver';
import { OnApplicationBootstrap } from '@nestjs/common';
import {
  LicenseService,
  VendureHubPlugin,
} from '@vendure-hub/vendure-hub-plugin';
import { asError } from 'catch-unknown';
import { FrequentlyBoughtTogetherShopResolver } from './api/frequently-bought-together-shop.resolver';
export type FrequentlyBoughtTogetherPluginOptions = Partial<
  Omit<PluginInitOptions, 'hasValidLicense'>
> &
  Pick<PluginInitOptions, 'licenseKey'>;
@VendurePlugin({
  imports: [PluginCommonModule, VendureHubPlugin],
  providers: [
    {
      provide: FREQUENTLY_BOUGHT_TOGETHER_PLUGIN_OPTIONS,
      useFactory: () => FrequentlyBoughtTogetherPlugin.options,
    },
    FrequentlyBoughtTogetherService,
  ],
  configuration: (config) => {
    config.customFields.Product.push({
      name: 'frequentlyBoughtWith',
      type: 'relation',
      label: [
        { languageCode: LanguageCode.en, value: 'Frequently bought with' },
      ],
      description: [
        {
          languageCode: LanguageCode.en,
          value:
            'Products that are frequently bought together with the current product',
        },
      ],
      list: true,
      entity: Product,
      public: false,
      readonly: false,
      eager: false,
      nullable: true,
      ui: { tab: FrequentlyBoughtTogetherPlugin.options.customFieldUiTab },
    });
    config.customFields.Product.push({
      name: 'frequentlyBoughtWithSupport',
      type: 'text',
      internal: true,
      public: false,
      nullable: true,
    });
    return config;
  },
  compatibility: '>=2.2.0',
  adminApiExtensions: {
    schema: adminApiExtensions,
    resolvers: [FrequentlyBoughtTogetherAdminResolver],
  },
  shopApiExtensions: {
    schema: shopApiExtensions,
    resolvers: [FrequentlyBoughtTogetherShopResolver],
  },
})
export class FrequentlyBoughtTogetherPlugin implements OnApplicationBootstrap {
  static options: PluginInitOptions = {
    licenseKey: '',
    customFieldUiTab: 'Related products',
    experimentMode: false,
    supportLevel: 0.01,
    maxRelatedProducts: 10,
    hasValidLicense: false,
  };
  constructor(private licenseService: LicenseService) {}
  onApplicationBootstrap() {
    this.licenseService
      .checkLicenseKey(
        FrequentlyBoughtTogetherPlugin.options.licenseKey,
        '@vendure-hub/pinelab-frequently-bought-together-plugin'
      )
      .then((result) => {
        if (!result.valid) {
          Logger.error(
            `Your license key is invalid. Make sure to obtain a valid license key from the Vendure Hub if you want to keep using this plugin.`,
            loggerCtx
          );
          FrequentlyBoughtTogetherPlugin.options.hasValidLicense = false;
        } else {
          FrequentlyBoughtTogetherPlugin.options.hasValidLicense = true;
        }
      })
      .catch((err) => {
        Logger.error(
          `Error checking license key: ${
            asError(err).message
          }. Some functionality might be disabled`,
          loggerCtx
        );
        FrequentlyBoughtTogetherPlugin.options.hasValidLicense = false;
      });
  }
  static init(
    options: FrequentlyBoughtTogetherPluginOptions
  ): Type<FrequentlyBoughtTogetherPlugin> {
    this.options = {
      ...this.options,
      ...options,
    };
    return FrequentlyBoughtTogetherPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    providers: ['providers.ts'],
  };
}
```

## File: packages/vendure-plugin-frequently-bought-together/src/generated-graphql-types.ts

```typescript
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};
export type FrequentlyBoughtTogetherItemSet = {
  __typename?: 'FrequentlyBoughtTogetherItemSet';
  items: Array<Scalars['String']>;
  support: Scalars['Int'];
};
export type FrequentlyBoughtTogetherPreview = {
  __typename?: 'FrequentlyBoughtTogetherPreview';
  bestItemSets: Array<FrequentlyBoughtTogetherItemSet>;
  maxMemoryUsedInMB: Scalars['Int'];
  totalItemSets: Scalars['Int'];
  uniqueProducts: Scalars['Int'];
  worstItemSets: Array<FrequentlyBoughtTogetherItemSet>;
};
export type Mutation = {
  __typename?: 'Mutation';
  triggerFrequentlyBoughtTogetherCalculation: Scalars['Boolean'];
};
export type Product = {
  __typename?: 'Product';
  frequentlyBoughtWith: Array<Product>;
};
export type Query = {
  __typename?: 'Query';
  previewFrequentlyBoughtTogether: FrequentlyBoughtTogetherPreview;
};
export type QueryPreviewFrequentlyBoughtTogetherArgs = {
  support: Scalars['Float'];
};
```

## File: packages/vendure-plugin-frequently-bought-together/src/index.ts

```typescript
export * from './frequently-bought-together.plugin';
export * from './custom-fields-types';
```

## File: packages/vendure-plugin-frequently-bought-together/src/types.ts

```typescript
import { ID, RequestContext } from '@vendure/core';
import { Itemset } from 'node-fpgrowth';
export interface PluginInitOptions {
  licenseKey: string;
  customFieldUiTab: string;
  experimentMode: boolean;
  supportLevel: number | ((ctx: RequestContext) => number);
  hasValidLicense: boolean;
  maxRelatedProducts: number;
}
export interface FrequentlyBoughtTogetherCalculationResult {
  itemSets: Itemset<ID>[];
  maxMemoryUsedInMB: number;
  uniqueProducts: number;
}
export interface Support {
  productId: ID;
  support: number;
}
```

## File: packages/vendure-plugin-frequently-bought-together/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { FrequentlyBoughtTogetherPlugin } from '../src';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      FrequentlyBoughtTogetherPlugin.init({
        licenseKey: `123`,
        experimentMode: true,
        supportLevel: 0.001,
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [FrequentlyBoughtTogetherPlugin.ui],
          devMode: true,
        }),
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: './test/products-import.csv',
  });
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_1', quantity: 1 },
    { id: 'T_2', quantity: 1 },
  ]);
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_1', quantity: 1 },
    { id: 'T_3', quantity: 1 },
  ]);
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_1', quantity: 1 },
    { id: 'T_3', quantity: 1 },
  ]);
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_2', quantity: 1 },
    { id: 'T_3', quantity: 1 },
  ]);
})();
```

## File: packages/vendure-plugin-frequently-bought-together/test/e2e.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import {
  DefaultLogger,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { TestServer } from '@vendure/testing/lib/test-server';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
import { FrequentlyBoughtTogetherPlugin } from '../src';
import gql from 'graphql-tag';
import { GetProductById, UpdateProductMutation } from './queries';
import { createSettledOrder } from '../../test/src/shop-utils';
import { waitFor } from '../../test/src/test-helpers';
import { testPaymentMethod } from '../../test/src/test-payment-method';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      FrequentlyBoughtTogetherPlugin.init({
        licenseKey: '123',
      }),
    ],
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  const serverStart = server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: './test/products-import.csv',
  });
  await expect(serverStart).resolves.toEqual(undefined);
}, 60000);
afterAll(() => {
  return server.destroy();
});
it('Server should start', async () => {
  await expect(server.app.getHttpServer()).toBeDefined();
});
it('Manually adds a related product', async () => {
  await adminClient.asSuperAdmin();
  const { updateProduct } = await adminClient.query(UpdateProductMutation, {
    input: {
      id: 'T_1',
      customFields: {
        frequentlyBoughtWithIds: ['T_1'],
      },
    },
  });
  expect(updateProduct.customFields.frequentlyBoughtWith[0].id).toEqual('T_1');
});
it('Exposes the related product via the Shop API', async () => {
  const { product } = await shopClient.query(GetProductById, { id: 'T_1' });
  expect(product.frequentlyBoughtWith[0].id).toBe('T_1');
  expect(product.frequentlyBoughtWith[0].name).toBe('Laptop');
});
it('Places sample orders', async () => {
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_1', quantity: 1 },
    { id: 'T_3', quantity: 1 },
  ]);
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_1', quantity: 1 },
    { id: 'T_2', quantity: 1 },
    { id: 'T_3', quantity: 1 },
  ]);
  await createSettledOrder(shopClient, 1, true, [
    { id: 'T_2', quantity: 1 },
    { id: 'T_3', quantity: 1 },
  ]);
});
it('Triggers bought together calculation via admin API', async () => {
  await adminClient.query(
    gql`
      mutation {
        triggerFrequentlyBoughtTogetherCalculation
      }
    `
  );
  await waitFor(async () => {
    const { product } = await shopClient.query(GetProductById, { id: 'T_1' });
    if (product.frequentlyBoughtWith.length >= 2) {
      return product;
    }
  });
});
it('Get sorted relations via shop API', async () => {
  const { product: product1 } = await shopClient.query(GetProductById, {
    id: 'T_1',
  });
  expect(product1.frequentlyBoughtWith.length).toBe(2);
  expect(product1.frequentlyBoughtWith[0].id).toBe('T_3');
  expect(product1.frequentlyBoughtWith[1].id).toBe('T_2');
  const { product: product2 } = await shopClient.query(GetProductById, {
    id: 'T_2',
  });
  expect(product2.frequentlyBoughtWith.length).toBe(2);
  expect(product2.frequentlyBoughtWith[0].id).toBe('T_3');
  expect(product2.frequentlyBoughtWith[1].id).toBe('T_1');
});
```

## File: packages/vendure-plugin-frequently-bought-together/test/queries.ts

```typescript
import gql from 'graphql-tag';
export const UpdateProductMutation = gql`
  mutation UpdateProduct($input: UpdateProductInput!) {
    updateProduct(input: $input) {
      id
      customFields {
        frequentlyBoughtWith {
          id
          name
        }
      }
    }
  }
`;
export const GetProductById = gql`
  query GetProduct($id: ID!) {
    product(id: $id) {
      id
      frequentlyBoughtWith {
        id
        name
      }
    }
  }
`;
```

## File: packages/vendure-plugin-goedgepickt/src/api/goedgepickt.client.ts

```typescript
import fetch from 'node-fetch';
import {
  GoedgepicktEvent,
  Order,
  OrderInput,
  Product,
  ProductInput,
  Webhook,
} from './goedgepickt.types';
import { Logger } from '@vendure/core';
import crypto from 'crypto';
import { loggerCtx } from '../constants';
interface RawRequestInput {
  entity: 'products' | 'orders' | 'webhooks' | 'webshops';
  method: 'POST' | 'GET' | 'PUT' | 'DELETE';
  payload?: Object;
  queryParams?: string;
  pathParam?: string;
}
export interface ClientInput {
  apiKey: string;
  webshopUuid: string;
}
export class GoedgepicktClient {
  private readonly headers: Record<string, string>;
  constructor(private readonly config: ClientInput) {
    this.headers = {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      Authorization: `Bearer ${config.apiKey}`,
    };
  }
  async getProducts(page = 1): Promise<Product[]> {
    const result = await this.rawRequest({
      entity: 'products',
      method: 'GET',
      queryParams: `perPage=100&page=${page}`,
    });
    Logger.debug(
      `Fetched ${result.items?.length} products from Goedgepickt`,
      loggerCtx
    );
    return result.items as Product[];
  }
  async getAllProducts(): Promise<Product[]> {
    const products: Product[] = [];
    let page = 1;
    while (true) {
      const results = await this.getProducts(page);
      if (results && Array.isArray(results)) {
        products.push(...results);
      }
      if (!results || results.length < 100) {
        break;
      }
      page++;
    }
    return products;
  }
  async getWebhooks(): Promise<Webhook[]> {
    const { items }: { items: Webhook[] } = await this.rawRequest({
      entity: 'webhooks',
      method: 'GET',
    });
    if (!items) {
      return [];
    }
    Logger.debug(
      `Fetched ${items?.length} webhooks from Goedgepickt`,
      loggerCtx
    );
    return items.filter((item) => item.webshopUuid === this.config.webshopUuid);
  }
  async createProduct(product: ProductInput): Promise<Product[]> {
    const result = await this.rawRequest({
      entity: 'products',
      method: 'POST',
      payload: product,
    });
    Logger.debug(
      `Created product ${result.items?.[0]?.uuid} in Goedgepickt`,
      loggerCtx
    );
    return result.items as Product[];
  }
  async findProductBySku(sku: string): Promise<Product | undefined> {
    const result = await this.rawRequest({
      entity: 'products',
      method: 'GET',
      queryParams: `searchAttribute=sku&searchDelimiter=%3D&searchValue=${sku}`,
    });
    const foundProduct = result.items?.[0];
    if (result.items.length > 1) {
      Logger.warn(
        `Found multiple products with sku ${sku} in Goedgepickt, using '${foundProduct.uuid}'`,
        loggerCtx
      );
    }
    return foundProduct;
  }
  async updateProduct(uuid: string, product: ProductInput): Promise<Product[]> {
    const result = await this.rawRequest({
      entity: 'products',
      method: 'PUT',
      payload: product,
      pathParam: `${uuid}`,
    });
    Logger.debug(`Updated product ${uuid} in Goedgepickt`, loggerCtx);
    return result.items as Product[];
  }
  async createWebhook(input: {
    webhookEvent: GoedgepicktEvent;
    targetUrl: string;
  }): Promise<Webhook> {
    const result = await this.rawRequest({
      entity: 'webhooks',
      method: 'POST',
      payload: input,
    });
    Logger.info(
      `Set webhook for event ${input.webhookEvent} to url ${input.targetUrl}`,
      loggerCtx
    );
    return result;
  }
  async createOrder(order: OrderInput): Promise<Order> {
    const result = await this.rawRequest({
      entity: 'orders',
      method: 'POST',
      payload: order,
    });
    Logger.info(
      `Created order ${order.orderId} in Goedgepickt with uuid ${result.orderUuid}`,
      loggerCtx
    );
    return result;
  }
  async getOrder(uuid: string): Promise<Order> {
    const result = await this.rawRequest({
      entity: 'orders',
      method: 'GET',
      pathParam: uuid,
    });
    return result as Order;
  }
  async rawRequest(input: RawRequestInput): Promise<any> {
    const queryExtension = input.queryParams ? `?${input.queryParams}` : '';
    const pathParam = input.pathParam ? `/${input.pathParam}` : '';
    const response = await fetch(
      `https://account.goedgepickt.nl/api/v1/${input.entity}${pathParam}${queryExtension}`,
      {
        method: input.method,
        headers: this.headers,
        body:
          input.payload && input.method !== 'GET'
            ? JSON.stringify({
                webshopUuid: this.config.webshopUuid,
                ...input.payload,
              })
            : undefined,
        redirect: 'follow',
      }
    );
    const json = (await response.json()) as any;
    if (response.ok) {
      return json;
    }
    throw Error(json.error || json.errorMessage || json.message);
  }
}
```

## File: packages/vendure-plugin-goedgepickt/src/api/goedgepickt.controller.ts

```typescript
import {
  Body,
  Controller,
  Get,
  Headers,
  Inject,
  Param,
  Post,
  Req,
} from '@nestjs/common';
import { Channel, Logger, TransactionalConnection } from '@vendure/core';
import { Request } from 'express';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { GoedgepicktService } from './goedgepickt.service';
import {
  GoedgepicktPluginConfig,
  IncomingOrderStatusEvent,
  IncomingStockUpdateEvent,
} from './goedgepickt.types';
@Controller('goedgepickt')
export class GoedgepicktController {
  constructor(
    private service: GoedgepicktService,
    private connection: TransactionalConnection,
    @Inject(PLUGIN_INIT_OPTIONS) private config: GoedgepicktPluginConfig
  ) {}
  @Get('fullsync/:secret')
  async sync(@Param('secret') secret: string): Promise<void> {
    if (secret !== this.config.endpointSecret) {
      Logger.warn(
        `Invalid incoming fullsync request with secret ${secret}`,
        loggerCtx
      );
      return;
    }
    const channels = await this.connection.getRepository(Channel).find();
    for (const channel of channels.filter((c) => c.customFields?.ggEnabled)) {
      await this.service.createFullsyncJobs(channel.token).catch((err) => {
        Logger.error(
          `Failed to create fullsync jobs for channel ${channel.id}: ${err.message}`,
          loggerCtx
        );
      });
    }
  }
  @Post('webhook/:channelToken')
  async webhook(
    @Param('channelToken') channelToken: string,
    @Req() req: Request,
    @Body() body: IncomingStockUpdateEvent | IncomingOrderStatusEvent,
    @Headers('signature') signature: string
  ) {
    Logger.info(
      `Incoming event ${body?.event} for channel ${channelToken}`,
      loggerCtx
    );
    if (!signature) {
      return Logger.warn(
        `Ignoring incoming event without signature for channel ${channelToken}`,
        loggerCtx
      );
    }
    if (!channelToken) {
      return Logger.warn(
        `Ignoring incoming event without channelToken`,
        loggerCtx
      );
    }
    try {
      const ctx = await this.service.getCtxForChannel(channelToken);
      switch (body.event) {
        case 'orderStatusChanged':
          await this.service.handleIncomingOrderStatusUpdate(
            ctx,
            body.orderNumber,
            body.orderUuid
          );
          break;
        case 'stockUpdated':
          await this.service.handleIncomingStockUpdate(ctx, body.productSku);
          break;
        default:
          return Logger.warn(
            `Unknown incoming event: ${JSON.stringify(body)}`,
            loggerCtx
          );
      }
      Logger.info(
        `Successfully processed webhook with event ${body.event} for channel ${channelToken}`,
        loggerCtx
      );
    } catch (err: any) {
      Logger.error(
        `Failed to process incoming webhook ${body?.event} for channel ${channelToken}: ${err?.message}`,
        loggerCtx,
        JSON.stringify(err, Object.getOwnPropertyNames(err))
      );
      throw err;
    }
    return;
  }
}
```

## File: packages/vendure-plugin-goedgepickt/src/api/goedgepickt.handler.ts

```typescript
import { FulfillmentHandler, LanguageCode, Logger } from '@vendure/core';
import { GoedgepicktService } from './goedgepickt.service';
import { loggerCtx } from '../constants';
let service: GoedgepicktService;
export const goedgepicktHandler = new FulfillmentHandler({
  code: 'goedgepickt',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Send order to Goedgepickt',
    },
  ],
  args: {
    goedGepicktOrderUUID: {
      type: 'string',
      required: false,
    },
    trackingCode: {
      type: 'string',
      required: false,
    },
    trackingUrls: {
      type: 'string',
      required: false,
    },
  },
  init: (injector) => {
    service = injector.get(GoedgepicktService);
  },
  createFulfillment: async (ctx, orders, orderItems, args) => {
    const orderCodes = orders.map((o) => o.code);
    Logger.info(`Fulfilled orders ${orderCodes.join(',')}`, loggerCtx);
    return {
      method: `GoedGepickt - ${args.trackingCode}`,
      trackingCode: args.trackingCode,
      customFields: {
        trackingUrls: args.trackingUrls,
      },
    };
  },
});
```

## File: packages/vendure-plugin-goedgepickt/src/api/goedgepickt.resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Permission,
  RequestContext,
  PermissionDefinition,
} from '@vendure/core';
import {
  GoedgepicktConfig,
  GoedgepicktPluginConfig,
  MutationSyncOrderToGoedgepicktArgs,
} from '../index';
import { GoedgepicktService } from './goedgepickt.service';
import { PLUGIN_INIT_OPTIONS } from '../constants';
import { Inject } from '@nestjs/common';
export const goedgepicktPermission = new PermissionDefinition({
  name: 'SetGoedgepicktConfig',
  description: 'Allows setting Goedgepickt configurations',
});
@Resolver()
export class GoedgepicktResolver {
  constructor(
    private service: GoedgepicktService,
    @Inject(PLUGIN_INIT_OPTIONS) private pluginConfig: GoedgepicktPluginConfig
  ) {}
  @Mutation()
  @Allow(goedgepicktPermission.Permission)
  async runGoedgepicktFullSync(@Ctx() ctx: RequestContext): Promise<boolean> {
    const channelToken = ctx.channel.token;
    await this.service.createFullsyncJobs(channelToken);
    if (this.pluginConfig.setWebhook) {
      await this.service.registerWebhooks(ctx);
    }
    return true;
  }
  @Mutation()
  @Allow(Permission.UpdateOrder)
  async syncOrderToGoedgepickt(
    @Ctx() ctx: RequestContext,
    @Args() input: MutationSyncOrderToGoedgepicktArgs
  ): Promise<boolean> {
    await this.service.syncOrder(ctx, input.orderCode);
    return true;
  }
}
```

## File: packages/vendure-plugin-goedgepickt/src/api/goedgepickt.service.ts

```typescript
import {
  Inject,
  Injectable,
  OnApplicationBootstrap,
  OnModuleInit,
} from '@nestjs/common';
import {
  ChannelService,
  ConfigService,
  EntityHydrator,
  EventBus,
  HistoryService,
  ID,
  JobQueue,
  JobQueueService,
  ListQueryBuilder,
  Logger,
  Order,
  OrderPlacedEvent,
  OrderService,
  ProductPriceApplicator,
  ProductVariant,
  ProductVariantEvent,
  ProductVariantService,
  RequestContext,
  SerializedRequestContext,
  StockLevel,
  StockLevelService,
  TransactionalConnection,
  Translated,
  translateDeep,
  UserInputError,
} from '@vendure/core';
import { IsNull } from 'typeorm';
import util from 'util';
import { transitionToDelivered } from '../../../util/src';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { GoedgepicktClient } from './goedgepickt.client';
import { goedgepicktHandler } from './goedgepickt.handler';
import {
  Order as GgOrder,
  GoedgepicktEvent,
  GoedgepicktPluginConfig,
  OrderInput,
  OrderItemInput,
  ProductInput,
} from './goedgepickt.types';
interface StockInput {
  variantId: ID;
  stock: number;
}
type VariantWithImage = {
  id: ID;
  productId: ID;
  sku: string;
  name: string;
  price: number;
  absoluteImageUrl?: string;
};
interface PushProductJobData {
  action: 'push-product';
  ctx: SerializedRequestContext;
  products: ProductInput[];
}
interface PushProductByVariantsJobData {
  action: 'push-product-by-variants';
  ctx: SerializedRequestContext;
  variants: ProductVariant[];
}
interface SyncOrderJobData {
  action: 'sync-order';
  ctx: SerializedRequestContext;
  orderCode: string;
}
type JobData =
  | PushProductJobData
  | PushProductByVariantsJobData
  | SyncOrderJobData;
@Injectable()
export class GoedgepicktService
  implements OnApplicationBootstrap, OnModuleInit
{
  readonly queryLimit: number;
  private jobQueue!: JobQueue<JobData>;
  constructor(
    private variantService: ProductVariantService,
    private channelService: ChannelService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: GoedgepicktPluginConfig,
    private configService: ConfigService,
    private stockLevelService: StockLevelService,
    private connection: TransactionalConnection,
    private jobQueueService: JobQueueService,
    private orderService: OrderService,
    private entityHydrator: EntityHydrator,
    private listQueryBuilder: ListQueryBuilder,
    private eventBus: EventBus,
    private productPriceApplicator: ProductPriceApplicator,
    private historyService: HistoryService
  ) {
    this.queryLimit = configService.apiOptions.adminListQueryLimit;
  }
  async onModuleInit() {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'goedgepickt-sync',
      process: async ({ data, id }) => {
        try {
          const ctx = RequestContext.deserialize(data.ctx);
          if (data.action === 'sync-order') {
            await this.syncOrder(ctx, data.orderCode);
          } else if (data.action === 'push-product') {
            await this.handlePushProductJob(ctx, data);
          } else if (data.action === 'push-product-by-variants') {
            await this.handlePushByVariantsJob(ctx, data);
          } else {
            return Logger.error(
              `Invalid jobqueue action '${JSON.stringify(data)}'`,
              loggerCtx
            );
          }
        } catch (error) {
          if (
            error instanceof Error &&
            error.message.includes('Too Many Attempts')
          ) {
            Logger.info(
              `Failed to process job ${data.action} (${id}) for channel ${data.ctx._channel.token}: ${error}`,
              loggerCtx
            );
            throw error;
          }
          const loggableData = {
            ...data,
            ctx: undefined,
          };
          Logger.warn(
            `Failed to process job ${data.action} (${id}) for channel ${
              data.ctx._channel.token
            }: ${error}. Job data: ${util.inspect(loggableData, false, 5)}`,
            loggerCtx
          );
          throw error;
        }
      },
    });
  }
  async onApplicationBootstrap(): Promise<void> {
    this.eventBus.ofType(OrderPlacedEvent).subscribe(async (event) => {
      await this.jobQueue.add(
        {
          action: 'sync-order',
          orderCode: event.order.code,
          ctx: event.ctx.serialize(),
        },
        { retries: 10 }
      );
    });
    this.eventBus
      .ofType(ProductVariantEvent)
      .subscribe(async ({ ctx, entity, type, input }) => {
        if (type !== 'created' && type !== 'updated') {
          return;
        }
        const batches = this.getBatches(entity, 15);
        for (const batch of batches) {
          await this.jobQueue.add(
            {
              action: 'push-product-by-variants',
              ctx: ctx.serialize(),
              variants: batch,
            },
            { retries: 20 }
          );
          Logger.info(
            `Added ${entity.length} to 'push-product-by-variants' queue, because they were ${type}`,
            loggerCtx
          );
        }
      });
  }
  async registerWebhooks(ctx: RequestContext): Promise<undefined> {
    const client = this.getClientForChannel(ctx);
    if (!client) {
      return;
    }
    const webhookTarget = this.getWebhookUrl(ctx.channel.token);
    const webhooks = await client.getWebhooks();
    const orderStatusWebhook = webhooks.find(
      (webhook) =>
        webhook.targetUrl === webhookTarget &&
        webhook.webhookEvent === GoedgepicktEvent.orderStatusChanged
    );
    const stockWebhook = webhooks.find(
      (webhook) =>
        webhook.targetUrl === webhookTarget &&
        webhook.webhookEvent === GoedgepicktEvent.stockChanged
    );
    if (!orderStatusWebhook) {
      const created = await client.createWebhook({
        webhookEvent: GoedgepicktEvent.orderStatusChanged,
        targetUrl: webhookTarget,
      });
      Logger.info(
        `Created OrderStatusWebhook '${created.webhookUuid}' because it didn't exist.`,
        loggerCtx
      );
    } else {
      Logger.info(`OrderStatusWebhook already present`, loggerCtx);
    }
    if (!stockWebhook) {
      const created = await client.createWebhook({
        webhookEvent: GoedgepicktEvent.stockChanged,
        targetUrl: webhookTarget,
      });
      Logger.info(
        `Created StockWebhook '${created.webhookUuid}' because it didn't exist.`,
        loggerCtx
      );
    } else {
      Logger.info(`StockWebhook already present`, loggerCtx);
    }
  }
  async handleIncomingStockUpdate(
    ctx: RequestContext,
    productSku: string
  ): Promise<void> {
    const client = this.getClientForChannel(ctx);
    if (!client) {
      return;
    }
    const ggProduct = await client.findProductBySku(productSku);
    if (!ggProduct) {
      Logger.warn(
        `Product with sku '${productSku}' doesn't exists in GoedGepickt. Ignoring incoming stock update event`,
        loggerCtx
      );
      return;
    }
    const ggStock = ggProduct.stock?.freeStock;
    if (!ggStock) {
      Logger.warn(
        `Product with sku '${productSku}' has no freeStock in GoedGepickt. Ignoring incoming stock update event`,
        loggerCtx
      );
      return;
    }
    const variants = await this.getVariants(ctx, productSku);
    const stockInput: StockInput[] = variants.map((v) => ({
      variantId: v.id as string,
      stock: ggStock,
    }));
    await this.updateStock(ctx, stockInput);
    Logger.info(
      `Updated stock for ${productSku} to ${ggStock} via incoming event`,
      loggerCtx
    );
  }
  private async createOrder(
    ctx: RequestContext,
    order: Order
  ): Promise<GgOrder | undefined> {
    try {
      const client = this.getClientForChannel(ctx);
      if (!client) {
        return undefined;
      }
      const orderItems: OrderItemInput[] = order.lines.map((orderLine) => ({
        sku: orderLine.productVariant.sku,
        productName: orderLine.productVariant.name,
        productQuantity: orderLine.quantity,
        taxRate: orderLine.taxRate,
      }));
      if (
        !order.shippingAddress.streetLine2 ||
        !order.shippingAddress.streetLine1
      ) {
        throw Error(
          `Missing required order fields streetLine1, streetLine2. Cannot push order to GoedGepickt`
        );
      }
      const { houseNumber, addition } =
        GoedgepicktService.splitHouseNumberAndAddition(
          order.shippingAddress.streetLine2
        );
      const billingAddress =
        order.billingAddress && order.billingAddress.streetLine1
          ? order.billingAddress
          : order.shippingAddress;
      const { houseNumber: billingHouseNumber, addition: billingAddition } =
        GoedgepicktService.splitHouseNumberAndAddition(
          order.shippingAddress.streetLine2
        );
      const orderStatus =
        (await this.config.determineOrderStatus?.(ctx, order)) || 'open';
      const orderInput: OrderInput = {
        orderId: order.code,
        orderDisplayId: order.code,
        createDate: GoedgepicktService.toLocalTime(
          order.orderPlacedAt || order.updatedAt
        )!,
        orderStatus,
        orderItems,
        shippingFirstName: order.customer?.firstName,
        shippingLastName: order.customer?.lastName,
        shippingCompany: order.shippingAddress.company,
        shippingAddress: order.shippingAddress.streetLine1,
        shippingHouseNumber: houseNumber,
        shippingHouseNumberAddition: addition,
        shippingZipcode: order.shippingAddress.postalCode,
        shippingCity: order.shippingAddress.city,
        shippingCountry: order.shippingAddress.countryCode?.toUpperCase(),
        billingFirstName: order.customer?.firstName,
        billingLastName: order.customer?.lastName,
        billingCompany: billingAddress.company,
        billingHouseNumber: billingHouseNumber,
        billingHouseNumberAddition: billingAddition,
        billingZipcode: billingAddress.postalCode,
        billingCity: billingAddress.city,
        billingCountry: billingAddress.countryCode?.toUpperCase(),
        billingEmail: order.customer?.emailAddress,
        billingPhone: order.customer?.phoneNumber,
        paymentMethod: order.payments?.[0]?.method,
        ignoreUnknownProductWarnings: true,
        customerNote: (order.customFields as any)?.customerNote,
        shippingMethod: order.shippingLines
          .map((line) => line.shippingMethod?.name)
          .join(','),
      };
      const customFields = order.customFields;
      if (
        customFields?.pickupLocationNumber ||
        customFields?.pickupLocationName
      ) {
        orderInput.pickupLocationData = {
          locationNumber: customFields.pickupLocationNumber,
          location: customFields.pickupLocationName,
          carrier: customFields.pickupLocationCarrier,
          street: customFields.pickupLocationStreet,
          houseNumber: customFields.pickupLocationHouseNumber,
          zipcode: customFields.pickupLocationZipcode,
          city: customFields.pickupLocationCity,
          country: customFields.pickupLocationCountry?.toUpperCase(),
        };
      }
      const ggOrder = await client.createOrder(orderInput);
      await this.logHistoryEntry(ctx, order.id);
      return ggOrder;
    } catch (error: unknown) {
      await this.logHistoryEntry(ctx, order.id, error);
      throw error;
    }
  }
  async handleIncomingOrderStatusUpdate(
    ctx: RequestContext,
    orderCode: string,
    orderUuid: string
  ): Promise<void> {
    const client = this.getClientForChannel(ctx);
    if (!client) {
      return;
    }
    const ggOrder = await client.getOrder(orderUuid);
    if (!ggOrder) {
      Logger.warn(
        `Order with uuid '${orderUuid}' doesn't exists in GoedGepickt. Ignoring incoming order status update for order'${orderCode}'`,
        loggerCtx
      );
      return;
    }
    const newStatus = ggOrder.status;
    let order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      Logger.warn(
        `Order with code ${orderCode} doesn't exists. Not updating status to ${newStatus} for this order in channel ${ctx.channel.token}`,
        loggerCtx
      );
      return;
    }
    if (newStatus === 'completed') {
      if (order.state === 'Delivered') {
        return;
      }
      await transitionToDelivered(this.orderService, ctx, order, {
        code: goedgepicktHandler.code,
        arguments: [
          {
            name: 'goedGepicktOrderUUID',
            value: orderUuid,
          },
          {
            name: 'trackingCode',
            value:
              ggOrder.shipments?.map((s) => s.trackTraceCode).join(',') ?? '',
          },
          {
            name: 'trackingUrls',
            value:
              ggOrder.shipments?.map((s) => s.trackTraceUrl).join(',') ?? '',
          },
        ],
      });
      Logger.info(`Updated order ${orderCode} to Delivered`, loggerCtx);
    } else {
      return Logger.info(
        `No status updates needed for order ${orderCode} for status ${newStatus}`,
        loggerCtx
      );
    }
  }
  /**
   * Returns undefined if plugin is disabled
   */
  getClientForChannel(ctx: RequestContext): GoedgepicktClient | undefined {
    if (!ctx.channel.customFields.ggEnabled) {
      Logger.info(
        `GoedGepickt plugin is disabled for channel ${ctx.channel.token}`
      );
      return undefined;
    }
    const [uuid, apiKey] = (ctx.channel.customFields.ggUuidApiKey || '').split(
      ':'
    );
    if (!uuid || !apiKey) {
      throw Error(
        `GoedGepickt plugin is enabled, but incomplete config found for channel ${ctx.channel.token}`
      );
    }
    return new GoedgepicktClient({
      webshopUuid: uuid,
      apiKey: apiKey,
    });
  }
  getWebhookUrl(channelToken: string): string {
    let webhookTarget = this.config.vendureHost;
    if (!webhookTarget.endsWith('/')) {
      webhookTarget += '/';
    }
    return `${webhookTarget}goedgepickt/webhook/${channelToken}`;
  }
  /**
   * Creates admin context for channel
   */
  async getCtxForChannel(channelToken: string): Promise<RequestContext> {
    const channel = await this.channelService.getChannelFromToken(channelToken);
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel,
    });
  }
  async createFullsyncJobs(channelToken: string): Promise<void> {
    const ctx = await this.getCtxForChannel(channelToken);
    const client = this.getClientForChannel(ctx);
    if (!client) {
      throw new UserInputError(
        `GoedGepickt is not configured for channel ${channelToken}`
      );
    }
    const [ggProducts, variants] = await Promise.all([
      client.getAllProducts(),
      this.getVariants(ctx),
    ]);
    Logger.info(
      `Pushing ${variants.length} Vendure variants for channel ${channelToken} to GoedGepickt and fetching stock levels for those variants from GoedGepickt`,
      loggerCtx
    );
    const stockLevelInputs: StockInput[] = [];
    ggProducts.forEach((p) => {
      const variantId = variants.find((v) => v.sku === p.sku)?.id;
      if (!variantId) {
        Logger.info(
          `No variant found for product with sku ${p.sku}`,
          loggerCtx
        );
        return;
      }
      if (p.stock?.freeStock === undefined || p.stock?.freeStock === null) {
        Logger.error(
          `No stock found on product from GoedGepickt with sku ${p.sku}`,
          loggerCtx
        );
        return;
      }
      stockLevelInputs.push({
        variantId,
        stock: p.stock?.freeStock,
      });
    });
    await this.updateStock(ctx, stockLevelInputs);
    const productInputs: ProductInput[] = [];
    for (const variant of variants) {
      const existing = ggProducts.find(
        (ggProduct) => ggProduct.sku === variant.sku
      );
      productInputs.push(this.mapToProductInput(variant, existing?.uuid));
    }
    const pushBatches = this.getBatches(productInputs, 15);
    await Promise.all(
      pushBatches.map(async (batch) => {
        await this.jobQueue.add(
          {
            action: 'push-product',
            ctx: ctx.serialize(),
            products: batch,
          },
          { retries: 20 }
        );
        Logger.info(
          `Created PushProducts job for ${batch.length} variants for channel ${channelToken}`,
          loggerCtx
        );
      })
    );
  }
  async handlePushProductJob(
    ctx: RequestContext,
    { products }: PushProductJobData
  ): Promise<void> {
    const client = this.getClientForChannel(ctx);
    if (!client) {
      return;
    }
    for (const product of products) {
      if (product.uuid) {
        product.picture = undefined;
        await client.updateProduct(product.uuid, product);
        Logger.debug(`Updated variant ${product.sku}`, loggerCtx);
      } else {
        await client.createProduct(product).catch((e) => {
          if (
            typeof e?.message === 'string' &&
            e.message.indexOf('already exists') > -1
          ) {
          } else {
            throw e;
          }
        });
        Logger.debug(`Created variant ${product.sku}`, loggerCtx);
      }
    }
    Logger.info(
      `Pushed ${products.length} products to GoedGepickt for channel ${ctx.channel.token}`,
      loggerCtx
    );
  }
  async handlePushByVariantsJob(
    ctx: RequestContext,
    { variants }: PushProductByVariantsJobData
  ): Promise<void> {
    const client = this.getClientForChannel(ctx);
    if (!client) {
      return;
    }
    for (const variant of variants) {
      const existing = await client.findProductBySku(variant.sku);
      const product = this.mapToProductInput(
        this.setAbsoluteImage(ctx, variant)
      );
      const uuid = existing?.uuid;
      if (uuid) {
        product.picture = undefined;
        await client.updateProduct(uuid, product);
        Logger.debug(`Updated variant ${product.sku}`, loggerCtx);
      } else {
        await client.createProduct(product);
        Logger.debug(`Created variant ${product.sku}`, loggerCtx);
      }
    }
    Logger.info(
      `Pushed ${variants.length} variants to GoedGepickt for channel ${ctx.channel.token}`
    );
  }
  async logHistoryEntry(
    ctx: RequestContext,
    orderId: ID,
    error?: unknown
  ): Promise<void> {
    let prettifiedError = error
      ? JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)))
      : undefined;
    await this.historyService.createHistoryEntryForOrder(
      {
        ctx,
        orderId,
        type: 'GOEDGEPICKT_NOTIFICATION' as any,
        data: {
          name: 'GoedGepickt',
          valid: !error,
          error: prettifiedError,
        },
      },
      false
    );
  }
  private async updateStock(
    ctx: RequestContext,
    stockInput: StockInput[]
  ): Promise<ProductVariant[]> {
    const variantsWithStock = stockInput.map((input) => ({
      id: input.variantId,
      stockOnHand: input.stock,
    }));
    const batches = this.getBatches(variantsWithStock, 500);
    const allVariants: ProductVariant[] = [];
    for (const batch of batches) {
      const variants = await this.variantService.update(ctx, batch);
      const variantIds = batch.map((v) => v.id);
      if (!variantIds.length) {
        return [];
      }
      await this.connection
        .getRepository(ctx, StockLevel)
        .createQueryBuilder()
        .update()
        .set({ stockAllocated: 0 })
        .where('productVariantId IN (:...variantIds)', { variantIds })
        .execute();
      const skus = variants.map((v) => v.sku);
      Logger.info(
        `Updated stock of variants for channel ${
          ctx.channel.token
        }: ${skus.join(',')}`,
        loggerCtx
      );
      allVariants.push(...variants);
    }
    return allVariants;
  }
  private async getVariants(
    ctx: RequestContext,
    sku?: string
  ): Promise<VariantWithImage[]> {
    const translatedVariants: VariantWithImage[] = [];
    const take = 100;
    let skip = 0;
    let hasMore = true;
    while (hasMore) {
      const query = this.listQueryBuilder.build(
        ProductVariant,
        {
          skip,
          take,
        },
        {
          relations: [
            'featuredAsset',
            'channels',
            'product',
            'product.featuredAsset',
            'taxCategory',
          ],
          channelId: ctx.channelId,
          where: { deletedAt: IsNull() },
          ctx,
        }
      );
      if (sku) {
        query.andWhere('sku = :sku', { sku });
      }
      const variants = await query.getMany();
      hasMore = !!variants.length;
      skip += take;
      const variantsWithPrice = await Promise.all(
        variants.map((v) =>
          this.productPriceApplicator.applyChannelPriceAndTax(v, ctx)
        )
      );
      const mappedVariants = variantsWithPrice
        .map((v) => translateDeep(v, ctx.languageCode))
        .map((v) => this.setAbsoluteImage(ctx, v));
      translatedVariants.push(...(await Promise.all(mappedVariants)));
    }
    return translatedVariants;
  }
  private setAbsoluteImage(
    ctx: RequestContext,
    variant: Translated<ProductVariant> | ProductVariant
  ): VariantWithImage {
    const shopCtx = new RequestContext({
      apiType: 'shop',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel: ctx.channel,
    });
    let imageUrl =
      variant.featuredAsset?.preview || variant.product?.featuredAsset?.preview;
    if (
      this.configService.assetOptions.assetStorageStrategy.toAbsoluteUrl &&
      imageUrl
    ) {
      imageUrl = this.configService.assetOptions.assetStorageStrategy
        .toAbsoluteUrl!(shopCtx.req as any, imageUrl);
    }
    return {
      id: variant.id,
      productId: variant.productId,
      sku: variant.sku,
      name: variant.name,
      price: variant.price,
      absoluteImageUrl: imageUrl,
    };
  }
  async syncOrder(ctx: RequestContext, orderCode: string): Promise<void> {
    const client = this.getClientForChannel(ctx);
    if (!client) {
      return;
    }
    Logger.info(
      `Syncing order ${orderCode} for channel ${ctx.channel.token} to GoedGepickt`,
      loggerCtx
    );
    let order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      Logger.error(
        `No order found with code ${orderCode}. Can not sync this order.`,
        loggerCtx
      );
      return;
    }
    order = await this.entityHydrator.hydrate(ctx, order, {
      relations: [
        'shippingLines',
        'shippingLines.shippingMethod',
        'lines.productVariant',
        'payments',
      ],
    });
    const hasGoedgepicktHandler = order.shippingLines.some(
      (shippingLine) =>
        shippingLine.shippingMethod?.fulfillmentHandlerCode ===
        goedgepicktHandler.code
    );
    if (!hasGoedgepicktHandler) {
      Logger.info(
        `Order ${order.code} does not have Goedgepickt set as handler. Not syncing this order.`,
        loggerCtx
      );
      return;
    }
    await this.createOrder(ctx, order);
    Logger.info(
      `Order ${order.code} for channel ${ctx.channel.token} synced to GoedGepickt`,
      loggerCtx
    );
  }
  private mapToProductInput(
    variant: VariantWithImage,
    uuid?: string
  ): ProductInput {
    return {
      uuid,
      name: variant.name,
      sku: variant.sku,
      productId: variant.sku,
      stockManagement: true,
      url: `${this.config.vendureHost}/admin/catalog/products/${variant.productId};id=${variant.productId};tab=variants`,
      picture: variant.absoluteImageUrl,
      price: (variant.price / 100).toFixed(2),
    };
  }
  private getBatches<T>(array: T[], batchSize: number): T[][] {
    const batches = [];
    for (let i = 0; i < array.length; i += batchSize) {
      batches.push(array.slice(i, i + batchSize));
    }
    return batches;
  }
  static splitHouseNumberAndAddition(houseNumberString: string): {
    houseNumber: number;
    addition?: string;
  } {
    const [houseNumber, ...addition] = houseNumberString.match(
      /[a-z]+|\d+/gi
    ) as any[];
    return {
      houseNumber,
      addition: addition.join() || undefined,
    };
  }
  static toLocalTime(date: Date) {
    const tzoffset = date.getTimezoneOffset() * 60000;
    return new Date(date.getTime() - tzoffset).toISOString().slice(0, -1);
  }
}
```

## File: packages/vendure-plugin-goedgepickt/src/api/goedgepickt.types.ts

```typescript
import { RequestContext, Order as VendureOrder } from '@vendure/core';
export interface GoedgepicktPluginConfig {
  vendureHost: string;
  endpointSecret: string;
  setWebhook?: boolean;
  determineOrderStatus?: (
    ctx: RequestContext,
    order: VendureOrder
  ) => Promise<OrderStatus> | OrderStatus;
}
export interface ProductInput {
  uuid?: string;
  name: string;
  sku: string;
  productId: string;
  stockManagement: boolean;
  url: string;
  picture?: string;
  price: string;
}
export interface Product {
  uuid: string;
  sku: string;
  ean?: string;
  barcode?: string;
  name: string;
  description?: string;
  price?: string;
  costPrice?: string;
  taxRate?: string;
  weight?: number;
  length?: string;
  height?: string;
  width?: string;
  productAttributes?: any[];
  internalComment?: string;
  picture?: string;
  stock?: Stock;
}
export interface Stock {
  freeStock: number;
  totalStock: number;
  reservedStock: number;
  unlimitedStock: number;
  minimalStock: number;
  fillStockTo: number;
}
export interface OrderInput {
  orderId: string;
  orderDisplayId?: string;
  createDate: string;
  finishDate?: string;
  orderStatus: OrderStatus;
  orderItems: OrderItemInput[];
  shippingFirstName?: string;
  shippingLastName?: string;
  shippingCompany?: string;
  shippingAddress: string;
  shippingHouseNumber: number;
  shippingHouseNumberAddition?: string;
  shippingAddress2?: string;
  shippingZipcode?: string;
  shippingCity?: string;
  shippingCountry?: string;
  shippingMethod?: string;
  paymentMethod?: string;
  billingFirstName?: string;
  billingLastName?: string;
  billingCompany?: string;
  billingHouseNumber?: number;
  billingHouseNumberAddition?: string;
  billingZipcode?: string;
  billingCity?: string;
  billingCountry?: string;
  billingEmail?: string;
  billingPhone?: string;
  customerNote?: string;
  pickupLocationData?: {
    locationNumber?: string;
    carrier?: string;
    location?: string;
    street?: string;
    houseNumber?: string;
    zipcode?: string;
    city?: string;
    country?: string;
  };
  ignoreUnknownProductWarnings?: boolean;
}
export type OrderStatus = 'on_hold' | 'open' | 'completed' | 'cancelled';
export interface OrderItemInput {
  sku: string;
  taxRate: number;
  productName: string;
  productQuantity: number;
}
export interface Order {
  orderUuid: string;
  status: OrderStatus;
  shipments?: {
    trackTraceUrl?: string;
    trackTraceCode?: string;
  }[];
}
export interface IncomingStockUpdateEvent {
  event: 'stockUpdated';
  newStock: string;
  productSku: string;
  productUuid: string;
}
export interface IncomingOrderStatusEvent {
  event: 'orderStatusChanged';
  newStatus: OrderStatus;
  orderNumber: string;
  orderUuid: string;
}
export interface Webhook {
  webhookUuid: string;
  webhookEvent: GoedgepicktEvent;
  webhookSecret: string;
  targetUrl: string;
  webshopName: string;
  webshopUuid: string;
}
export interface Webshop {
  uuid: string;
  name: string;
  url: string;
  platform: string;
}
export enum GoedgepicktEvent {
  stockChanged = 'product.stockChanged',
  orderStatusChanged = 'order.statusChanged',
}
```

## File: packages/vendure-plugin-goedgepickt/src/api/schema.graphql.ts

```typescript
import gql from 'graphql-tag';
export const schema = gql`
  extend enum HistoryEntryType {
    GOEDGEPICKT_NOTIFICATION
  }
  input GoedgepicktConfigInput {
    enabled: Boolean
    apiKey: String
    webshopUuid: String
  }
  type GoedgepicktConfig {
    enabled: Boolean
    apiKey: String
    webshopUuid: String
    orderWebhookUrl: String
    stockWebhookUrl: String
  }
  type GoedgepicktError {
    message: String
  }
  union GoedgepicktConfigUpdateResult = GoedgepicktConfig | GoedgepicktError
  extend type Mutation {
    updateGoedgepicktConfig(
      input: GoedgepicktConfigInput!
    ): GoedgepicktConfigUpdateResult
    # Push products and pull stocklevels
    runGoedgepicktFullSync: Boolean
    syncOrderToGoedgepickt(orderCode: String!): Boolean
  }
  extend type Query {
    goedgepicktConfig: GoedgepicktConfig
  }
`;
```

## File: packages/vendure-plugin-goedgepickt/src/ui/goedgepickt-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import {
  addActionBarDropdownMenuItem,
  registerHistoryEntryComponent,
  SharedModule,
} from '@vendure/admin-ui/core';
import { HistoryEntryComponent } from './history-entry.component';
import gql from 'graphql-tag';
@NgModule({
  imports: [SharedModule],
  declarations: [HistoryEntryComponent],
  providers: [
    registerHistoryEntryComponent({
      type: 'GOEDGEPICKT_NOTIFICATION',
      component: HistoryEntryComponent,
    }),
    addActionBarDropdownMenuItem({
      id: 'gg-full-sync',
      label: 'GoedGepickt full sync',
      locationId: 'product-list',
      icon: 'refresh',
      onClick: async (
        event,
        { dataService, notificationService, injector }
      ) => {
        dataService
          .mutate(
            gql`
              mutation RunGoedgepicktFullSync {
                runGoedgepicktFullSync
              }
            `
          )
          .subscribe({
            next: () => {
              notificationService.success(
                'Started full sync. This might take about 15 minutes...'
              );
            },
            error: (err) => {
              notificationService.error(err.message);
            },
          });
      },
    }),
  ],
})
export class GoedgepicktNavModule {}
```

## File: packages/vendure-plugin-goedgepickt/src/ui/history-entry.component.ts

```typescript
import { Component } from '@angular/core';
import {
  DataService,
  NotificationService,
  OrderDetailFragment,
  OrderHistoryEntryComponent,
  TimelineDisplayType,
  TimelineHistoryEntry,
} from '@vendure/admin-ui/core';
import gql from 'graphql-tag';
@Component({
  selector: 'goedgepickt-notification-component',
  template: `
    <span *ngIf="entry.data.valid"> Synced to {{ getName(entry) }} </span>
    <span *ngIf="!entry.data.valid">
      Failed to sync to {{ getName(entry) }}
    </span>
    <button (click)="mutate()" class="btn btn-link btn-sm details-button">
      <clr-icon shape="sync" size="16"></clr-icon>
    </button>
    <br />
    <vdr-history-entry-detail *ngIf="entry.data.error">
      <vdr-object-tree [value]="entry.data.error"></vdr-object-tree>
    </vdr-history-entry-detail>
  `,
})
export class HistoryEntryComponent implements OrderHistoryEntryComponent {
  entry!: TimelineHistoryEntry;
  order!: OrderDetailFragment;
  constructor(
    protected dataService: DataService,
    protected notificationService: NotificationService
  ) {}
  async mutate(): Promise<void> {
    try {
      await this.dataService
        .mutate(
          gql`
          mutation {
              syncOrderToGoedgepickt(orderCode: "${this.order.code}")
          }
      `
        )
        .toPromise();
      this.notificationService.success('Success');
    } catch (e: any) {
      this.notificationService.error('Error');
    }
  }
  getDisplayType(entry: TimelineHistoryEntry): TimelineDisplayType {
    return entry.data.valid ? 'success' : 'error';
  }
  getName(entry: TimelineHistoryEntry): string {
    return entry.data.name;
  }
  isFeatured(entry: TimelineHistoryEntry): boolean {
    return !entry.data.valid;
  }
  getIconShape(entry: TimelineHistoryEntry) {
    return entry.data.valid ? 'check-circle' : 'exclamation-circle';
  }
}
```

## File: packages/vendure-plugin-goedgepickt/src/constants.ts

```typescript
export const loggerCtx = 'GoedgepicktPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('GOEDGEPICKT_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-goedgepickt/src/custom-fields.ts

```typescript
import {
  CustomFieldConfig,
  Injector,
  LanguageCode,
  Logger,
  RequestContext,
} from '@vendure/core';
import fetch from 'node-fetch';
import { goedgepicktPermission } from './api/goedgepickt.resolver';
import { GoedgepicktService } from './api/goedgepickt.service';
import { loggerCtx } from './constants';
declare module '@vendure/core' {
  interface CustomOrderFields {
    pickupLocationNumber?: string;
    pickupLocationCarrier?: string;
    pickupLocationName?: string;
    pickupLocationStreet?: string;
    pickupLocationHouseNumber?: string;
    pickupLocationZipcode?: string;
    pickupLocationCity?: string;
    pickupLocationCountry?: string;
  }
  interface CustomChannelFields {
    ggEnabled?: boolean;
    ggUuidApiKey?: string;
  }
}
export const orderCustomFields: CustomFieldConfig[] = [
  {
    name: 'pickupLocationNumber',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationCarrier',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationName',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationStreet',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationHouseNumber',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationZipcode',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationCity',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
  {
    name: 'pickupLocationCountry',
    type: 'string',
    public: true,
    nullable: true,
    ui: { tab: 'pickup' },
  },
];
const uiTab = 'GoedGepickt';
export const channelCustomFields: CustomFieldConfig[] = [
  {
    name: 'ggEnabled',
    type: 'boolean',
    public: false,
    label: [{ languageCode: LanguageCode.en, value: 'Enabled' }],
    requiresPermission: goedgepicktPermission.Permission,
    ui: {
      tab: uiTab,
    },
  },
  {
    name: 'ggUuidApiKey',
    type: 'text',
    public: false,
    validate,
    label: [{ languageCode: LanguageCode.en, value: 'UUID and ApiKey' }],
    description: [
      {
        languageCode: LanguageCode.en,
        value:
          'Webshop UUID and ApiKey separated by colon, e.g. "uuid1234:apikey1234"',
      },
    ],
    requiresPermission: goedgepicktPermission.Permission,
    ui: {
      tab: uiTab,
      component: 'textarea-form-input',
      spellcheck: false,
    },
  },
];
async function validate(
  value: any,
  injector: Injector,
  ctx: RequestContext
): Promise<string | undefined> {
  if (typeof value !== 'string') {
    return 'Must be a string';
  }
  const [uuid, apiKey] = value.split(':');
  if (!uuid || !apiKey) {
    return 'Must be in the format "uuid1234:apiKey4567"';
  }
  if (process.env.VITEST_WORKER_ID) {
    return;
  }
  const result = await fetch('https://account.goedgepickt.nl/api/v1/webshops', {
    method: 'GET',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    redirect: 'follow',
  });
  if (result.status !== 200) {
    return `Invalid ApiKey: ${result.status} (${result.statusText})`;
  }
  const json: any = await result.json();
  const webshop = json.items?.find((item: any) => item.uuid === uuid);
  if (!webshop) {
    return 'Apikey is correct, but cannot find webshopUuid';
  }
  Logger.info(
    `Saved correct UUID and ApiKey for webshop '${webshop.name}' for channel '${ctx.channel.token}`,
    loggerCtx
  );
  await injector
    .get(GoedgepicktService)
    .registerWebhooks(ctx)
    .catch((err) => {
      Logger.error(
        `Failed to set webhooks for channel '${ctx.channel.token}' after saving credentials: ${err.message}`,
        loggerCtx
      );
    });
}
```

## File: packages/vendure-plugin-goedgepickt/src/goedgepickt.plugin.ts

```typescript
import {
  CustomOrderFields,
  PluginCommonModule,
  RuntimeVendureConfig,
  VendurePlugin,
} from '@vendure/core';
import { GoedgepicktService } from './api/goedgepickt.service';
import { GoedgepicktController } from './api/goedgepickt.controller';
import { goedgepicktHandler } from './api/goedgepickt.handler';
import { GoedgepicktPluginConfig } from './api/goedgepickt.types';
import {
  GoedgepicktResolver,
  goedgepicktPermission,
} from './api/goedgepickt.resolver';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { schema } from './api/schema.graphql';
import path from 'path';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { channelCustomFields, orderCustomFields } from './custom-fields';
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [GoedgepicktController],
  providers: [
    GoedgepicktService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => GoedgepicktPlugin.config,
    },
  ],
  adminApiExtensions: {
    schema,
    resolvers: [GoedgepicktResolver],
  },
  configuration: (config: RuntimeVendureConfig) => {
    config.shippingOptions.fulfillmentHandlers.push(goedgepicktHandler);
    config.authOptions.customPermissions.push(goedgepicktPermission);
    config.customFields.Order.push(...orderCustomFields);
    config.customFields.Channel.push(...channelCustomFields);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class GoedgepicktPlugin {
  static config: GoedgepicktPluginConfig;
  static init(config: GoedgepicktPluginConfig): typeof GoedgepicktPlugin {
    this.config = config;
    if (this.config.setWebhook !== false) {
      this.config.setWebhook = true;
    }
    return GoedgepicktPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'shared',
        ngModuleFileName: 'goedgepickt-nav.module.ts',
        ngModuleName: 'GoedgepicktNavModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-goedgepickt/src/index.ts

```typescript
export * from './ui/generated/graphql';
export * from './api/goedgepickt.types';
export * from './goedgepickt.plugin';
export * from './api/goedgepickt.handler';
```

## File: packages/vendure-plugin-goedgepickt/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  Channel,
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  ShippingMethodService,
  TransactionalConnection,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { GoedgepicktService } from '../src/api/goedgepickt.service';
import { goedgepicktHandler, GoedgepicktPlugin } from '../src';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import path from 'path';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
(async () => {
  require('dotenv').config();
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      GoedgepicktPlugin.init({
        vendureHost: process.env.WEBHOOK_ENDPOINT!,
        endpointSecret: 'test',
        setWebhook: true,
        determineOrderStatus: async (ctx, order) => 'on_hold' as const,
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [GoedgepicktPlugin.ui],
          devMode: true,
        }),
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  const goedgepicktService = server.app.get(GoedgepicktService);
  const connection = server.app.get(TransactionalConnection);
  await connection.getRepository(Channel).update(1, {
    customFields: {
      ggEnabled: true,
      ggUuidApiKey: `${process.env.GOEDGEPICKT_WEBSHOPUUID}:${process.env.GOEDGEPICKT_APIKEY}`,
    },
  });
  const ctx = await goedgepicktService.getCtxForChannel('e2e-default-channel');
  await server.app.get(ShippingMethodService).update(ctx, {
    id: 1,
    fulfillmentHandler: goedgepicktHandler.code,
    translations: [],
  });
  await goedgepicktService.registerWebhooks(ctx);
  await goedgepicktService.handleIncomingStockUpdate(ctx, 'L2201308');
  await createSettledOrder(shopClient, 1);
})();
```

## File: packages/vendure-plugin-goedgepickt/test/goedgepickt.spec.ts

```typescript
import nock from 'nock';
import {
  AvailableStock,
  configureDefaultOrderProcess,
  DefaultLogger,
  ID,
  LanguageCode,
  LogLevel,
  mergeConfig,
  Order,
  OrderService,
  ProductService,
  ProductVariant,
  ProductVariantService,
  ShippingMethodService,
  StockLevelService,
  TransactionalConnection,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import gql from 'graphql-tag';
import { afterAll, afterEach, beforeAll, describe, expect, it } from 'vitest';
import { getOrder, updateVariants } from '../../test/src/admin-utils';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { initialData } from '../../test/src/initial-data';
import {
  addItem,
  createSettledOrder,
  SettledOrder,
} from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import {
  goedgepicktHandler,
  GoedgepicktPlugin,
  IncomingOrderStatusEvent,
  IncomingStockUpdateEvent,
  OrderInput,
} from '../src';
import { GoedgepicktService } from '../src/api/goedgepickt.service';
import { updateChannel } from './helpers';
import { waitFor } from '../../test/src/test-helpers';
import { GlobalFlag } from '@vendure/common/lib/generated-types';
describe('Goedgepickt plugin', function () {
  const defaultChannelToken = 'e2e-default-channel';
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  const ggConfig = {
    apiKey: 'test-api-key',
    webshopUuid: 'test-webshop-uuid',
  };
  let pushProductsPayloads: any[] = [];
  let webhookPayloads: any[] = [];
  let createOrderPayload: OrderInput;
  let order: SettledOrder;
  const apiUrl = 'https://account.goedgepickt.nl/';
  afterEach(() => {
    const pendingMocks = nock.pendingMocks();
    if (pendingMocks.length > 0) {
      console.error("Pending mocks that weren't called:", pendingMocks);
    }
    nock.cleanAll();
  });
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        adminListQueryLimit: 10000,
        port: 3105,
      },
      logger: new DefaultLogger({ level: LogLevel.Info }),
      plugins: [
        GoedgepicktPlugin.init({
          vendureHost: 'https://test-host',
          endpointSecret: 'test',
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
      orderOptions: {
        process: [
          configureDefaultOrderProcess({ checkFulfillmentStates: false }),
        ] as any,
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
  }, 60000);
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Should track inventory of all variants', async () => {
    await adminClient.asSuperAdmin();
    const variants = await updateVariants(adminClient, [
      { id: 'T_1', trackInventory: GlobalFlag.TRUE },
      { id: 'T_2', trackInventory: GlobalFlag.TRUE },
      { id: 'T_3', trackInventory: GlobalFlag.TRUE },
      { id: 'T_4', trackInventory: GlobalFlag.TRUE as any },
    ]);
    const everyVariantHasStockTracking = variants.every(
      (v) => v!.trackInventory === (GlobalFlag.TRUE as any)
    );
    expect(everyVariantHasStockTracking).toBe(true);
  });
  it('Updates credentials on Channel', async () => {
    const uuidAndApiKey = ggConfig.webshopUuid + ':' + ggConfig.apiKey;
    const result = await adminClient.query(updateChannel, {
      input: {
        id: 'T_1',
        customFields: {
          ggEnabled: true,
          ggUuidApiKey: uuidAndApiKey,
        },
      },
    });
    await expect(result.updateChannel.customFields.ggUuidApiKey).toBe(
      uuidAndApiKey
    );
  });
  it('Pushes products and updates stock level on FullSync', async () => {
    nock(apiUrl)
      .persist(true)
      .get('/api/v1/webhooks')
      .reply(200, { items: [] });
    nock(apiUrl)
      .persist(true)
      .post('/api/v1/webhooks', (reqBody: any) => {
        webhookPayloads.push(reqBody);
        return true;
      })
      .reply(200, { webhookSecret: 'test-secret' });
    nock(apiUrl)
      .persist(true)
      .get(
        /\/api\/v1\/products\?searchAttribute=sku&searchDelimiter=%3D&searchValue=*/
      )
      .reply(200, {
        items: [],
      });
    nock(apiUrl)
      .persist(true)
      .post('/api/v1/products', (reqBody: any) => {
        pushProductsPayloads.push(reqBody);
        return true;
      })
      .reply(200, []);
    nock(apiUrl)
      .persist(true)
      .get('/api/v1/products')
      .query(true)
      .reply(200, {
        items: [
          {
            uuid: 'test-uuid',
            sku: 'L2201308',
            stock: {
              freeStock: 33,
            },
          },
        ],
      });
    nock(apiUrl).put('/api/v1/products/test-uuid').reply(200, []);
    await adminClient.query(
      gql`
        mutation {
          runGoedgepicktFullSync
        }
      `
    );
    await waitFor(() => pushProductsPayloads.length > 3);
    await expect(pushProductsPayloads.length).toBeGreaterThanOrEqual(3); // After multiple restarts we have 1 extra
    const laptopPayload = pushProductsPayloads.find(
      (p) => p.sku === 'L2201516'
    );
    await expect(laptopPayload.webshopUuid).toBe(ggConfig.webshopUuid);
    await expect(laptopPayload.productId).toBe('L2201516');
    await expect(laptopPayload.sku).toBe('L2201516');
    await expect(laptopPayload.name).toBe('Laptop 15 inch 16GB');
    await expect(laptopPayload.price).toBe('2299.00');
    await expect(laptopPayload.url).toBe(
      `https:
    );
    const updatedVariant = await findVariantBySku('L2201308');
    expect(updatedVariant).toBeDefined();
    const stock = await getAvailableStock(updatedVariant?.id!);
    expect(stock.stockOnHand).toBe(33);
    expect(stock.stockAllocated).toBe(0);
    await waitFor(() => webhookPayloads.length >= 2);
    expect(webhookPayloads.length).toBe(2);
  });
  it('Set goedgepickt as fulfillment handler', async () => {
    const ctx = await server.app
      .get(GoedgepicktService)
      .getCtxForChannel(defaultChannelToken);
    const shippingMethod = await server.app
      .get(ShippingMethodService)
      .update(ctx, {
        id: 1,
        fulfillmentHandler: goedgepicktHandler.code,
        translations: [],
      });
    expect(shippingMethod.fulfillmentHandlerCode).toBe('goedgepickt');
  });
  it('Pushes order after placement', async () => {
    nock(apiUrl)
      .post('/api/v1/orders', (reqBody: any) => {
        createOrderPayload = reqBody;
        return true;
      })
      .reply(200, {
        message: 'Order created',
        orderUuid: 'testUuid',
      });
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    await addItem(shopClient, 'T_1', 1);
    await shopClient.query(SET_CUSTOM_FIELDS);
    order = await createSettledOrder(shopClient, 1);
    await waitFor(() => !!createOrderPayload);
    await expect(createOrderPayload.orderId).toBe(order.code);
    await expect(createOrderPayload.orderItems.length).toBe(2);
    await expect(createOrderPayload.shippingFirstName).toBe('Hayden');
    await expect(createOrderPayload.shippingLastName).toBe('Zieme');
    await expect(createOrderPayload.shippingAddress).toBe('Verzetsstraat');
    await expect(createOrderPayload.shippingHouseNumber).toBe('12');
    await expect(createOrderPayload.shippingHouseNumberAddition).toBe('a');
    await expect(createOrderPayload.shippingZipcode).toBe('8923CP');
    await expect(createOrderPayload.shippingCity).toBe('Liwwa');
    await expect(createOrderPayload.shippingCountry).toBe('NL');
    await expect(createOrderPayload.pickupLocationData?.houseNumber).toBe(
      '13a'
    );
    await expect(createOrderPayload.pickupLocationData?.city).toBe(
      'Leeuwarden'
    );
    await expect(createOrderPayload.pickupLocationData?.locationNumber).toBe(
      '1234'
    );
    await expect(createOrderPayload.pickupLocationData?.country).toBe('NL');
    await expect(createOrderPayload.shippingMethod).toBe('Standard Shipping');
    const stock = await getAvailableStock(1);
    expect(stock.stockOnHand).toBe(33);
    expect(stock.stockAllocated).toBe(2);
  });
  it('Decreases stock via webhook and resets allocated', async () => {
    nock(apiUrl)
      .persist(true)
      .get(
        /\/api\/v1\/products\?searchAttribute=sku&searchDelimiter=%3D&searchValue=*/
      )
      .reply(200, {
        items: [
          {
            uuid: 'test-uuid',
            sku: 'L2201308',
            stock: {
              freeStock: 123,
            },
          },
        ],
      });
    const body: IncomingStockUpdateEvent = {
      event: 'stockUpdated',
      newStock: 'doestn matter',
      productSku: 'L2201308',
      productUuid: 'doesntmatter',
    };
    const res = await shopClient.fetch(
      `http://localhost:3105/goedgepickt/webhook/${defaultChannelToken}`,
      {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
          signature: 'some-sample-signature',
        },
      }
    );
    const updatedVariant = await findVariantBySku('L2201308');
    expect(res.ok).toBe(true);
    expect(updatedVariant).toBeDefined();
    const stock = await getAvailableStock(updatedVariant?.id!);
    expect(stock.stockOnHand).toBe(123);
    expect(stock.stockAllocated).toBe(0);
  });
  it('Completes order via webhook', async () => {
    nock(apiUrl)
      .get('/api/v1/orders/testUuid')
      .reply(200, {
        message: 'Order created',
        orderUuid: 'testUuid',
        status: 'completed',
        shipments: [
          {
            trackTraceCode: 'XYZ',
            trackTraceUrl: 'pinelab.studio/xyz',
          },
        ],
      });
    const body: IncomingOrderStatusEvent = {
      newStatus: 'completed',
      orderNumber: order.code,
      event: 'orderStatusChanged',
      orderUuid: 'testUuid',
    };
    const res = await shopClient.fetch(
      `http://localhost:3105/goedgepickt/webhook/${defaultChannelToken}`,
      {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
          signature: 'test-signature',
        },
      }
    );
    const ctx = await server.app
      .get(GoedgepicktService)
      .getCtxForChannel(defaultChannelToken);
    const adminOrder = (await server.app
      .get(OrderService)
      .findOneByCode(ctx, order.code))!;
    expect(res.ok).toBe(true);
    expect(adminOrder.state).toBe('Delivered');
    const stock = await getAvailableStock(1);
    expect(stock.stockOnHand).toBe(121);
    expect(stock.stockAllocated).toBe(-2);
  });
  it('Has fulfillment after completion', async () => {
    const adminOrder = await getOrder(adminClient, order.id as string);
    const fulfillment = adminOrder?.fulfillments?.[0];
    expect(fulfillment?.method).toBe('GoedGepickt - XYZ');
    expect(fulfillment?.trackingCode).toBe('XYZ');
  });
  it('Pushes product on product creation', async () => {
    nock(apiUrl)
      .persist(true)
      .get(
        /\/api\/v1\/products\?searchAttribute=sku&searchDelimiter=%3D&searchValue=*/
      )
      .reply(200, {
        items: [],
      });
    nock(apiUrl)
      .persist(true)
      .post('/api/v1/products', (reqBody: any) => {
        pushProductsPayloads.push(reqBody);
        return true;
      })
      .reply(200, []);
    const ctx = await server.app
      .get(GoedgepicktService)
      .getCtxForChannel(defaultChannelToken);
    await server.app.get(ProductService).create(ctx, {
      translations: [
        {
          languageCode: LanguageCode.en,
          name: 'test',
          slug: 'test',
          description: '',
        },
      ],
    });
    await server.app.get(ProductVariantService).create(ctx, [
      {
        productId: 2,
        price: 1200,
        sku: 'sku123',
        translations: [
          {
            languageCode: LanguageCode.en,
            name: 'test variant',
          },
        ],
      },
    ]);
    const payload = await waitFor(
      () => !!pushProductsPayloads.find((p) => p.sku === 'sku123')
    );
    expect(payload).toBeDefined();
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        GoedgepicktPlugin.ui
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
  async function findVariantBySku(sku: string): Promise<ProductVariant | null> {
    const ctx = await server.app
      .get(GoedgepicktService)
      .getCtxForChannel(defaultChannelToken);
    const transactionalConnection = server.app.get(TransactionalConnection);
    const productVariantRepo = transactionalConnection.getRepository(
      ctx,
      ProductVariant
    );
    return await productVariantRepo.findOne({
      where: { sku },
      relations: ['stockLevels'],
    });
  }
  async function getAvailableStock(
    productVariantId: ID
  ): Promise<AvailableStock> {
    const ctx = await server.app
      .get(GoedgepicktService)
      .getCtxForChannel(defaultChannelToken);
    const stockLevelService = server.app.get(StockLevelService);
    return await stockLevelService.getAvailableStock(ctx, productVariantId);
  }
});
const SET_CUSTOM_FIELDS = gql`
  mutation {
    setOrderCustomFields(
      input: {
        customFields: {
          pickupLocationNumber: "1234"
          pickupLocationCarrier: "1"
          pickupLocationName: "Local shop"
          pickupLocationStreet: "Shopstreet"
          pickupLocationHouseNumber: "13a"
          pickupLocationZipcode: "8888HG"
          pickupLocationCity: "Leeuwarden"
          pickupLocationCountry: "nl"
        }
      }
    ) {
      ... on Order {
        id
        code
      }
      ... on NoActiveOrderError {
        errorCode
        message
      }
    }
  }
`;
```

## File: packages/vendure-plugin-goedgepickt/test/helpers.ts

```typescript
import gql from 'graphql-tag';
export const updateChannel = gql`
  mutation UpdateChannel($input: UpdateChannelInput!) {
    updateChannel(input: $input) {
      ... on Channel {
        id
        token
        customFields {
          ggEnabled
          ggUuidApiKey
        }
      }
      __typename
    }
  }
`;
```

## File: packages/vendure-plugin-google-cloud-tasks/src/cloud-tasks-controller.ts

```typescript
import {
  Controller,
  Get,
  OnApplicationBootstrap,
  Param,
  Post,
  Req,
  Res,
} from '@nestjs/common';
import { Logger } from '@vendure/core';
import { Request, Response } from 'express';
import { CloudTasksService } from './cloud-tasks-service';
import { CloudTasksPlugin } from './cloud-tasks.plugin';
import { loggerCtx } from './constants';
import { CloudTaskMessage, ROUTE } from './types';
@Controller(ROUTE)
export class CloudTasksController implements OnApplicationBootstrap {
  private applicationBootstrapped = false;
  constructor(private readonly service: CloudTasksService) {}
  onApplicationBootstrap() {
    this.applicationBootstrapped = true;
  }
  @Post('handler')
  async handler(@Req() req: Request, @Res() res: Response): Promise<void> {
    if (!this.applicationBootstrapped) {
      res.sendStatus(500);
      return;
    }
    if (!this.isValidRequest(req)) {
      res.sendStatus(401);
      return;
    }
    const message: CloudTaskMessage = req.body;
    const attemptsHeader = req.header('x-cloudtasks-taskretrycount');
    const responseCode = await this.service.handleIncomingJob(
      message,
      attemptsHeader
    );
    res.sendStatus(responseCode);
  }
  @Get('clear-jobs/:days')
  async clearJobs(
    @Req() req: Request,
    @Res() res: Response,
    @Param('days') daysString: string
  ): Promise<void> {
    if (!this.isValidRequest(req)) {
      res.sendStatus(401);
      return;
    }
    if (isNaN(parseInt(daysString))) {
      res.status(400).send(`${daysString} is not a number`);
      return;
    }
    const days = parseInt(daysString);
    const daysAgo = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    await this.service.removeAllJobs(daysAgo);
    res.sendStatus(200);
  }
  private isValidRequest(req: Request): boolean {
    if (
      req.header('Authorization') !==
      `Bearer ${CloudTasksPlugin.options.authSecret}`
    ) {
      Logger.warn(
        `Unauthorized incoming webhook with Auth header ${req.header(
          'Authorization'
        )}`,
        loggerCtx
      );
      return false;
    }
    return true;
  }
}
```

## File: packages/vendure-plugin-google-cloud-tasks/src/cloud-tasks-job-queue.strategy.ts

```typescript
import { JobListOptions } from '@vendure/common/lib/generated-types';
import {
  ID,
  Injector,
  InspectableJobQueueStrategy,
  Job,
  JobData,
  PaginatedList,
} from '@vendure/core';
import { CloudTasksService } from './cloud-tasks-service';
export class CloudTasksJobQueueStrategy implements InspectableJobQueueStrategy {
  private service!: CloudTasksService;
  init(injector: Injector): void | Promise<void> {
    this.service = injector.get(CloudTasksService);
  }
  async add<Data extends JobData<Data> = {}>(
    job: Job<Data>
  ): Promise<Job<Data>> {
    return await this.service.add(job);
  }
  async start<Data extends JobData<Data> = {}>(
    originalQueueName: string,
    process: (job: Job<Data>) => Promise<any>
  ) {
    await this.service.start(originalQueueName, process);
  }
  async stop<Data extends JobData<Data> = {}>(
    queueName: string,
    _process: (job: Job<Data>) => Promise<any>
  ) {
    await this.service.stop(queueName, _process);
  }
  async findOne(id: ID): Promise<Job<any> | undefined> {
    return await this.service.findJob(id);
  }
  async findMany(
    options?: JobListOptions | undefined
  ): Promise<PaginatedList<Job<any>>> {
    return await this.service.findJobs(options);
  }
  async findManyById(ids: ID[]): Promise<Job<any>[]> {
    return await this.service.findJobsById(ids);
  }
  async removeSettledJobs(
    queueNames?: string[] | undefined,
    olderThan?: Date | undefined
  ): Promise<number> {
    return await this.service.removeSettledJobs(queueNames || [], olderThan);
  }
  async cancelJob(jobId: ID): Promise<Job<any> | undefined> {
    return await this.service.cancelJob(jobId);
  }
}
```

## File: packages/vendure-plugin-google-cloud-tasks/src/cloud-tasks-service.ts

```typescript
import { CloudTasksClient } from '@google-cloud/tasks';
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { JobListOptions, JobState } from '@vendure/common/lib/generated-types';
import {
  ID,
  Job,
  JobData,
  JsonCompatible,
  ListQueryBuilder,
  Logger,
  PaginatedList,
} from '@vendure/core';
import { JobRecord } from '@vendure/core/dist/plugin/default-job-queue-plugin/job-record.entity';
import { DataSource, In, LessThan, Repository } from 'typeorm';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from './constants';
import { CloudTaskMessage, CloudTaskOptions } from './types';
import { generatePublicId } from '@vendure/core/dist/common/generate-public-id';
type QueueProcessFunction = (job: Job) => Promise<any>;
@Injectable()
export class CloudTasksService implements OnApplicationBootstrap {
  LIVE_QUEUES = new Set<string>();
  PROCESS_MAP = new Map<string, QueueProcessFunction>();
  readonly jobRecordRepository: Repository<JobRecord>;
  readonly client: CloudTasksClient;
  constructor(
    private readonly listQueryBuilder: ListQueryBuilder,
    @Inject(PLUGIN_INIT_OPTIONS) private readonly options: CloudTaskOptions,
    dataSource: DataSource
  ) {
    this.jobRecordRepository = dataSource.getRepository(JobRecord);
    this.client = new CloudTasksClient(options.clientOptions);
  }
  onApplicationBootstrap() {
    const daysAgo30 = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    this.removeAllJobs(daysAgo30)
      .then(() => {
        Logger.info(`Removed settled jobs`, loggerCtx);
      })
      .catch((e: any) => {
        Logger.error(
          `Failed to remove settled jobs: ${e?.message}`,
          loggerCtx,
          e?.stack
        );
      });
  }
  async findJob(id: ID): Promise<Job<any> | undefined> {
    const jobRecord = await this.jobRecordRepository.findOne({ where: { id } });
    if (!jobRecord) {
      return undefined;
    }
    return new Job(jobRecord);
  }
  async findJobs(
    options?: JobListOptions | undefined
  ): Promise<PaginatedList<Job<any>>> {
    return this.listQueryBuilder
      .build(JobRecord, options)
      .getManyAndCount()
      .then(([items, totalItems]) => ({
        items: items.map(this.fromRecord),
        totalItems,
      }));
  }
  async findJobsById(ids: ID[]): Promise<Job<any>[]> {
    return this.jobRecordRepository
      .find({ where: { id: In(ids) } })
      .then((records) => records.map(this.fromRecord));
  }
  async removeSettledJobs(
    queueNames: string[],
    olderThan?: Date | undefined
  ): Promise<number> {
    const result = await this.jobRecordRepository.delete({
      ...(0 < queueNames.length ? { queueName: In(queueNames) } : {}),
      isSettled: true,
      settledAt: LessThan(olderThan ?? new Date()),
    });
    return result.affected || 0;
  }
  async removeAllJobs(olderThan: Date): Promise<void> {
    await this.jobRecordRepository.delete({
      createdAt: LessThan(olderThan),
    });
  }
  async cancelJob(jobId: ID): Promise<Job<any> | undefined> {
    await this.jobRecordRepository.delete({ id: jobId });
    return;
  }
  async add<Data extends JobData<Data> = {}>(
    job: Job<Data>
  ): Promise<Job<Data>> {
    const queueName = this.getQueueName(job.queueName);
    if (!this.LIVE_QUEUES.has(queueName)) {
      await this.createQueue(queueName);
    }
    const retries = job.retries || this.options.defaultJobRetries || 3;
    const jobRecord = await this.saveWithRetry(
      new JobRecord({
        id: job.id,
        queueName: queueName,
        data: job.data as any,
        attempts: job.attempts,
        state: JobState.PENDING,
        startedAt: job.startedAt,
        createdAt: job.createdAt,
        isSettled: false,
        retries,
        progress: 0,
      })
    );
    const cloudTaskMessage: CloudTaskMessage = {
      id: jobRecord.id,
      queueName: queueName,
      data: job.data,
      createdAt: job.createdAt,
      maxRetries: retries,
    };
    const parent = this.getQueuePath(queueName);
    const task = {
      name: `projects/${this.options.projectId}/locations/${
        this.options.location
      }/queues/${queueName}/tasks/${generatePublicId()}`,
      httpRequest: {
        httpMethod: 'POST' as const,
        headers: {
          'Content-type': 'application/json',
          Authorization: `Bearer ${this.options.authSecret}`,
        },
        url: `${this.options.taskHandlerHost}/cloud-tasks/handler`,
        body: Buffer.from(JSON.stringify(cloudTaskMessage)).toString('base64'),
      },
    };
    const request = { parent, task };
    let currentAttempt = 0;
    while (true) {
      try {
        Logger.debug(
          `Adding job (${cloudTaskMessage.id}) with retries=${cloudTaskMessage.maxRetries} to queue ${queueName} for ${task.httpRequest?.url}`,
          loggerCtx
        );
        await this.client.createTask(request, {
          maxRetries: cloudTaskMessage.maxRetries,
        });
        Logger.debug(
          `Added job (${cloudTaskMessage.id}) with retries=${cloudTaskMessage.maxRetries} to queue ${queueName} for ${task.httpRequest.url}`,
          loggerCtx
        );
        return new Job<any>(jobRecord);
      } catch (e: any) {
        currentAttempt += 1;
        if (currentAttempt === (this.options.createTaskRetries ?? 5)) {
          Logger.error(
            `Failed to add task to queue ${queueName} in ${currentAttempt} attempts. Not retrying anymore! Error: ${e?.message}`,
            loggerCtx,
            (e as Error)?.stack
          );
          throw e;
        }
        Logger.warn(
          `Failed to add task to queue ${queueName} in attempt nr ${currentAttempt}: ${e?.message}`,
          loggerCtx
        );
        if (currentAttempt > 3) {
          await new Promise((resolve) =>
            setTimeout(resolve, 1000 * 2 ** currentAttempt)
          );
        }
      }
    }
  }
  async start<Data extends JobData<Data> = {}>(
    originalQueueName: string,
    process: (job: Job<Data>) => Promise<any>
  ) {
    const queueName = this.getQueueName(originalQueueName);
    this.PROCESS_MAP.set(queueName, process);
    Logger.info(`Started queue ${queueName}`, loggerCtx);
  }
  getAllQueueNames(): string[] {
    return Array.from(this.PROCESS_MAP.keys());
  }
  async handleIncomingJob(
    message: CloudTaskMessage,
    attemptsHeader?: string
  ): Promise<200 | 500> {
    Logger.debug(`Received Cloud Task message ${message.id}`, loggerCtx);
    const processFn = this.PROCESS_MAP.get(message.queueName);
    if (!processFn) {
      Logger.error(
        `No process function found for queue ${message.queueName}`,
        loggerCtx
      );
      return 500;
    }
    const attempts = attemptsHeader ? parseInt(attemptsHeader) : 0;
    const job = new Job({
      id: message.id,
      queueName: message.queueName,
      data: message.data as JsonCompatible<unknown>,
      attempts: attempts,
      state: JobState.RUNNING,
      startedAt: new Date(),
      createdAt: message.createdAt,
      retries: message.maxRetries,
    });
    try {
      await processFn(job);
      Logger.debug(
        `Successfully handled ${message.id} after ${attempts} attempts`,
        loggerCtx
      );
      await this.saveWithRetry(
        new JobRecord({
          id: job.id,
          queueName: job.queueName,
          data: job.data,
          attempts: job.attempts,
          state: JobState.COMPLETED,
          startedAt: job.startedAt,
          createdAt: job.createdAt,
          retries: job.retries,
          isSettled: true,
          settledAt: new Date(),
          progress: 100,
        })
      );
      return 200;
    } catch (error: any) {
      if (this.options.onJobFailure) {
        try {
          await this.options.onJobFailure(error);
        } catch (e: any) {
          Logger.error(`Error in 'onJobFailure': ${e}`, loggerCtx);
        }
      }
      if (attempts === job.retries) {
        Logger.error(
          `Failed to handle message ${message.id} after final attempt (${attempts} attempts made). Marking with status 200 to prevent retries: ${error}`,
          loggerCtx
        );
        await this.saveWithRetry(
          new JobRecord({
            id: job.id,
            queueName: job.queueName,
            data: job.data,
            attempts: job.attempts,
            state: JobState.FAILED,
            startedAt: job.startedAt,
            createdAt: job.createdAt,
            retries: job.retries,
            isSettled: true,
            settledAt: new Date(),
            progress: 0,
            result: error?.message ?? error.toString(),
          })
        ).catch((e: any) => {
          Logger.error(`Failed `, loggerCtx);
        });
        return 200;
      } else {
        Logger.warn(
          `Failed to handle message ${message.id} after ${attempts} attempts. Retrying... ${error}`,
          loggerCtx
        );
        return 500;
      }
    }
  }
  async stop<Data extends JobData<Data> = {}>(
    queueName: string,
    _process: (job: Job<Data>) => Promise<any>
  ) {
    this.PROCESS_MAP.delete(this.getQueueName(queueName));
    Logger.info(`Stopped queue ${this.getQueueName(queueName)}`, loggerCtx);
  }
  private async saveWithRetry(jobRecord: JobRecord): Promise<JobRecord> {
    try {
      return await this.jobRecordRepository.save(jobRecord);
    } catch (e: any) {
      if (e?.message?.indexOf('ER_DATA_TOO_LONG') > -1) {
        jobRecord.data = undefined;
        return await this.jobRecordRepository.save(jobRecord);
      }
      throw e;
    }
  }
  private getQueueName(name: string): string {
    return this.options.queueSuffix
      ? `${name}-${this.options.queueSuffix}`
      : name;
  }
  private getQueuePath(queueName: string): string {
    return this.client.queuePath(
      this.options.projectId,
      this.options.location,
      queueName
    );
  }
  private fromRecord(this: void, jobRecord: JobRecord): Job<any> {
    return new Job<any>(jobRecord);
  }
  private async createQueue(queueName: string): Promise<void> {
    if (this.LIVE_QUEUES.has(queueName)) {
      return;
    }
    try {
      await this.client.createQueue({
        parent: this.client.locationPath(
          this.options.projectId,
          this.options.location
        ),
        queue: { name: this.getQueuePath(queueName) },
      });
      this.LIVE_QUEUES.add(queueName);
    } catch (error: any) {
      if (error?.message?.indexOf('Queue already exists') > -1) {
        this.LIVE_QUEUES.add(queueName);
        Logger.debug(`Queue ${queueName} already exists`, loggerCtx);
      } else {
        throw error;
      }
    }
  }
}
```

## File: packages/vendure-plugin-google-cloud-tasks/src/cloud-tasks.plugin.ts

```typescript
import {
  PluginCommonModule,
  RuntimeVendureConfig,
  VendurePlugin,
  Logger,
} from '@vendure/core';
import { CloudTasksJobQueueStrategy } from './cloud-tasks-job-queue.strategy';
import { CloudTasksController } from './cloud-tasks-controller';
import { CloudTasksService } from './cloud-tasks-service';
import { CloudTaskOptions } from './types';
import { JobRecord } from '@vendure/core/dist/plugin/default-job-queue-plugin/job-record.entity';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from './constants';
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [CloudTasksController],
  entities: [JobRecord],
  providers: [
    CloudTasksService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => CloudTasksPlugin.options,
    },
  ],
  configuration: (config: RuntimeVendureConfig) => {
    config.jobQueueOptions.jobQueueStrategy = new CloudTasksJobQueueStrategy();
    return config;
  },
  compatibility: '>=2.2.0',
})
export class CloudTasksPlugin {
  static options: CloudTaskOptions;
  static init(options: CloudTaskOptions): typeof CloudTasksPlugin {
    this.options = options;
    if (
      this.options?.createTaskRetries &&
      this.options?.createTaskRetries > 20
    ) {
      this.options.createTaskRetries = 20;
      Logger.warn(
        `createTaskRetries can be set to a maximum of 20 retries. This is to avoid too many stacked create task retries`,
        loggerCtx
      );
    }
    return CloudTasksPlugin;
  }
}
```

## File: packages/vendure-plugin-google-cloud-tasks/src/constants.ts

```typescript
export const loggerCtx = 'CloudTaskPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-google-cloud-tasks/src/types.ts

```typescript
import { ClientOptions } from 'google-gax';
export interface CloudTaskOptions {
  taskHandlerHost: string;
  projectId: string;
  location: string;
  authSecret: string;
  onJobFailure?: (error: any) => void | Promise<void>;
  queueSuffix?: string;
  defaultJobRetries?: number;
  createTaskRetries?: number;
  clientOptions?: ClientOptions;
}
export interface CloudTaskMessage {
  id: string | number;
  data: unknown;
  queueName: string;
  createdAt: Date;
  maxRetries: number;
}
export const ROUTE = 'cloud-tasks';
```

## File: packages/vendure-plugin-google-cloud-tasks/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  InitialData,
  DefaultSearchPlugin,
  DefaultLogger,
  LogLevel,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { CloudTasksPlugin } from '../src/cloud-tasks.plugin';
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  require('dotenv').config();
  testConfig.plugins.push(
    CloudTasksPlugin.init({
      taskHandlerHost: process.env.PUBLIC_VENDURE_URL!,
      projectId: process.env.GCLOUD_PROJECT!,
      location: process.env.TASKQUEUE_LOCATION!,
      authSecret: 'some-secret-to-authenticate-cloud-tasks',
      queueSuffix: 'plugin-test2',
      clientOptions: {
        fallback: true,
      },
    })
  );
  testConfig.plugins.push(AdminUiPlugin.init({ route: 'admin', port: 3002 }));
  testConfig.plugins.push(DefaultSearchPlugin);
  testConfig.logger = new DefaultLogger({ level: LogLevel.Debug });
  const { server } = createTestEnvironment(testConfig);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-google-cloud-tasks/test/e2e.spec.ts

```typescript
import {
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { gql } from 'graphql-tag';
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { CloudTasksPlugin } from '../src/cloud-tasks.plugin';
let task: { url: string; body: string };
const mockClient = {
  createTask: vi
    .fn()
    .mockImplementation((request) => (task = request.task.httpRequest)),
  createQueue: vi.fn(),
  locationPath: vi.fn(),
  queuePath: vi.fn(),
};
vi.mock('@google-cloud/tasks', () => ({
  CloudTasksClient: vi.fn().mockImplementation(() => mockClient),
}));
describe('CloudTasks job queue e2e', () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  testConfig.plugins.push(
    CloudTasksPlugin.init({
      taskHandlerHost: 'https://localhost',
      projectId: 'test-project',
      location: 'europe-west1',
      authSecret: 'some-secret',
      queueSuffix: 'plugin-test',
      defaultJobRetries: 50,
      onJobFailure: async (error) => {
        console.log('Custom error handler', error);
      },
      clientOptions: {
        fallback: true,
      },
    })
  );
  testConfig.plugins.push(DefaultSearchPlugin);
  testConfig.logger = new DefaultLogger({ level: LogLevel.Debug });
  testConfig.apiOptions.port = 3103;
  const { server, adminClient } = createTestEnvironment(testConfig);
  let started = false;
  beforeAll(async () => {
    await server.init({
      initialData: initialData as InitialData,
      productsCsvPath: '../test/src/products-import.csv',
    });
    started = true;
  }, 60000);
  it('Should start successfully', async () => {
    expect(started).toBe(true);
  });
  let reindexId: string;
  it('Should create a Queue and Task', async () => {
    await adminClient.asSuperAdmin();
    ({
      reindex: { id: reindexId },
    } = await adminClient.query(
      gql`
        mutation {
          reindex {
            id
          }
        }
      `
    ));
    expect(reindexId).toBeDefined();
    expect(mockClient.locationPath).lastCalledWith(
      'test-project',
      'europe-west1'
    );
    expect(mockClient.queuePath).lastCalledWith(
      'test-project',
      'europe-west1',
      'update-search-index-plugin-test'
    );
    expect(mockClient.createQueue).toHaveBeenCalled();
    expect(mockClient.createTask).toHaveBeenCalled();
    expect(task.url).toBe('https://localhost/cloud-tasks/handler');
    const body = JSON.parse(Buffer.from(task.body, 'base64').toString('utf8'));
    expect(body.maxRetries).toBe(50);
  });
  it('Should fail unauthorized webhook', async () => {
    const buff = new Buffer(task.body, 'base64');
    const res = await adminClient.fetch(
      `http:
      {
        method: 'post',
        body: buff.toString(),
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer malicious-attempt',
        },
      }
    );
    expect(res.status).toBe(401);
  });
  it('Should handle incoming task', async () => {
    const buff = new Buffer(task.body, 'base64');
    const res = await adminClient.fetch(
      `http://localhost:3103/cloud-tasks/handler`,
      {
        method: 'post',
        body: buff.toString(),
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer some-secret',
        },
      }
    );
    expect(res.status).toBe(200);
  });
  it('Should have successful jobs in database', async () => {
    await adminClient.asSuperAdmin();
    const data: any = await adminClient.query(
      gql`
        query {
          jobs(options: { filter: { isSettled: { eq: true } } }) {
            totalItems
          }
        }
      `
    );
    expect(data.jobs?.totalItems).toBeGreaterThan(0);
  });
  it('Should clear settled jobs', async () => {
    const res = await adminClient.fetch(
      `http:
      {
        method: 'get',
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer some-secret',
        },
      }
    );
    expect(res.status).toBe(200);
  });
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-google-cloud-tasks/vitest.config.ts

```typescript
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    testTimeout: 10000,
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-google-storage-assets/src/asset-thumbnail.resolvers.ts

```typescript
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { Asset, ConfigService, Ctx, RequestContext } from '@vendure/core';
@Resolver()
export class AssetThumbnailResolvers {
  constructor(private configService: ConfigService) {}
  @ResolveField('thumbnail')
  @Resolver('Asset')
  thumbnail(@Ctx() ctx: RequestContext, @Parent() asset: Asset): string {
    const { assetOptions } = this.configService;
    if (assetOptions.assetStorageStrategy.toAbsoluteUrl) {
      return assetOptions.assetStorageStrategy.toAbsoluteUrl(
        ctx.req!,
        `${asset.preview}_thumbnail.jpg`
      );
    } else {
      return `${asset.preview}_thumbnail.jpg`;
    }
  }
}
```

## File: packages/vendure-plugin-google-storage-assets/src/asset-thumbnail.schema.ts

```typescript
import gql from 'graphql-tag';
export const assetThumbnailSchema = gql`
  extend type Asset {
    thumbnail: String!
  }
`;
```

## File: packages/vendure-plugin-google-storage-assets/src/google-storage-config.ts

```typescript
import type { StorageOptions } from '@google-cloud/storage';
export interface GoogleStorageConfig {
  bucketName: string;
  thumbnails?: {
    height: number;
    width: number;
  };
  storageOptions?: StorageOptions;
  useAssetServerForAdminUi?: boolean;
}
```

## File: packages/vendure-plugin-google-storage-assets/src/google-storage-plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { assetThumbnailSchema } from './asset-thumbnail.schema';
import { AssetThumbnailResolvers } from './asset-thumbnail.resolvers';
@VendurePlugin({
  imports: [PluginCommonModule],
  shopApiExtensions: {
    schema: assetThumbnailSchema,
    resolvers: [AssetThumbnailResolvers],
  },
  adminApiExtensions: {
    schema: assetThumbnailSchema,
    resolvers: [AssetThumbnailResolvers],
  },
  compatibility: '>=2.2.0',
})
export class GoogleStoragePlugin {
  context = 'GoogleStoragePlugin';
}
```

## File: packages/vendure-plugin-google-storage-assets/src/google-storage-strategy.ts

```typescript
import { AssetStorageStrategy } from '@vendure/core';
import { Storage } from '@google-cloud/storage';
import { Request } from 'express';
import { Stream } from 'stream';
import * as tmp from 'tmp';
import * as fs from 'fs';
import { GoogleStorageConfig } from './google-storage-config';
import sharp from 'sharp';
export class GoogleStorageStrategy implements AssetStorageStrategy {
  storage: Storage;
  urlPrefix = 'https://storage.googleapis.com';
  bucketName: string;
  readonly useAssetServerForAdminUi: boolean;
  constructor(private config: GoogleStorageConfig) {
    this.bucketName = config.bucketName;
    this.useAssetServerForAdminUi =
      config.useAssetServerForAdminUi === undefined
        ? true
        : config.useAssetServerForAdminUi;
    if (!config.thumbnails) {
      config.thumbnails = {
        height: 300,
        width: 300,
      };
    }
    this.storage = new Storage(config.storageOptions ?? {});
  }
  toAbsoluteUrl(request: Request | undefined, identifier: string): string {
    const apiType =
      (request as any)?.vendureRequestContext?.default?._apiType ||
      (request as any)?.vendureRequestContext?._apiType;
    if (this.useAssetServerForAdminUi && apiType === 'admin') {
      return `${request!.protocol}://${request!.get(
        'host'
      )}/assets/${identifier}`;
    }
    return `${this.urlPrefix}/${this.bucketName}/${identifier}`;
  }
  async deleteFile(identifier: string): Promise<void> {
    await this.storage.bucket(this.bucketName).file(identifier).delete();
  }
  async fileExists(fileName: string): Promise<boolean> {
    const [exists] = await this.storage
      .bucket(this.bucketName)
      .file(fileName)
      .exists();
    return exists;
  }
  async readFileToBuffer(identifier: string): Promise<Buffer> {
    if (identifier?.startsWith('/')) {
      identifier = identifier.replace('/', '');
    }
    const tmpFile = tmp.fileSync();
    await this.storage
      .bucket(this.bucketName)
      .file(identifier)
      .download({ destination: tmpFile.name });
    return fs.readFileSync(tmpFile.name);
  }
  async readFileToStream(identifier: string): Promise<Stream> {
    if (identifier?.startsWith('/')) {
      identifier = identifier.replace('/', '');
    }
    return this.storage
      .bucket(this.bucketName)
      .file(identifier)
      .createReadStream();
  }
  async writeFileFromBuffer(fileName: string, data: Buffer): Promise<string> {
    const tmpFile = tmp.fileSync();
    fs.writeFileSync(tmpFile.name, data);
    await this.storage.bucket(this.bucketName).upload(tmpFile.name, {
      destination: fileName,
    });
    if (fileName.startsWith('preview/')) {
      // For each preview, we also generate a thumbnail version
      await this.writeThumbnail(fileName, tmpFile.name);
    }
    return fileName;
  }
  async writeFileFromStream(fileName: string, data: Stream): Promise<string> {
    const blob = this.storage.bucket(this.bucketName).file(fileName);
    const uploadStream = blob.createWriteStream();
    await Promise.all([
      this.streamToPromise(data.pipe(uploadStream)),
      this.streamToPromise(uploadStream),
    ]);
    return fileName;
  }
  streamToPromise(stream: Stream): Promise<void> {
    return new Promise(function (resolve, reject) {
      stream.on('end', resolve);
      stream.on('finish', resolve);
      stream.on('close', resolve);
      stream.on('error', reject);
    });
  }
  async writeThumbnail(fileName: string, localFilePath: string): Promise<void> {
    const tmpFile = tmp.fileSync({ postfix: '.jpg' });
    await sharp(localFilePath)
      .resize({
        width: this.config.thumbnails!.width,
        height: this.config.thumbnails!.height,
      })
      .flatten({ background: '#ffffff' })
      .toFile(tmpFile.name);
    await this.storage.bucket(this.bucketName).upload(tmpFile.name, {
      destination: `${fileName}_thumbnail.jpg`,
    });
  }
}
```

## File: packages/vendure-plugin-google-storage-assets/src/index.ts

```typescript
export * from './google-storage-strategy';
export * from './google-storage-plugin';
export * from './google-storage-config';
```

## File: packages/vendure-plugin-google-storage-assets/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  InitialData,
} from '@vendure/core';
import { AssetServerPlugin } from '@vendure/asset-server-plugin';
import { GoogleStorageStrategy } from '../src';
import { GoogleStoragePlugin } from '../src';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import dotenv from 'dotenv';
(async () => {
  dotenv.config();
  testConfig.logger = new DefaultLogger({ level: LogLevel.Debug });
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  testConfig.plugins.push(
    AssetServerPlugin.init({
      storageStrategyFactory: () =>
        new GoogleStorageStrategy({
          bucketName: process.env.BUCKET!,
        }),
      route: 'assets',
      assetUploadDir: '/tmp/vendure/assets',
    })
  );
  testConfig.plugins.push(GoogleStoragePlugin);
  testConfig.plugins.push(DefaultSearchPlugin);
  testConfig.plugins.push(AdminUiPlugin.init({ route: 'admin', port: 3002 }));
  testConfig.apiOptions.shopApiPlayground = {};
  testConfig.apiOptions.adminApiPlayground = {};
  const { server } = createTestEnvironment(testConfig);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-google-storage-assets/test/e2e.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import {
  DefaultLogger,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { TestServer } from '@vendure/testing/lib/test-server';
import { AssetServerPlugin } from '@vendure/asset-server-plugin';
import { GoogleStoragePlugin, GoogleStorageStrategy } from '../src';
import { describe, it, expect, afterAll, beforeAll } from 'vitest';
describe('Google Storage Assets plugin', () => {
  let server: TestServer;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3102,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        AssetServerPlugin.init({
          storageStrategyFactory: () =>
            new GoogleStorageStrategy({
              bucketName: 'testBucket',
            }),
          route: 'assets',
          assetUploadDir: '/tmp/vendure/assets',
        }),
        GoogleStoragePlugin,
      ],
    });
    ({ server } = createTestEnvironment(config));
    await server.init({
      initialData: initialData as InitialData,
      productsCsvPath: '../test/src/products-import.csv',
    });
  }, 20000);
  it('Should start server', async () => {
    await expect(server.app.getHttpServer).toBeDefined();
  });
  afterAll(() => {
    return server.destroy();
  }, 20000);
});
```

## File: packages/vendure-plugin-google-storage-assets/vitest.config.ts

```typescript
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    testTimeout: 20000,
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-invoices/src/api/api-extensions.ts

```typescript
import gql from 'graphql-tag';
const scalars = gql`
  scalar DateTime
  scalar JSON
  scalar LogicalOperator
  scalar StringOperators
  scalar Money
`;
const commonSchemaExtensions = gql`
  type InvoiceTaxSummary {
    description: String!
    taxBase: Money!
    taxRate: Money!
    taxTotal: Money!
  }
  """
  The order totals that were used to generate the invoice.
  These are used to generate credit invoices.
  """
  type InvoiceOrderTotals {
    taxSummaries: [InvoiceTaxSummary!]!
    total: Money!
    totalWithTax: Money!
  }
  type Invoice {
    id: ID!
    createdAt: DateTime
    invoiceNumber: Int!
    downloadUrl: String!
    orderCode: String!
    orderId: ID!
    isCreditInvoice: Boolean!
    accountingReference: InvoiceAccountingReference
    orderTotals: InvoiceOrderTotals!
  }
  extend type Order {
    invoices: [Invoice!]!
  }
  type InvoiceAccountingReference {
    reference: String
    link: String
    errorMessage: String
  }
`;
export const shopSchemaExtensions = gql`
  ${commonSchemaExtensions}
`;
export const adminSchemaExtensions = gql`
  ${commonSchemaExtensions}
  type InvoiceConfig {
    id: ID!
    enabled: Boolean!
    createCreditInvoices: Boolean!
    templateString: String!
  }
  type InvoiceList {
    items: [Invoice!]!
    totalItems: Int!
  }
  input InvoiceConfigInput {
    enabled: Boolean!
    createCreditInvoices: Boolean
    templateString: String
  }
  input InvoiceListFilter {
    orderCode: StringOperators
    invoiceNumber: StringOperators
  }
  input InvoiceListOptions {
    skip: Int
    take: Int
    filter: InvoiceListFilter
    filterOperator: LogicalOperator
    sort: JSON
  }
  extend type Mutation {
    upsertInvoiceConfig(input: InvoiceConfigInput): InvoiceConfig!
    """
    Generate a new invoice for the given order. Creates a credit invoice if the order already has an invoice.
    """
    createInvoice(orderId: ID!): Invoice!
    """
    Export the given invoice to the configured accounting platform.
    This is done via the Job Queue, so monitor invoice.accountingReference to see if the export succeeded.
    """
    exportInvoiceToAccountingPlatform(invoiceNumber: Int!): Boolean!
  }
  extend type Query {
    invoiceConfig: InvoiceConfig
    invoices(options: InvoiceListOptions): InvoiceList
  }
`;
```

## File: packages/vendure-plugin-invoices/src/api/invoice-admin.resolver.ts

```typescript
import { Inject } from '@nestjs/common';
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  ID,
  OrderService,
  PaginatedList,
  RequestContext,
  Transaction,
  UserInputError,
} from '@vendure/core';
import { PLUGIN_INIT_OPTIONS } from '../constants';
import { InvoicePluginConfig } from '../index';
import { InvoiceService } from '../services/invoice.service';
import {
  Invoice,
  InvoiceConfigInput,
  QueryInvoicesArgs,
} from '../ui/generated/graphql';
import { InvoiceConfigEntity } from '../entities/invoice-config.entity';
import { invoicePermission } from './invoice-common.resolver';
import { AccountingService } from '../services/accounting.service';
@Resolver()
export class InvoiceAdminResolver {
  constructor(
    private invoiceService: InvoiceService,
    private accountingService: AccountingService,
    private orderService: OrderService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: InvoicePluginConfig
  ) {}
  @Mutation()
  @Allow(invoicePermission.Permission)
  async exportInvoiceToAccountingPlatform(
    @Ctx() ctx: RequestContext,
    @Args('invoiceNumber') invoiceNumber: number
  ): Promise<boolean> {
    this.invoiceService.throwIfInvalidLicense();
    await this.accountingService.exportInvoiceToAccountingPlatform(
      ctx,
      invoiceNumber
    );
    return true;
  }
  @Mutation()
  @Transaction()
  @Allow(invoicePermission.Permission)
  async upsertInvoiceConfig(
    @Ctx() ctx: RequestContext,
    @Args('input') input: InvoiceConfigInput
  ): Promise<InvoiceConfigEntity> {
    this.invoiceService.throwIfInvalidLicense();
    return this.invoiceService.upsertConfig(ctx, input);
  }
  @Mutation()
  @Transaction()
  @Allow(invoicePermission.Permission)
  async createInvoice(
    @Ctx() ctx: RequestContext,
    @Args('orderId') orderId: ID
  ): Promise<Invoice> {
    const order = await this.orderService.findOne(ctx, orderId, ['customer']);
    if (!order?.customer?.emailAddress) {
      throw new UserInputError(
        `Can not generate invoice for an order without 'customer.emailAddress'`
      );
    }
    const invoice = await this.invoiceService.createInvoicesForOrder(
      ctx.channel.token,
      order.code,
      false
    );
    if (!invoice) {
      throw new UserInputError(
        `Could not generate invoice for order. Please check the logs for more information.`
      );
    }
    return {
      ...invoice,
      isCreditInvoice: invoice.isCreditInvoice,
      orderId: order.id,
      orderCode: order.code,
      downloadUrl: this.invoiceService.getDownloadUrl(
        ctx,
        invoice.invoiceNumber,
        order.code,
        order.customer.emailAddress
      ),
    };
  }
  @Query()
  @Allow(invoicePermission.Permission)
  async invoiceConfig(
    @Ctx() ctx: RequestContext
  ): Promise<InvoiceConfigEntity | undefined> {
    this.invoiceService.throwIfInvalidLicense();
    return this.invoiceService.getConfig(ctx);
  }
  @Query()
  @Allow(invoicePermission.Permission)
  async invoices(
    @Ctx() ctx: RequestContext,
    @Args() args: QueryInvoicesArgs
  ): Promise<PaginatedList<Invoice>> {
    this.invoiceService.throwIfInvalidLicense();
    return this.invoiceService.findAll(ctx, args.options || undefined);
  }
}
```

## File: packages/vendure-plugin-invoices/src/api/invoice-common.resolver.ts

```typescript
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  EntityHydrator,
  Order,
  PermissionDefinition,
  RequestContext,
} from '@vendure/core';
import { InvoiceService } from '../services/invoice.service';
import { Invoice } from '../ui/generated/graphql';
export const invoicePermission = new PermissionDefinition({
  name: 'AllowInvoicesPermission',
  description: 'Allow this user to enable invoice generation',
});
@Resolver()
export class InvoiceCommonResolver {
  constructor(
    private invoiceService: InvoiceService,
    private entityHydrator: EntityHydrator
  ) {}
  @ResolveField('invoices')
  @Resolver('Order')
  @Allow(invoicePermission.Permission)
  async invoices(
    @Ctx() ctx: RequestContext,
    @Parent() order: Order
  ): Promise<Invoice[]> {
    const invoices = await this.invoiceService.getInvoicesForOrder(
      ctx,
      order.id
    );
    await this.entityHydrator.hydrate(ctx, order, { relations: ['customer'] });
    if (!order.customer?.emailAddress) {
      return [];
    }
    return invoices.map((invoice) => ({
      ...invoice,
      orderCode: order.code,
      orderId: order.id,
      isCreditInvoice: invoice.isCreditInvoice,
      orderTotals: invoice.orderTotals,
      downloadUrl: this.invoiceService.getDownloadUrl(
        ctx,
        invoice.invoiceNumber,
        order.code,
        order.customer!.emailAddress
      ),
    }));
  }
}
```

## File: packages/vendure-plugin-invoices/src/api/invoice.controller.ts

```typescript
import { InvoiceService } from '../services/invoice.service';
import {
  Controller,
  Get,
  Param,
  Post,
  Query,
  Req,
  Res,
  Body,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { Request, Response } from 'express';
import {
  Allow,
  ChannelService,
  Ctx,
  Logger,
  RequestContext,
  UserInputError,
} from '@vendure/core';
import { loggerCtx } from '../constants';
import { invoicePermission } from './invoice-common.resolver';
@Controller('invoices')
export class InvoiceController {
  constructor(
    private invoiceService: InvoiceService,
    private channelService: ChannelService
  ) {}
  @Allow(invoicePermission.Permission)
  @Get('/download')
  async downloadMultipleInvoices(
    @Ctx() ctx: RequestContext,
    @Query('nrs') numbers: string,
    @Req() req: Request,
    @Res() res: Response
  ) {
    if (!ctx.channelId) {
      throw Error(`Channel id is needed to download invoices`);
    }
    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
    const stream = await this.invoiceService.downloadMultiple(
      ctx,
      numbers.split(','),
      res
    );
    Logger.info(`Invoices ${numbers} downloaded from ${ip}`, loggerCtx);
    stream.pipe(res);
  }
  @Allow(invoicePermission.Permission)
  @Post('/preview/:orderCode?')
  async preview(
    @Ctx() ctx: RequestContext,
    @Res() res: Response,
    @Body() body: { template: string },
    @Param('orderCode') orderCode?: string
  ) {
    if (!ctx.channel?.token) {
      throw new BadRequestException('No channel set for request');
    }
    if (!body?.template || !body?.template.trim()) {
      throw new BadRequestException('No template given');
    }
    const stream = await this.invoiceService.previewInvoiceWithTemplate(
      ctx,
      body.template,
      orderCode
    );
    res.set({
      'Content-Type': 'application/pdf',
      'Content-Disposition': `inline; filename="preview-invoice.pdf"`,
    });
    return stream.pipe(res);
  }
  @Get('/:channelToken/:orderCode/:invoiceNumber?')
  async downloadInvoice(
    @Param('channelToken') channelToken: string,
    @Param('orderCode') orderCode: string,
    @Param('invoiceNumber') invoiceNumber: string | number | undefined,
    @Query('email') encodedCustomerEmail: string,
    @Req() req: Request,
    @Res() res: Response
  ) {
    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
    if (!channelToken || !orderCode || !encodedCustomerEmail) {
      Logger.warn(
        `Invalid invoice download attempt from ${ip} for ${req.path}`,
        loggerCtx
      );
      throw new BadRequestException();
    }
    try {
      const customerEmail = decodeURIComponent(encodedCustomerEmail);
      const channel = await this.channelService.getChannelFromToken(
        channelToken
      );
      if (channel.token !== channelToken) {
        throw new UserInputError(
          `No channel found with token '${channelToken}'`
        );
      }
      const ctx = new RequestContext({
        apiType: 'admin',
        authorizedAsOwnerOnly: false,
        isAuthorized: true,
        channel,
      });
      const streamOrRedirect = await this.invoiceService.downloadInvoice(ctx, {
        orderCode,
        customerEmail,
        invoiceNumber,
        res,
      });
      Logger.info(
        `Invoice downloaded from ${JSON.stringify(ip)} for ${req.path}`,
        loggerCtx
      );
      if (
        typeof streamOrRedirect === 'string' ||
        streamOrRedirect instanceof String
      ) {
        return res.redirect(302, streamOrRedirect as string);
      } else {
        return streamOrRedirect.pipe(res);
      }
    } catch (error: any) {
      Logger.warn(
        `Failed invoice download attempt from ${JSON.stringify(ip)} for ${
          req.path
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        }: ${error.message}`,
        loggerCtx
      );
      throw new ForbiddenException(
        'This invoice does not exist or you are not authorized to download it'
      );
    }
  }
}
```

## File: packages/vendure-plugin-invoices/src/entities/invoice-config.entity.ts

```typescript
import { DeepPartial, Logger, VendureEntity } from '@vendure/core';
import { Column, ColumnType, Entity } from 'typeorm';
import { loggerCtx } from '../constants';
@Entity('invoice_config')
export class InvoiceConfigEntity extends VendureEntity {
  constructor(input?: DeepPartial<InvoiceConfigEntity>) {
    super(input);
  }
  @Column()
  channelId!: string;
  @Column({ default: false })
  enabled: boolean = false;
  @Column({ default: true })
  createCreditInvoices: boolean = true;
  @Column({ type: resolveTemplateColumnType(), nullable: true })
  templateString?: string | null;
}
function resolveTemplateColumnType(): ColumnType {
  const dbEngine = process.env.INVOICES_PLUGIN_DB_ENGINE;
  if (!dbEngine) {
    return 'text';
  } else if (dbEngine === 'mysql' || dbEngine === 'mariadb') {
    return 'longtext';
  } else if (dbEngine === 'postgres') {
    return 'text';
  } else if (dbEngine === 'cockroachdb') {
    return 'string';
  } else if (dbEngine === 'mssql') {
    return 'text';
  } else if (dbEngine === 'sqlite') {
    return 'text';
  } else if (dbEngine === 'oracle') {
    return 'clob';
  } else {
    Logger.warn(
      `No large-text column type available for DB engine "${dbEngine}", using "text". ( Contributions welcome )`,
      loggerCtx
    );
  }
  return 'text';
}
```

## File: packages/vendure-plugin-invoices/src/entities/invoice.entity.ts

```typescript
import { DeepPartial, VendureEntity } from '@vendure/core';
import { Column, Entity, Unique, Index, OneToMany, ManyToOne } from 'typeorm';
import { InvoiceOrderTotals } from '../ui/generated/graphql';
@Entity('invoice')
@Unique(['channelId', 'invoiceNumber'])
export class InvoiceEntity extends VendureEntity {
  constructor(input?: DeepPartial<InvoiceEntity>) {
    super(input);
  }
  @Index()
  @Column()
  channelId!: string;
  @Index()
  @Column({ nullable: false })
  orderId!: string;
  @Column({ nullable: false, type: 'int' })
  invoiceNumber!: number;
  @Column({ nullable: false })
  storageReference!: string;
  @Column({ nullable: false, default: false })
  isCreditInvoice!: boolean;
  @OneToMany(() => InvoiceEntity, (invoice) => invoice.isCreditInvoiceFor)
  creditInvoices?: InvoiceEntity[];
  @ManyToOne(() => InvoiceEntity, (invoice) => invoice.creditInvoices)
  isCreditInvoiceFor: InvoiceEntity | undefined;
  @Column({ nullable: true, type: 'simple-json' })
  orderTotals!: InvoiceOrderTotals;
  @Column({ nullable: true, type: 'simple-json' })
  accountingReference:
    | {
        reference: string;
        link?: string;
        errorMessage?: string;
      }
    | undefined;
}
```

## File: packages/vendure-plugin-invoices/src/scripts/populate-invoice-fields.ts

```typescript

```

## File: packages/vendure-plugin-invoices/src/services/accounting.service.ts

```typescript
import { Inject, Injectable, OnModuleInit } from '@nestjs/common';
import {
  EntityRelationPaths,
  JobQueue,
  JobQueueService,
  Logger,
  Order,
  OrderService,
  RequestContext,
  SerializedRequestContext,
  TransactionalConnection,
  UserInputError,
} from '@vendure/core';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { InvoiceEntity } from '../entities/invoice.entity';
import { InvoicePluginConfig } from '../invoice.plugin';
import {
  AccountingExportStrategy,
  ExternalReference,
} from '../strategies/accounting/accounting-export-strategy';
@Injectable()
export class AccountingService implements OnModuleInit {
  constructor(
    private connection: TransactionalConnection,
    private jobQueueService: JobQueueService,
    private orderService: OrderService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: InvoicePluginConfig
  ) {}
  accountingExportQueue!: JobQueue<{
    ctx: SerializedRequestContext;
    orderCode: string;
    invoiceNumber: number;
  }>;
  orderRelations: EntityRelationPaths<Order>[] = [
    'lines.productVariant.product',
    'shippingLines.shippingMethod',
    'payments',
    'customer',
  ];
  async onModuleInit(): Promise<void> {
    this.accountingExportQueue = await this.jobQueueService.createQueue({
      name: 'export-invoice-to-accounting',
      process: async (job) => {
        await this.handleAccountingExportJob(
          RequestContext.deserialize(job.data.ctx),
          job.data.invoiceNumber,
          job.data.orderCode
        ).catch((error: Error) => {
          Logger.warn(
            `Failed to export invoice '${job.data.invoiceNumber}' to accounting platform for '${job.data.orderCode}': ${error?.message}`,
            loggerCtx
          );
          throw error;
        });
      },
    });
  }
  findAccountingExportStrategyForChannel(
    ctx: RequestContext
  ): AccountingExportStrategy | undefined {
    return (this.config.accountingExports || []).find(
      (s) => s.channelToken === ctx.channel.token || !s.channelToken
    );
  }
  async exportInvoiceToAccountingPlatform(
    ctx: RequestContext,
    invoiceNumber: number
  ): Promise<void> {
    if (!this.findAccountingExportStrategyForChannel(ctx)) {
      throw new UserInputError(
        `No account exports configured for channel '${ctx.channel.token}'`
      );
    }
    const invoice = await this.getInvoiceByNumber(ctx, invoiceNumber);
    const order = await this.orderService.findOne(ctx, invoice.orderId, []);
    if (!order) {
      throw new UserInputError(
        `No order found with id '${invoice.orderId}'. Can not export invoice without order`
      );
    }
    await this.createAccountingExportJob(
      ctx,
      invoice.invoiceNumber,
      order.code
    );
  }
  async handleAccountingExportJob(
    ctx: RequestContext,
    invoiceNumber: number,
    orderCode: string
  ): Promise<void> {
    const strategy = this.findAccountingExportStrategyForChannel(ctx);
    if (!strategy) {
      Logger.warn(
        `No accounting export strategy found for channel ${ctx.channel.token}. Not exporting invoice '${invoiceNumber}' for order '${orderCode}'`,
        loggerCtx
      );
      return;
    }
    const [order, invoice] = await Promise.all([
      this.orderService.findOneByCode(ctx, orderCode, this.orderRelations),
      this.getInvoiceByNumber(ctx, invoiceNumber),
    ]);
    if (!order) {
      throw Error(`[${loggerCtx}] No order found with code ${orderCode}`);
    }
    const invoiceRepository = this.connection.getRepository(ctx, InvoiceEntity);
    try {
      if (
        !this.orderMatchesInvoice(order, invoice) &&
        !invoice.isCreditInvoice
      ) {
        throw Error(
          `Order '${order.code}' has changed compared to the invoice. Can not export this invoice again!`
        );
      }
      let reference: ExternalReference;
      if (invoice.isCreditInvoice) {
        reference = await strategy.exportCreditInvoice(
          ctx,
          invoice,
          invoice.isCreditInvoiceFor!,
          order
        );
      } else {
        reference = await strategy.exportInvoice(ctx, invoice, order);
      }
      await invoiceRepository.update(invoice.id, {
        accountingReference: reference,
      });
      Logger.info(
        `Exported invoice '${invoiceNumber}' for order '${orderCode}' to accounting system '${strategy.constructor.name}' with reference '${reference.reference}'`,
        loggerCtx
      );
    } catch (e) {
      await invoiceRepository.update(invoice.id, {
        accountingReference: {
          errorMessage:
            (e as Error)?.message ||
            `Unknown error occured at ${new Date().toISOString()}`,
        },
      });
      throw e;
    }
  }
  async createAccountingExportJob(
    ctx: RequestContext,
    invoiceNumber: number,
    orderCode: string
  ): Promise<void> {
    if (!this.findAccountingExportStrategyForChannel(ctx)) {
      Logger.debug(`No accounting export strategies configured`, loggerCtx);
      return;
    }
    await this.accountingExportQueue.add(
      {
        ctx: ctx.serialize(),
        invoiceNumber,
        orderCode,
      },
      {
        retries: 10,
      }
    );
    Logger.info(
      `Added accounting export job for invoice '${invoiceNumber}' for order '${orderCode}'`,
      loggerCtx
    );
  }
  private orderMatchesInvoice(order: Order, invoice: InvoiceEntity): boolean {
    if (
      order.total !== invoice.orderTotals.total ||
      order.totalWithTax !== invoice.orderTotals.totalWithTax
    ) {
      return false;
    }
    return order.taxSummary.every((orderSummary) => {
      const matchingInvoiceSummary = invoice.orderTotals.taxSummaries.find(
        (invoiceSummary) =>
          invoiceSummary.taxRate === orderSummary.taxRate &&
          invoiceSummary.taxBase === orderSummary.taxBase
      );
      return !!matchingInvoiceSummary;
    });
  }
  private async getInvoiceByNumber(
    ctx: RequestContext,
    invoiceNumber: number
  ): Promise<InvoiceEntity> {
    const invoice = await this.connection
      .getRepository(ctx, InvoiceEntity)
      .findOne({
        where: { invoiceNumber, channelId: String(ctx.channelId) },
        relations: ['isCreditInvoiceFor'],
      });
    if (!invoice) {
      throw Error(`[${loggerCtx}] No invoice found with code ${invoiceNumber}`);
    }
    return invoice;
  }
}
```

## File: packages/vendure-plugin-invoices/src/services/invoice-created-event.ts

```typescript
import { Order, RequestContext, VendureEvent } from '@vendure/core';
import { InvoiceEntity } from '../entities/invoice.entity';
export class InvoiceCreatedEvent extends VendureEvent {
  public ctx: RequestContext;
  public order: Order;
  public newInvoice: InvoiceEntity;
  public previousInvoice?: InvoiceEntity;
  public creditInvoice?: InvoiceEntity;
  constructor(input: {
    ctx: RequestContext;
    order: Order;
    newInvoice: InvoiceEntity;
    previousInvoice?: InvoiceEntity;
    creditInvoice?: InvoiceEntity;
  }) {
    super();
    this.ctx = input.ctx;
    this.order = input.order;
    this.newInvoice = input.newInvoice;
    this.previousInvoice = input.previousInvoice;
    this.creditInvoice = input.creditInvoice;
  }
}
```

## File: packages/vendure-plugin-invoices/src/services/invoice.service.ts

```typescript
import {
  Inject,
  Injectable,
  OnApplicationBootstrap,
  OnModuleInit,
} from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  ChannelService,
  EntityRelationPaths,
  EventBus,
  ID,
  idsAreEqual,
  Injector,
  JobQueue,
  JobQueueService,
  ListQueryBuilder,
  ListQueryOptions,
  Logger,
  Order,
  OrderPlacedEvent,
  OrderService,
  OrderStateTransitionEvent,
  PaginatedList,
  RequestContext,
  TransactionalConnection,
  UserInputError,
} from '@vendure/core';
import { Response } from 'express';
import { createReadStream, ReadStream } from 'fs';
import Handlebars from 'handlebars';
import {
  Invoice,
  InvoiceConfigInput,
  InvoiceListFilter,
  InvoiceListOptions,
  InvoiceOrderTotals,
} from '../ui/generated/graphql';
import {
  LogicalOperator,
  SortOrder,
} from '@vendure/common/lib/generated-shop-types';
import { QueryDeepPartialEntity } from 'typeorm/query-builder/QueryPartialEntity';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { InvoiceConfigEntity } from '../entities/invoice-config.entity';
import { InvoiceEntity } from '../entities/invoice.entity';
import { InvoicePluginConfig } from '../invoice.plugin';
import { CreditInvoiceInput } from '../strategies/load-data-fn';
import {
  LocalStorageStrategy,
  RemoteStorageStrategy,
} from '../strategies/storage/storage-strategy';
import { defaultTemplate } from '../util/default-template';
import { createTempFile } from '../util/file.util';
import { reverseOrderTotals } from '../util/order-calculations';
import { InvoiceCreatedEvent } from './invoice-created-event';
import puppeteer from 'puppeteer';
import { Browser } from 'puppeteer';
import { filter } from 'rxjs';
import { In } from 'typeorm';
import { parseFilterParams } from '@vendure/core/dist/service/helpers/list-query-builder/parse-filter-params';
import { AccountingService } from './accounting.service';
import util from 'util';
interface DownloadInput {
  customerEmail: string;
  orderCode: string;
  invoiceNumber: string | number | undefined;
  res: Response;
}
@Injectable()
export class InvoiceService implements OnModuleInit, OnApplicationBootstrap {
  generateInvoiceQueue!: JobQueue<{
    channelToken: string;
    orderCode: string;
    creditInvoiceOnly: boolean;
  }>;
  orderRelations: EntityRelationPaths<Order>[] = [
    'lines.productVariant.product',
    'shippingLines.shippingMethod',
    'payments',
    'surcharges',
    'customer',
  ];
  constructor(
    private eventBus: EventBus,
    private jobQueueService: JobQueueService,
    private orderService: OrderService,
    private channelService: ChannelService,
    private listQueryBuilder: ListQueryBuilder,
    private moduleRef: ModuleRef,
    private connection: TransactionalConnection,
    private accountingService: AccountingService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: InvoicePluginConfig
  ) {
    Handlebars.registerHelper('formatMoney', (amount?: number) => {
      if (amount == null) {
        return amount;
      }
      return (amount / 100).toFixed(2);
    });
  }
  async onModuleInit(): Promise<void> {
    this.generateInvoiceQueue = await this.jobQueueService.createQueue({
      name: 'generate-invoice',
      process: async (job) => {
        await this.createInvoicesForOrder(
          job.data.channelToken,
          job.data.orderCode,
          job.data.creditInvoiceOnly
        ).catch((error) => {
          Logger.warn(
            `Failed to generate invoice for ${job.data.orderCode}: ${error?.message}`,
            loggerCtx
          );
          throw error;
        });
      },
    });
  }
  onApplicationBootstrap(): void {
    this.eventBus.ofType(OrderPlacedEvent).subscribe(({ ctx, order }) => {
      this.createInvoiceGenerationJobs(ctx, order.code, 'order-placed').catch(
        (e: Error) =>
          Logger.error(
            `Failed to create invoice jobs for 'order-placed': ${e?.message}`,
            loggerCtx,
            JSON.stringify(e)
          )
      );
    });
    this.eventBus
      .ofType(OrderStateTransitionEvent)
      .pipe(filter((event) => event.toState === 'Cancelled'))
      .subscribe(({ ctx, order }) => {
        this.createInvoiceGenerationJobs(
          ctx,
          order.code,
          'order-cancelled'
        ).catch((e: Error) =>
          Logger.error(
            `Failed to create invoice jobs for 'order-cancelled': ${e?.message}`,
            loggerCtx,
            JSON.stringify(e)
          )
        );
      });
  }
  async findAll(
    ctx: RequestContext,
    options?: InvoiceListOptions
  ): Promise<PaginatedList<Invoice>> {
    const entityOptions: ListQueryOptions<InvoiceEntity> = {
      ...options,
      ...(options?.filter?.invoiceNumber
        ? { filter: { invoiceNumber: options?.filter?.invoiceNumber } }
        : { filter: {} }),
      sort: { updatedAt: SortOrder.DESC },
    };
    const qb = this.listQueryBuilder.build(InvoiceEntity, entityOptions, {
      ctx,
      where: {
        channelId: ctx.channelId.toString(),
      },
      entityAlias: 'invoice',
    });
    if (options?.filter?.orderCode) {
      qb.innerJoin(Order, 'order', 'order.id = invoice.orderId');
      qb.addSelect(['order.id', 'order.code']);
      const filter = parseFilterParams(
        qb.connection,
        Order,
        { code: { ...options?.filter?.orderCode } },
        undefined,
        'order'
      );
      const condition = filter[0];
      condition.clause = condition.clause.replace('arg1', 'argX');
      const parameters = { argX: condition.parameters['arg1'] };
      if (options.filterOperator === LogicalOperator.AND) {
        qb.andWhere(condition.clause, parameters);
      } else {
        qb.orWhere(condition.clause, parameters);
      }
    }
    const [invoices, totalItems] = await qb.getManyAndCount();
    const orderIds = invoices.map((i) => i.orderId);
    const orders = await this.orderService.findAll(
      ctx,
      { filter: { id: { in: orderIds } } },
      ['customer']
    );
    const items: Invoice[] = [];
    for (const invoice of invoices) {
      const order = orders.items.find((o) =>
        idsAreEqual(o.id, invoice.orderId)
      );
      if (!order) {
        Logger.error(
          `No order with id '${invoice.orderId}' found for invoice '${invoice.invoiceNumber}'. Omitting this invoice from the results`,
          loggerCtx
        );
        continue;
      }
      if (!order.customer?.emailAddress) {
        Logger.error(
          `Order '${order.id}' for invoice '${invoice.invoiceNumber}' has no customer. Omitting this invoice from the results`,
          loggerCtx
        );
        continue;
      }
      items.push({
        ...invoice,
        orderCode: order.code,
        orderId: order.id,
        isCreditInvoice: invoice.isCreditInvoice,
        downloadUrl: this.getDownloadUrl(
          ctx,
          invoice.invoiceNumber,
          order.code,
          order.customer.emailAddress
        ),
      });
    }
    return { items, totalItems };
  }
  parseFilter(filter: InvoiceListFilter | undefined) {
    let filterInput = {};
    if (filter?.invoiceNumber) {
      filterInput = {
        invoiceNumber: String(filter?.invoiceNumber),
      };
    }
    if (filter?.orderCode) {
      filterInput = {
        ...filterInput,
        order: {
          code: String(filter?.orderCode),
        },
      };
    }
    return filterInput;
  }
  async downloadMultiple(
    ctx: RequestContext,
    invoiceNumbers: string[],
    res: Response
  ): Promise<ReadStream> {
    if (invoiceNumbers.length > 10) {
      throw new UserInputError(`You can only download 10 invoices at a time`);
    }
    const invoiceRepo = this.connection.getRepository(ctx, InvoiceEntity);
    const invoices = await invoiceRepo.find({
      where: {
        channelId: String(ctx.channelId),
        invoiceNumber: In(invoiceNumbers),
      },
    });
    if (!invoices) {
      throw Error(
        `No invoices found for channel ${
          ctx.channelId
        } and invoiceNumbers ${JSON.stringify(invoiceNumbers)}`
      );
    }
    return this.config.storageStrategy.streamMultiple(invoices, res);
  }
  async createInvoicesForOrder(
    channelToken: string,
    orderCode: string,
    createCreditInvoiceOnly: boolean
  ): Promise<InvoiceEntity | undefined> {
    const ctx = await this.createCtx(channelToken);
    const [order, previousInvoiceForOrder, config] = await Promise.all([
      this.orderService.findOneByCode(ctx, orderCode, this.orderRelations),
      this.getMostRecentInvoiceForOrder(ctx, orderCode),
      this.getConfig(ctx),
    ]);
    if (!config) {
      Logger.warn(
        `Cannot generate invoice for ${orderCode}, because no config was found`,
        loggerCtx
      );
      return;
    }
    if (!config.enabled) {
      Logger.info(
        `Not generating invoice for ${orderCode} for channel ${channelToken}, because invoice generation is disabled in the config.`,
        loggerCtx
      );
      return;
    }
    if (!order) {
      throw new UserInputError(`No order found with code ${orderCode}`);
    }
    if (createCreditInvoiceOnly && !config?.createCreditInvoices) {
      Logger.info(
        `Cannot generate credit invoice only with "createCreditInvoiceOnly=true" for order ${orderCode}, because credit invoices are disabled in the config.`,
        loggerCtx
      );
      return;
    }
    if (createCreditInvoiceOnly && !previousInvoiceForOrder) {
      Logger.info(
        `"createCreditInvoiceOnly=true" was supplied, but no previous invoice exists for order ${orderCode}, so we can not generate a credit invoice.`,
        loggerCtx
      );
      return;
    }
    if (createCreditInvoiceOnly) {
      Logger.info(
        `Creating credit invoice only for order ${orderCode}`,
        loggerCtx
      );
    } else if (previousInvoiceForOrder && config.createCreditInvoices) {
      Logger.info(
        `Creating invoice and credit invoice for order ${orderCode}`,
        loggerCtx
      );
    } else {
      Logger.info(`Creating invoice for order ${orderCode}`, loggerCtx);
    }
    let creditInvoice: InvoiceEntity | undefined;
    if (previousInvoiceForOrder && config.createCreditInvoices) {
      creditInvoice = await this.createAndSaveInvoice(
        ctx,
        order,
        config.templateString!,
        previousInvoiceForOrder
      );
      if (createCreditInvoiceOnly) {
        await this.eventBus.publish(
          new InvoiceCreatedEvent({
            ctx,
            order,
            newInvoice: creditInvoice,
            previousInvoice: previousInvoiceForOrder,
          })
        );
        await this.createAccountingExportJob(
          ctx,
          creditInvoice.invoiceNumber,
          orderCode
        );
        return creditInvoice;
      }
    }
    const newInvoice = await this.createAndSaveInvoice(
      ctx,
      order,
      config.templateString!
    );
    await this.eventBus.publish(
      new InvoiceCreatedEvent({
        ctx,
        order,
        newInvoice,
        previousInvoice: previousInvoiceForOrder,
        creditInvoice,
      })
    );
    if (creditInvoice) {
      await this.createAccountingExportJob(
        ctx,
        creditInvoice.invoiceNumber,
        orderCode
      );
    }
    await this.createAccountingExportJob(
      ctx,
      newInvoice.invoiceNumber,
      orderCode
    );
    return newInvoice;
  }
  private async createAccountingExportJob(
    ctx: RequestContext,
    invoiceNumber: number,
    orderCode: string
  ) {
    await this.accountingService
      .createAccountingExportJob(ctx, invoiceNumber, orderCode)
      .catch((e) => {
        Logger.error(
          `Failed to create accounting export job: ${e?.message}`,
          loggerCtx,
          util.inspect(e, false, 5)
        );
      });
  }
  private async createInvoiceGenerationJobs(
    ctx: RequestContext,
    orderCode: string,
    event: 'order-cancelled' | 'order-placed'
  ) {
    if (!this.generateInvoiceQueue) {
      return Logger.error(`Invoice jobQueue not initialized`, loggerCtx);
    }
    try {
      const enabled = await this.isInvoicePluginEnabled(ctx);
      if (!enabled) {
        return Logger.debug(
          `Invoice generation not enabled for order ${orderCode} in channel ${ctx.channel.token}`,
          loggerCtx
        );
      }
      const creditInvoiceOnly = event === 'order-cancelled';
      await this.generateInvoiceQueue.add(
        {
          channelToken: ctx.channel.token,
          orderCode: orderCode,
          creditInvoiceOnly,
        },
        { retries: 10 }
      );
      return Logger.info(
        `Added invoice job to queue for order ${orderCode}`,
        loggerCtx
      );
    } catch (error: any) {
      Logger.error(
        `Failed to add invoice job to queue: ${error?.message}`,
        loggerCtx
      );
    }
  }
  private async createAndSaveInvoice(
    ctx: RequestContext,
    order: Order,
    templateString: string,
    isCreditInvoiceFor?: InvoiceEntity
  ): Promise<InvoiceEntity> {
    let orderTotals: InvoiceOrderTotals = {
      taxSummaries: order.taxSummary.map((t) => ({
        description: t.description,
        taxRate: t.taxRate,
        taxBase: t.taxBase,
        taxTotal: t.taxTotal,
      })),
      total: order.total,
      totalWithTax: order.totalWithTax,
    };
    if (isCreditInvoiceFor) {
      orderTotals = reverseOrderTotals(isCreditInvoiceFor.orderTotals);
    }
    const { invoiceNumber, invoiceTmpFile } = await this.generatePdfFile(
      ctx,
      templateString,
      order,
      isCreditInvoiceFor
        ? {
            previousInvoice: isCreditInvoiceFor,
            reversedOrderTotals: orderTotals,
          }
        : undefined
    );
    const invoiceRowId = await this.createInvoiceRow(ctx, {
      invoiceNumber,
      orderId: order.id as string,
      isCreditInvoice: !!isCreditInvoiceFor,
      orderTotals,
      isCreditInvoiceFor,
    });
    const storageReference = await this.config.storageStrategy.save(
      invoiceTmpFile,
      invoiceNumber,
      ctx.channel.token,
      !!isCreditInvoiceFor
    );
    const invoiceRepo = this.connection.getRepository(ctx, InvoiceEntity);
    await invoiceRepo.update(invoiceRowId, { storageReference });
    Logger.info(
      `Created ${
        isCreditInvoiceFor ? 'credit ' : ' '
      }invoice ${invoiceNumber} for order ${order.code}`,
      loggerCtx
    );
    return await invoiceRepo.findOneOrFail({ where: { id: invoiceRowId } });
  }
  async generatePdfFile(
    ctx: RequestContext,
    htmlTemplateString: string,
    order: Order,
    shouldGenerateCreditInvoice?: CreditInvoiceInput
  ): Promise<{ invoiceTmpFile: string; invoiceNumber: number }> {
    const latestInvoiceNumber = await this.getLatestInvoiceNumber(ctx);
    const data = await this.config.loadDataFn(
      ctx,
      new Injector(this.moduleRef),
      order,
      latestInvoiceNumber ?? this.config.startInvoiceNumber,
      shouldGenerateCreditInvoice
    );
    const tmpFilePath = await createTempFile('.pdf');
    let browser: Browser | undefined;
    try {
      const compiledHtml = Handlebars.compile(htmlTemplateString)(data);
      browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox'],
      });
      const page = await browser.newPage();
      await page.setContent(compiledHtml);
      await page.pdf({
        path: tmpFilePath,
        format: 'A4',
        margin: { bottom: 100, top: 100, left: 50, right: 50 },
      });
    } catch (e) {
      Logger.warn(
        `Failed to generate invoice: ${JSON.stringify((e as Error)?.message)}`,
        loggerCtx
      );
      throw e;
    } finally {
      if (browser) {
        browser.close().catch((e: Error) => {
          Logger.error(
            `Failed to close puppeteer browser: ${e?.message}`,
            loggerCtx
          );
        });
      }
    }
    return {
      invoiceTmpFile: tmpFilePath,
      invoiceNumber: data.invoiceNumber,
    };
  }
  async previewInvoiceWithTemplate(
    ctx: RequestContext,
    template: string,
    orderCode?: string
  ): Promise<ReadStream> {
    let order: Order | undefined;
    if (orderCode) {
      order = await this.orderService.findOneByCode(
        ctx,
        orderCode,
        this.orderRelations
      );
    } else {
      const orderId = (
        await this.orderService.findAll(
          ctx,
          {
            take: 1,
            sort: { createdAt: SortOrder.DESC },
          },
          []
        )
      )?.items[0].id;
      order = await this.orderService.findOne(
        ctx,
        orderId,
        this.orderRelations
      );
    }
    if (!order) {
      throw new UserInputError(`No order found with code ${orderCode}`);
    }
    const config = await this.getConfig(ctx);
    if (!config) {
      throw Error(`No config found for channel ${ctx.channel.token}`);
    }
    const { invoiceTmpFile } = await this.generatePdfFile(ctx, template, order);
    return createReadStream(invoiceTmpFile);
  }
  async downloadInvoice(
    ctx: RequestContext,
    input: DownloadInput
  ): Promise<ReadStream | string> {
    const order = await this.orderService.findOneByCode(ctx, input.orderCode, [
      'customer',
    ]);
    if (!order) {
      throw Error(`No order found with code ${input.orderCode}`);
    }
    if (order.customer?.emailAddress !== input.customerEmail) {
      throw Error(
        `This order doesn't belong to customer ${input.customerEmail}`
      );
    }
    const invoices = await this.getInvoicesForOrder(ctx, order.id);
    if (!invoices.length) {
      throw Error(`No invoices exists for ${input.orderCode}`);
    }
    let invoice = invoices[0];
    if (input.invoiceNumber) {
      const invoiceWithNumber = invoices.find(
        (i) => i.invoiceNumber == input.invoiceNumber
      );
      if (!invoiceWithNumber) {
        throw new UserInputError(
          `No invoice found with number ${input.invoiceNumber}`
        );
      }
      invoice = invoiceWithNumber;
    }
    const strategy = this.config.storageStrategy;
    if ((strategy as RemoteStorageStrategy).getPublicUrl) {
      return await (strategy as RemoteStorageStrategy).getPublicUrl(invoice);
    } else {
      return await (strategy as LocalStorageStrategy).streamFile(
        invoice,
        input.res
      );
    }
  }
  async getInvoicesForOrder(
    ctx: RequestContext,
    orderId: ID
  ): Promise<InvoiceEntity[]> {
    const invoiceRepo = this.connection.getRepository(ctx, InvoiceEntity);
    return await invoiceRepo.find({
      where: {
        orderId: String(orderId),
      },
      order: { invoiceNumber: 'DESC' },
    });
  }
  async getMostRecentInvoiceForOrder(
    ctx: RequestContext,
    orderCode: string
  ): Promise<InvoiceEntity | undefined> {
    const order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      throw Error(`No order found with code ${orderCode}`);
    }
    const invoices = await this.getInvoicesForOrder(ctx, order.id);
    if (!invoices.length) {
      return undefined;
    }
    return invoices[invoices.length - 1];
  }
  async getLatestInvoiceNumber(
    ctx: RequestContext
  ): Promise<number | undefined> {
    const invoiceRepo = this.connection.getRepository(ctx, InvoiceEntity);
    const result = await invoiceRepo.findOne({
      where: [{ channelId: ctx.channelId as string }],
      select: ['invoiceNumber'],
      order: { invoiceNumber: 'DESC' },
      cache: false,
    });
    return result?.invoiceNumber;
  }
  getDownloadUrl(
    ctx: RequestContext,
    invoiceNumber: number,
    orderCode: string,
    customerEmail: string
  ): string {
    const emailAddress = encodeURIComponent(customerEmail);
    return `${this.config.vendureHost}/invoices/${ctx.channel.token}/${orderCode}/${invoiceNumber}?email=${emailAddress}`;
  }
  async upsertConfig(
    ctx: RequestContext,
    input: InvoiceConfigInput
  ): Promise<InvoiceConfigEntity> {
    const configRepo = this.connection.getRepository(ctx, InvoiceConfigEntity);
    const existing = await configRepo.findOne({
      where: { channelId: String(ctx.channelId) },
    });
    if (existing) {
      await configRepo.update(
        existing.id,
        input as QueryDeepPartialEntity<InvoiceConfigEntity>
      );
    } else {
      await configRepo.insert({
        ...input,
        channelId: String(ctx.channelId),
      } as QueryDeepPartialEntity<InvoiceConfigEntity>);
    }
    return configRepo.findOneOrFail({
      where: { channelId: String(ctx.channelId) },
    });
  }
  async getConfig(
    ctx: RequestContext
  ): Promise<InvoiceConfigEntity | undefined> {
    const configRepo = this.connection.getRepository(ctx, InvoiceConfigEntity);
    let config = await configRepo.findOne({
      where: { channelId: String(ctx.channelId) },
    });
    if (!config) {
      config = await this.upsertConfig(ctx, {
        enabled: false,
        createCreditInvoices: true,
        templateString: defaultTemplate,
      });
    }
    if (!config.templateString || !config.templateString.trim()) {
      config.templateString = defaultTemplate;
    }
    return config;
  }
  async isInvoicePluginEnabled(ctx: RequestContext): Promise<boolean> {
    const configRepo = this.connection.getRepository(ctx, InvoiceConfigEntity);
    const result = await configRepo.findOne({
      select: ['enabled'],
      where: { channelId: ctx.channelId as string },
    });
    return !!result?.enabled;
  }
  throwIfInvalidLicense(): void {
    if (this.config.hasValidLicense) {
      return;
    }
    const message = `Invalid license key. Viewing invoices is disabled. Invoice generation will continue as usual.`;
    Logger.error(message, loggerCtx);
    if (process.env.NODE_ENV === 'test') {
      return;
    }
    throw Error(message);
  }
  private async createInvoiceRow(
    ctx: RequestContext,
    invoice: Omit<
      InvoiceEntity,
      | 'id'
      | 'channelId'
      | 'createdAt'
      | 'updatedAt'
      | 'storageReference'
      | 'accountingReference'
    >
  ): Promise<ID> {
    const invoiceRepo = this.connection.getRepository(ctx, InvoiceEntity);
    const entity = await invoiceRepo.save({
      ...invoice,
      channelId: ctx.channelId as string,
      storageReference: '', // This will be updated when the invoice is saved
    });
    return entity.id;
  }
  private async createCtx(channelToken: string): Promise<RequestContext> {
    const channel = await this.channelService.getChannelFromToken(channelToken);
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel,
    });
  }
}
```

## File: packages/vendure-plugin-invoices/src/strategies/accounting/accounting-export-strategy.ts

```typescript
import { RequestContext, Order, Injector } from '@vendure/core';
import { InvoiceEntity } from '../../entities/invoice.entity';
export interface ExternalReference {
  reference?: string;
  link?: string;
}
export interface AccountingExportStrategy {
  channelToken?: string;
  init?(injector: Injector): Promise<void> | void;
  exportInvoice(
    ctx: RequestContext,
    invoice: InvoiceEntity,
    order: Order
  ): Promise<ExternalReference> | ExternalReference;
  exportCreditInvoice(
    ctx: RequestContext,
    invoice: InvoiceEntity,
    isCreditInvoiceFor: InvoiceEntity,
    order: Order
  ): Promise<ExternalReference> | ExternalReference;
}
```

## File: packages/vendure-plugin-invoices/src/strategies/accounting/xero-uk-export-strategy.ts

```typescript
import {
  createSelfRefreshingCache,
  Customer,
  EntityHydrator,
  Injector,
  Logger,
  Order,
  RequestContext,
  SelfRefreshingCache,
  translateDeep,
} from '@vendure/core';
import util from 'util';
import { InvoiceEntity } from '../../entities/invoice.entity';
import {
  AccountingExportStrategy,
  ExternalReference,
} from './accounting-export-strategy';
const loggerCtx = 'XeroUKAccountingExport';
interface Config {
  clientId: string;
  clientSecret: string;
  shippingAccountCode: string;
  salesAccountCode: string;
  channelToken?: string;
  invoiceBrandingThemeId?: string;
  getReference?: (
    order: Order,
    invoice: InvoiceEntity,
    isCreditInvoiceFor?: number
  ) => string;
  getVendureUrl?(order: Order, invoice: InvoiceEntity): string;
  getDueDate?(ctx: RequestContext, order: Order, invoice: InvoiceEntity): Date;
}
interface TaxRate {
  rate?: number;
  type?: string;
}
let injector: Injector;
export class XeroUKExportStrategy implements AccountingExportStrategy {
  readonly channelToken?: string;
  taxRates: TaxRate[] = [];
  private xero!: import('xero-node').XeroClient;
  private tokenCache!: SelfRefreshingCache<import('xero-node').TokenSet, []>;
  readonly tenantId = '';
  constructor(private config: Config) {
    this.channelToken = config.channelToken;
  }
  async init(_injector: Injector): Promise<void> {
    injector = _injector;
    try {
      // Test if package is installed
      await import('xero-node');
    } catch (e: any) {
      throw Error(
        `Could not find the "xero-node" package. Make sure it is installed: ${e?.message}`
      );
    }
    const XeroNode = await import('xero-node');
    this.xero = new XeroNode.XeroClient({
      clientId: this.config.clientId,
      clientSecret: this.config.clientSecret,
      grantType: 'client_credentials',
    });
    this.tokenCache = await this.createCache();
    try {
      this.taxRates = await this.getTaxRates();
    } catch (e: any) {
      Logger.error(
        `Failed initialize: Could not get tax rates from Xero: ${e?.message}`,
        loggerCtx,
        util.inspect(e, false, 5)
      );
    }
  }
  async exportInvoice(
    ctx: RequestContext,
    invoice: InvoiceEntity,
    order: Order
  ): Promise<ExternalReference> {
    await injector.get(EntityHydrator).hydrate(ctx, order, {
      relations: [
        'customer',
        'surcharges',
        'lines.productVariant',
        'lines.productVariant.translations',
        'shippingLines.shippingMethod',
      ],
    });
    if (!order.customer) {
      throw Error(
        `Cannot export invoice of order '${order.code}' to Xero without a customer`
      );
    }
    try {
      const contact = await this.getOrCreateContact(
        order.customer,
        order.billingAddress?.company
      );
      const reference =
        this.config.getReference?.(order, invoice) || order.code;
      const oneMonthLater = new Date();
      oneMonthLater.setDate(oneMonthLater.getDate() + 30);
      const dueDate = this.config.getDueDate
        ? this.config.getDueDate(ctx, order, invoice)
        : oneMonthLater;
      const xeroInvoice: import('xero-node').Invoice = {
        invoiceNumber: String(invoice.invoiceNumber),
        type: 'ACCREC' as any,
        contact: {
          contactID: contact.contactID,
        },
        dueDate: this.toDate(dueDate),
        brandingThemeID: this.config.invoiceBrandingThemeId,
        date: this.toDate(order.orderPlacedAt ?? order.updatedAt),
        lineItems: this.getLineItems(ctx, order),
        reference,
        status: 'DRAFT' as any,
        url: this.config.getVendureUrl?.(order, invoice),
      };
      const idempotencyKey = `${ctx.channel.token}-${
        invoice.invoiceNumber
      }-${order.updatedAt.toISOString()}`;
      const response = await this.xero.accountingApi.createInvoices(
        this.tenantId,
        { invoices: [xeroInvoice] },
        true,
        undefined,
        idempotencyKey
      );
      const createdInvoice = response.body.invoices?.[0];
      Logger.info(
        `Created invoice '${invoice.invoiceNumber}' for order '${order.code}' in Xero with ID '${createdInvoice?.invoiceID}' with a total Incl. Tax of ${createdInvoice?.total}`,
        loggerCtx
      );
      return {
        reference: createdInvoice?.invoiceID,
        link: `https://go.xero.com/AccountsReceivable/View.aspx?InvoiceID=${createdInvoice?.invoiceID}`,
      };
    } catch (err: any) {
      const errorMessage = this.getErrorMessage(err);
      Logger.warn(
        `Failed to export invoice to Xero for order '${order.code}': ${errorMessage}`,
        loggerCtx
      );
      throw Error(errorMessage);
    }
  }
  async exportCreditInvoice(
    ctx: RequestContext,
    invoice: InvoiceEntity,
    isCreditInvoiceFor: InvoiceEntity,
    order: Order
  ): Promise<ExternalReference> {
    await this.tokenCache.value();
    await injector
      .get(EntityHydrator)
      .hydrate(ctx, order, { relations: ['customer'] });
    if (!order.customer) {
      throw Error(
        `Cannot export credit invoice of order '${order.code}' to Xero without a customer`
      );
    }
    try {
      const contact = await this.getOrCreateContact(
        order.customer,
        order.billingAddress?.company
      );
      const reference =
        this.config.getReference?.(
          order,
          invoice,
          isCreditInvoiceFor.invoiceNumber
        ) || `Credit note for ${isCreditInvoiceFor.invoiceNumber}`;
      const creditNote: import('xero-node').CreditNote = {
        creditNoteNumber: `${invoice.invoiceNumber} (CN)`,
        type: 'ACCRECCREDIT' as any,
        contact: {
          contactID: contact.contactID,
        },
        date: this.toDate(order.updatedAt),
        brandingThemeID: this.config.invoiceBrandingThemeId,
        lineItems: this.getCreditLineItems(invoice),
        reference,
        status: 'DRAFT' as any,
      };
      const idempotencyKey = `${ctx.channel.token}-${
        invoice.invoiceNumber
      }-${order.updatedAt.toISOString()}`;
      const response = await this.xero.accountingApi.createCreditNotes(
        this.tenantId,
        { creditNotes: [creditNote] },
        true,
        undefined,
        idempotencyKey
      );
      const creditNoteResponse = response.body.creditNotes?.[0];
      Logger.info(
        `Created credit note '${invoice.invoiceNumber}' for order '${order.code}' in Xero with ID '${creditNoteResponse?.creditNoteID}' with a total Incl. Tax of ${creditNoteResponse?.total}`,
        loggerCtx
      );
      return {
        reference: creditNoteResponse?.creditNoteID,
        link: `https://go.xero.com/AccountsReceivable/EditCreditNote.aspx?creditNoteID=${creditNoteResponse?.creditNoteID}`,
      };
    } catch (err: any) {
      const errorMessage = this.getErrorMessage(err);
      Logger.warn(
        `Failed to export Credit Invoice to Xero for order '${order.code}': ${errorMessage}`,
        loggerCtx
      );
      throw Error(errorMessage);
    }
  }
  async getOrCreateContact(
    customer: Customer,
    companyName?: string
  ): Promise<import('xero-node').Contact> {
    await this.tokenCache.value();
    const contactName = this.getNormalizedContactName(customer, companyName);
    let contacts = await this.xero.accountingApi.getContacts(
      this.tenantId,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      contactName
    );
    if (!contacts.body.contacts?.length) {
      contacts = await this.xero.accountingApi.getContacts(
        this.tenantId,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        customer.emailAddress
      );
    }
    if ((contacts.body?.contacts?.length ?? 0) > 1) {
      const contact = contacts.body.contacts![0];
      Logger.info(
        `Found multiple contacts in Xero with email address "${customer.emailAddress}". Using ${contact.contactID}`,
        loggerCtx
      );
      return contact;
    } else if ((contacts.body?.contacts?.length ?? 0) === 1) {
      return contacts.body.contacts![0];
    }
    const createdContacts = await this.xero.accountingApi.createContacts(
      this.tenantId,
      {
        contacts: [
          {
            name: `${customer.firstName} ${customer.lastName}`,
            emailAddress: customer.emailAddress,
            firstName: customer.firstName,
            lastName: customer.lastName,
          },
        ],
      }
    );
    const createdContact = createdContacts.body.contacts?.[0];
    Logger.info(
      `No contact found with name '${contactName}' or email '${customer.emailAddress}'. Created new contact with email "${createdContact?.emailAddress}" (${createdContact?.contactID})`,
      loggerCtx
    );
    return createdContacts.body.contacts![0];
  }
  async getTaxRates(): Promise<TaxRate[]> {
    const rates = await this.xero.accountingApi.getTaxRates(this.tenantId);
    return (
      rates.body.taxRates
        ?.filter((rate) => rate.canApplyToRevenue)
        .map((rate) => ({
          rate: rate.effectiveRate,
          type: rate.taxType,
        })) || []
    );
  }
  private getErrorMessage(err: string): string {
    const errorObj = JSON.parse(err);
    return (
      errorObj?.response?.body?.Elements?.[0]?.ValidationErrors?.[0]?.Message ||
      errorObj?.response?.body?.Message ||
      errorObj?.response?.body ||
      errorObj?.body
    );
  }
  private getLineItems(
    ctx: RequestContext,
    order: Order
  ): import('xero-node').LineItem[] {
    const lineItems: import('xero-node').LineItem[] = order.lines.map(
      (line) => {
        return {
          description: translateDeep(
            line.productVariant,
            ctx.channel.defaultLanguageCode
          ).name,
          quantity: line.quantity,
          unitAmount: this.toMoney(line.proratedUnitPrice),
          accountCode: this.config.salesAccountCode,
          taxType: this.getTaxType(line.taxRate, order.code),
        };
      }
    );
    lineItems.push(
      ...order.shippingLines.map((shippingLine) => {
        return {
          description: translateDeep(
            shippingLine.shippingMethod,
            ctx.channel.defaultLanguageCode
          ).name,
          quantity: 1,
          unitAmount: this.toMoney(shippingLine.discountedPrice),
          accountCode: this.config.shippingAccountCode,
          taxType: this.getTaxType(shippingLine.taxRate, order.code),
        };
      })
    );
    lineItems.push(
      ...order.surcharges.map((surcharge) => {
        return {
          description: surcharge.description,
          quantity: 1,
          unitAmount: this.toMoney(surcharge.price),
          accountCode: this.config.salesAccountCode,
          taxType: this.getTaxType(surcharge.taxRate, order.code),
        };
      })
    );
    return lineItems;
  }
  private getCreditLineItems(
    invoice: InvoiceEntity
  ): import('xero-node').LineItem[] {
    if (!invoice.isCreditInvoice) {
      throw Error(
        `Cannot create credit line items for non-credit invoice '${invoice.invoiceNumber}'`
      );
    }
    return invoice.orderTotals.taxSummaries.map((taxSummary) => {
      return {
        description: `Credit of all line items with '${taxSummary.description}'`,
        quantity: 1,
        unitAmount: this.toMoney(Math.abs(taxSummary.taxBase)),
        accountCode: this.config.salesAccountCode,
        taxType: this.getTaxType(taxSummary.taxRate, invoice.invoiceNumber),
      };
    });
  }
  private getNormalizedContactName(
    customer: Customer,
    companyName?: string
  ): string {
    const contactName =
      companyName ||
      [customer.firstName, customer.lastName].filter(Boolean).join(' ');
    return contactName.trim().replace(/\s\s+/g, ' ').substring(0, 50);
  }
  private getTaxType(
    rate: number,
    orderOrInvoice: string | number
  ): string | undefined {
    const taxType = this.taxRates.find(
      (xeroRate) => xeroRate.rate == rate
    )?.type;
    if (taxType) {
      return taxType;
    }
    Logger.error(
      `No tax rate found in Xero with tax rate '${rate}'. No rate set for '${orderOrInvoice}'`,
      loggerCtx,
      `Available tax rates: ${this.taxRates
        .map((r) => `${r.type}=${r.rate}`)
        .join(', ')}`
    );
  }
  private toDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }
  private toMoney(value: number): number {
    return value / 100;
  }
  private async createCache(): Promise<
    SelfRefreshingCache<import('xero-node').TokenSet, []>
  > {
    return createSelfRefreshingCache({
      name: 'Xero Token Cache',
      ttl: 1200000,
      refresh: {
        fn: async () => {
          try {
            return await this.xero.getClientCredentialsToken();
          } catch (e: any) {
            Logger.error(
              `Failed to get access_token for Xero: ${e?.message}`,
              loggerCtx,
              util.inspect(e, false, 5)
            );
            throw Error(
              `Failed to get access_token for Xero: ${
                e?.message
              }: ${JSON.stringify(e?.response?.data)}`
            );
          }
        },
        defaultArgs: [],
      },
    });
  }
}
```

## File: packages/vendure-plugin-invoices/src/strategies/storage/google-storage-invoice-strategy.ts

```typescript
import { Logger } from '@vendure/core';
import { Response } from 'express';
import { InvoiceEntity } from '../../entities/invoice.entity';
import { createReadStream, ReadStream } from 'fs';
import {
  ZippableFile,
  createTempFile,
  safeRemove,
  zipFiles,
} from '../../util/file.util';
import { RemoteStorageStrategy } from './storage-strategy';
interface GoogleInvoiceConfig {
  bucketName: string;
  storageOptions?: import('@google-cloud/storage').StorageOptions;
}
export class GoogleStorageInvoiceStrategy implements RemoteStorageStrategy {
  private storage!: import('@google-cloud/storage').Storage;
  private bucketName: string;
  constructor(private config: GoogleInvoiceConfig) {
    this.bucketName = config.bucketName;
  }
  async init(): Promise<void> {
    try {
      const storage = await import('@google-cloud/storage');
      this.storage = this.config.storageOptions
        ? new storage.Storage(this.config.storageOptions)
        : new storage.Storage();
    } catch (err: any) {
      Logger.error(
        `Could not find the "@google-cloud/storage" package. Make sure it is installed`,
        GoogleStorageInvoiceStrategy.name,
        err.stack
      );
    }
  }
  async getPublicUrl(invoice: InvoiceEntity): Promise<string> {
    const [url] = await this.storage
      .bucket(this.bucketName)
      .file(invoice.storageReference)
      .getSignedUrl({
        version: 'v4',
        action: 'read',
        expires: Date.now() + 15 * 60 * 1000,
      });
    return url;
  }
  async save(
    tmpFile: string,
    invoiceNumber: number,
    channelToken: string,
    isCreditInvoice: boolean
  ): Promise<string> {
    let filename = `${invoiceNumber}.pdf`;
    if (isCreditInvoice) {
      filename = `${invoiceNumber}-credit.pdf`;
    }
    const fullPath = `${channelToken}/${filename}`;
    await this.storage.bucket(this.bucketName).upload(tmpFile, {
      destination: fullPath,
    });
    safeRemove(tmpFile);
    return fullPath;
  }
  async streamMultiple(
    invoices: InvoiceEntity[],
    res: Response
  ): Promise<ReadStream> {
    res.set({
      'Content-Type': 'application/zip',
      'Content-Disposition': `inline; filename="invoices-${invoices.length}.zip"`,
    });
    const files: ZippableFile[] = await Promise.all(
      invoices.map(async (invoice) => {
        const tmpFile = await createTempFile('.pdf');
        await this.storage
          .bucket(this.bucketName)
          .file(invoice.storageReference)
          .download({ destination: tmpFile });
        return {
          path: tmpFile,
          name: invoice.invoiceNumber + '.pdf',
        };
      })
    );
    const zipFile = await zipFiles(files);
    return createReadStream(zipFile);
  }
}
```

## File: packages/vendure-plugin-invoices/src/strategies/storage/local-file-strategy.ts

```typescript
import { Response } from 'express';
import { createReadStream, promises as fs, ReadStream } from 'fs';
import { InvoiceEntity } from '../../entities/invoice.entity';
import { exists, zipFiles, ZippableFile } from '../../util/file.util';
import { LocalStorageStrategy } from './storage-strategy';
export class LocalFileStrategy implements LocalStorageStrategy {
  invoiceDir = 'invoices';
  async init(): Promise<void> {}
  async save(
    tmpFile: string,
    invoiceNumber: number,
    channelToken: string,
    isCreditInvoice: boolean
  ) {
    if (!(await exists(this.invoiceDir))) {
      await fs.mkdir(this.invoiceDir);
    }
    let name = `${invoiceNumber}.pdf`;
    if (isCreditInvoice) {
      name = `${invoiceNumber}-credit.pdf`;
    }
    const newPath = `${this.invoiceDir}/${name}`;
    await fs.rename(tmpFile, newPath);
    return newPath;
  }
  async streamMultiple(
    invoices: InvoiceEntity[],
    res: Response
  ): Promise<ReadStream> {
    res.set({
      'Content-Type': 'application/zip',
      'Content-Disposition': `inline; filename="invoices-${invoices.length}.zip"`,
    });
    const zippableFiles: ZippableFile[] = invoices.map((invoice) => ({
      path: invoice.storageReference,
      name: invoice.invoiceNumber + '.pdf',
    }));
    const zipFile = await zipFiles(zippableFiles);
    return createReadStream(zipFile);
  }
  streamFile(invoice: InvoiceEntity, res: Response): ReadStream {
    res.set({
      'Content-Type': 'application/pdf',
      'Content-Disposition': `inline; filename="${invoice.invoiceNumber}.pdf"`,
    });
    return createReadStream(invoice.storageReference);
  }
}
```

## File: packages/vendure-plugin-invoices/src/strategies/storage/s3-storage.strategy.ts

```typescript
import { Logger } from '@vendure/core';
import { readFile, writeFile } from 'fs/promises';
import { InvoiceEntity } from '../../entities/invoice.entity';
import {
  safeRemove,
  ZippableFile,
  createTempFile,
  zipFiles,
} from '../../util/file.util';
import { createReadStream, ReadStream } from 'fs';
import { RemoteStorageStrategy } from './storage-strategy';
export interface Config {
  expiresInSeconds: number;
  bucket: string;
  region?: string;
  endpoint?: any;
  s3ForcePathStyle?: boolean;
  credentials?: any;
  signatureVersion?: string;
}
export class S3StorageStrategy implements RemoteStorageStrategy {
  private s3?: import('aws-sdk').S3;
  private readonly bucket: string;
  private readonly expiresInSeconds: number;
  constructor(private readonly config: Config) {
    this.bucket = config.bucket;
    this.expiresInSeconds = config.expiresInSeconds;
  }
  async init(): Promise<void> {
    try {
      const AWS = await import('aws-sdk');
      this.s3 = new AWS.S3(this.config as any);
    } catch (e: any) {
      Logger.error(
        `Could not find the "aws-sdk" package. Make sure it is installed`,
        S3StorageStrategy.name,
        JSON.stringify(e.stack)
      );
    }
  }
  getPublicUrl(invoice: InvoiceEntity): string {
    return this.s3!.getSignedUrl('getObject', {
      Key: invoice.storageReference,
      Bucket: this.bucket,
      Expires: this.expiresInSeconds,
    });
  }
  async save(
    tmpFile: string,
    invoiceNumber: number,
    channelToken: string,
    isCreditInvoice: boolean
  ): Promise<string> {
    let filename = `${invoiceNumber}.pdf`;
    if (isCreditInvoice) {
      filename = `${invoiceNumber}-credit.pdf`;
    }
    const Key: string = `invoices/${channelToken}/${filename}`;
    await this.s3!.upload({
      Bucket: this.bucket,
      Key,
      Body: await readFile(tmpFile),
      ContentType: 'application/pdf',
      ContentDisposition: 'inline',
    }).promise();
    safeRemove(tmpFile);
    return Key;
  }
  async streamMultiple(invoices: InvoiceEntity[]): Promise<ReadStream> {
    const files: ZippableFile[] = await Promise.all(
      invoices.map(async (invoice) => {
        const tmpFile = await createTempFile('.pdf');
        const object = await this.s3!.getObject({
          Bucket: this.bucket,
          Key: invoice.storageReference,
        }).promise();
        await writeFile(tmpFile, object.Body?.toString() as string);
        return {
          path: tmpFile,
          name: invoice.invoiceNumber + '.pdf',
        };
      })
    );
    const zipFile = await zipFiles(files);
    return createReadStream(zipFile);
  }
}
```

## File: packages/vendure-plugin-invoices/src/strategies/storage/storage-strategy.ts

```typescript
import { Response } from 'express';
import { ReadStream } from 'fs';
import { InvoiceEntity } from '../../entities/invoice.entity';
export type StorageStrategy = RemoteStorageStrategy | LocalStorageStrategy;
interface BaseStorageStrategy {
  save(
    tmpFile: string,
    invoiceNumber: number,
    channelToken: string,
    isCreditInvoice: boolean
  ): Promise<string>;
  init(): Promise<void>;
  streamMultiple(invoices: InvoiceEntity[], res: Response): Promise<ReadStream>;
}
export interface RemoteStorageStrategy extends BaseStorageStrategy {
  getPublicUrl(invoice: InvoiceEntity): Promise<string> | string;
}
export interface LocalStorageStrategy extends BaseStorageStrategy {
  streamFile(
    invoice: InvoiceEntity,
    res: Response
  ): Promise<ReadStream> | ReadStream;
}
```

## File: packages/vendure-plugin-invoices/src/strategies/load-data-fn.ts

```typescript
import {
  Injector,
  Order,
  RequestContext,
  translateEntity,
} from '@vendure/core';
import { InvoiceEntity } from '../entities/invoice.entity';
import { InvoiceOrderTotals } from '../ui/generated/graphql';
export interface InvoiceData {
  invoiceNumber: number;
  [key: string]: any;
}
export interface CreditInvoiceInput {
  previousInvoice: InvoiceEntity;
  reversedOrderTotals: InvoiceOrderTotals;
}
export type LoadDataFn = (
  ctx: RequestContext,
  injector: Injector,
  order: Order,
  mostRecentInvoiceNumber?: number,
  shouldGenerateCreditInvoice?: CreditInvoiceInput
) => Promise<InvoiceData> | InvoiceData;
interface DefaultInvoiceData {
  orderDate: string;
  invoiceNumber: number;
  order: Partial<Order>;
}
interface CreditInvoiceData extends DefaultInvoiceData {
  isCreditInvoice: true;
  originalInvoiceNumber: number;
}
export type DefaultInvoiceDataResponse = DefaultInvoiceData | CreditInvoiceData;
export const defaultLoadDataFn: LoadDataFn = (
  ctx: RequestContext,
  injector: Injector,
  order: Order,
  mostRecentInvoiceNumber?: number,
  shouldGenerateCreditInvoice?: CreditInvoiceInput
): DefaultInvoiceDataResponse => {
  let newInvoiceNumber = mostRecentInvoiceNumber || 0;
  newInvoiceNumber += 1;
  const orderDate = new Intl.DateTimeFormat('nl-NL').format(order.updatedAt);
  order.lines.forEach((line) => {
    line.productVariant = translateEntity(
      line.productVariant,
      ctx.languageCode
    );
  });
  order.shippingLines.forEach((line) => {
    line.shippingMethod = translateEntity(
      line.shippingMethod,
      ctx.languageCode
    );
  });
  if (!shouldGenerateCreditInvoice) {
    return {
      orderDate,
      invoiceNumber: newInvoiceNumber,
      order: order,
    };
  }
  const { previousInvoice, reversedOrderTotals } = shouldGenerateCreditInvoice;
  return {
    orderDate,
    invoiceNumber: newInvoiceNumber,
    isCreditInvoice: true,
    originalInvoiceNumber: previousInvoice.invoiceNumber,
    order: {
      ...order,
      total: reversedOrderTotals.total,
      totalWithTax: reversedOrderTotals.totalWithTax,
      taxSummary: reversedOrderTotals.taxSummaries.map((t) => {
        return {
          description: t.description,
          taxBase: t.taxBase,
          taxRate: t.taxRate,
          taxTotal: t.taxTotal,
        };
      }),
    },
  };
};
```

## File: packages/vendure-plugin-invoices/src/ui/invoice-list/invoice-list.component.ts

```typescript
import { gql, TypedDocumentNode } from '@apollo/client';
import {
  TypedBaseListComponent,
  SharedModule,
  LogicalOperator,
  NotificationService,
  DataService,
} from '@vendure/admin-ui/core';
import { ChangeDetectionStrategy, Component } from '@angular/core';
import {
  ExportInvoiceToAccountingPlatformMutation,
  Invoice,
  InvoiceListOptions,
} from '../generated/graphql';
import { exportToAccounting } from '../queries.graphql';
const GET_INVOICES_QUERY = gql`
  query InvoiceList($options: InvoiceListOptions) {
    invoices(options: $options) {
      items {
        id
        createdAt
        invoiceNumber
        downloadUrl
        isCreditInvoice
        orderCode
        orderId
        accountingReference {
          reference
          link
          errorMessage
        }
      }
      totalItems
    }
  }
`;
const typedDocumentNode: TypedDocumentNode<{
  invoices: { items: Invoice[]; totalItems: number };
}> = GET_INVOICES_QUERY;
@Component({
  selector: 'invoice-list',
  templateUrl: './invoice-list.component.html',
  styleUrls: ['./invoice-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [SharedModule],
})
export class InvoiceListComponent extends TypedBaseListComponent<
  typeof typedDocumentNode,
  'invoices'
> {
  // Here we set up the filters that will be available
  // to use in the data table
  readonly filters = this.createFilterCollection()
    .addFilter({
      name: 'orderCode',
      type: { kind: 'text' },
      label: 'Order Code',
      filterField: 'orderCode',
    })
    .addFilter({
      name: 'invoiceNumber',
      type: { kind: 'text' },
      label: 'Invoice Number',
      filterField: 'invoiceNumber',
    })
    .connectToRoute(this.route);
  constructor(
    protected dataService: DataService,
    private notificationService: NotificationService
  ) {
    super();
    super.configure({
      document: typedDocumentNode,
      getItems: (data) => data.invoices,
      setVariables: (skip, take) =>
        this.createQueryOptions(skip, take, this.searchTermControl.value),
      refreshListOnChanges: [this.filters.valueChanges],
    });
  }
  exportToAccounting(invoiceNumber: number) {
    this.dataService
      .mutate<ExportInvoiceToAccountingPlatformMutation>(exportToAccounting, {
        invoiceNumber,
      })
      .subscribe(() => {
        this.notificationService.success(`Started export`);
      });
  }
  private createQueryOptions(
    skip: number,
    take: number,
    searchTerm: string | null
  ): { options: InvoiceListOptions } {
    let filterInput = this.filters.createFilterInput();
    if (searchTerm) {
      filterInput = {
        invoiceNumber: {
          contains: searchTerm,
        },
        orderCode: {
          contains: searchTerm,
        },
      };
    }
    return {
      options: {
        skip,
        take,
        filter: {
          ...(filterInput ?? {}),
        },
        filterOperator: searchTerm ? LogicalOperator.OR : LogicalOperator.AND,
      },
    };
  }
}
```

## File: packages/vendure-plugin-invoices/src/ui/invoices-detail-view/invoices-detail-view.component.ts

```typescript
import { Component, OnInit, ChangeDetectorRef } from '@angular/core';
import { UntypedFormGroup } from '@angular/forms';
import {
  DataService,
  CustomDetailComponent,
  getServerLocation,
} from '@vendure/admin-ui/core';
import { Observable } from 'rxjs';
import { Invoice } from '../generated/graphql';
import { getOrderWithInvoices } from './invoices-detail-view';
import { Permission, Order } from '@vendure/admin-ui/core';
@Component({
  selector: 'invoices-detail-view',
  templateUrl: './invoices-detail-view.component.html',
})
export class InvoiceDetailViewComponent
  implements CustomDetailComponent, OnInit
{
  entity$: Observable<Order>;
  detailForm: UntypedFormGroup;
  invoicesList: Invoice[] | undefined;
  itemsPerPage = 10;
  serverPath: string;
  page = 1;
  selectedInvoices: Invoice[] = [];
  constructor(
    protected dataService: DataService,
    private cdr: ChangeDetectorRef
  ) {
    this.serverPath = getServerLocation();
  }
  ngOnInit(): void {
    this.dataService.client
      .userStatus()
      .mapStream((data) => data.userStatus.permissions)
      .subscribe((permissions) => {
        if (permissions.includes('AllowInvoicesPermission' as Permission)) {
          this.getOrderInvoices();
        } else {
          console.warn('Current user doesnt have permission to view invoices');
        }
      });
  }
  getOrderInvoices(): void {
    this.entity$.subscribe((order: Order) => {
      this.dataService
        .query(getOrderWithInvoices, {
          id: order?.id,
        })
        .mapStream((r: any) => r.order.invoices as Invoice[])
        .subscribe((result) => {
          this.invoicesList = result;
          this.cdr.markForCheck();
        });
    });
  }
  setPageNumber(page: number) {
    this.page = page;
    this.getOrderInvoices();
  }
  setItemsPerPage(nrOfItems: number) {
    this.page = 1;
    this.itemsPerPage = Number(nrOfItems);
    this.getOrderInvoices();
  }
}
```

## File: packages/vendure-plugin-invoices/src/ui/invoices-detail-view/invoices-detail-view.ts

```typescript
import gql from 'graphql-tag';
export const invoiceFragment = gql`
  fragment invoiceFields on Invoice {
    id
    createdAt
    invoiceNumber
    isCreditInvoice
    downloadUrl
    accountingReference {
      reference
      link
      errorMessage
    }
  }
`;
export const getOrderWithInvoices = gql`
  ${invoiceFragment}
  query order($id: ID!) {
    order(id: $id) {
      id
      code
      state
      invoices {
        ...invoiceFields
      }
    }
  }
`;
```

## File: packages/vendure-plugin-invoices/src/ui/invoices-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
import { registerCustomDetailComponent } from '@vendure/admin-ui/core';
import { InvoiceDetailViewComponent } from './invoices-detail-view/invoices-detail-view.component';
import { getRegenerateInvoiceButton } from './util';
@NgModule({
  imports: [SharedModule],
  providers: [
    addNavMenuItem(
      {
        id: 'invoices',
        label: 'Invoices',
        routerLink: ['/extensions/invoices'],
        icon: 'file-group',
        requiresPermission: 'AllowInvoicesPermission',
      },
      'settings'
    ),
    registerCustomDetailComponent({
      locationId: 'order-detail',
      component: InvoiceDetailViewComponent,
    }),
    getRegenerateInvoiceButton(false),
    getRegenerateInvoiceButton(true),
  ],
})
export class InvoicesNavModule {}
```

## File: packages/vendure-plugin-invoices/src/ui/invoices.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import {
  DataService,
  getServerLocation,
  LocalStorageService,
  NotificationService,
} from '@vendure/admin-ui/core';
import { getConfigQuery, upsertConfigMutation } from './queries.graphql';
import {
  InvoiceConfigQuery,
  UpsertInvoiceConfigMutation,
  UpsertInvoiceConfigMutationVariables,
} from './generated/graphql';
import { firstValueFrom } from 'rxjs';
import { ConfigArgDefinition } from '@vendure/common/lib/generated-types';
import { downloadBlob, getHeaders } from './providers';
@Component({
  selector: 'invoices-component',
  template: `
    <div class="page-block">
      <vdr-page-block>
        <vdr-action-bar>
          <vdr-ab-right>
            <button
              class="btn btn-primary"
              (click)="save()"
              [disabled]="form.invalid || form.get('templateString')?.pristine"
            >
              {{ 'common.update' | translate }}
            </button>
          </vdr-ab-right>
        </vdr-action-bar>
      </vdr-page-block>
      <vdr-page-block>
        <vdr-card>
          <form class="form" [formGroup]="form">
            <vdr-form-field label="Generate invoices on" for="enabled">
              <clr-checkbox-wrapper>
                <input type="checkbox" clrCheckbox formControlName="enabled" />
              </clr-checkbox-wrapper>
            </vdr-form-field>
            <vdr-form-field label="HTML template" for="templateString">
              <vdr-dynamic-form-input
                *ngIf="renderNow"
                formControlName="templateString"
                [readonly]="false"
                [def]="htmlFormInputConfigArgsDef"
                [control]="form.get('templateString')"
                style="max-width: 100%;"
              >
              </vdr-dynamic-form-input>
            </vdr-form-field>
            <vdr-form-field label="Order Code" for="enabled">
              <clr-input-container>
                <input type="text" clrInput formControlName="orderCode" />
              </clr-input-container>
            </vdr-form-field>
            <button
              class="btn btn-primary preview-button"
              (click)="testDownload()"
              [disabled]="invoicePreviewLoading"
            >
              Preview Template
            </button>
          </form>
        </vdr-card>
      </vdr-page-block>
    </div>
  `,
  styleUrls: ['./invoices.component.scss'],
})
export class InvoicesComponent implements OnInit {
  form: FormGroup;
  serverPath: string;
  invoicePreviewLoading: boolean = false;
  renderNow = false;
  htmlFormInputConfigArgsDef: ConfigArgDefinition = {
    name: 'templateString',
    type: 'text',
    list: false,
    required: false,
    ui: { component: 'html-editor-form-input' },
  };
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService,
    private localStorageService: LocalStorageService
  ) {
    this.form = this.formBuilder.group({
      enabled: ['enabled'],
      templateString: ['templateString'],
      orderCode: [''],
    });
    this.serverPath = getServerLocation();
  }
  ngOnInit(): void {
    this.dataService
      .query<InvoiceConfigQuery>(getConfigQuery)
      .mapStream((d) => d.invoiceConfig)
      .subscribe((config) => {
        this.form.controls['enabled'].setValue(config?.enabled);
        this.renderNow = true;
        this.form.controls['templateString'].setValue(config?.templateString);
      });
  }
  async save() {
    try {
      if (this.form.dirty) {
        const formValue = this.form.value;
        const result$ = this.dataService.mutate<
          UpsertInvoiceConfigMutation,
          UpsertInvoiceConfigMutationVariables
        >(upsertConfigMutation, {
          input: {
            enabled: formValue.enabled as boolean,
            templateString: formValue.templateString as string,
          },
        });
        const { upsertInvoiceConfig: result } = await firstValueFrom(result$);
        this.form.controls['enabled'].setValue(result.enabled);
        this.form.controls['templateString'].setValue(result.templateString);
      }
      this.form.markAsPristine();
      this.changeDetector.markForCheck();
      this.notificationService.success('common.notify-update-success', {
        entity: 'InvoiceConfig',
      });
    } catch (e: any) {
      this.notificationService.error('common.notify-update-error', {
        entity: 'InvoiceConfig',
      });
    }
  }
  async testDownload() {
    try {
      const template = this.form.value.templateString as string;
      const orderCode = this.form.value.orderCode as string;
      this.invoicePreviewLoading = true;
      this.changeDetector.markForCheck();
      const res = await fetch(
        `${this.serverPath}/invoices/preview/${orderCode}`,
        {
          headers: {
            ...getHeaders(this.localStorageService),
            'Content-Type': 'application/json',
          },
          method: 'POST',
          body: JSON.stringify({ template }),
        }
      );
      if (!res.ok) {
        const json = await res.json();
        throw Error(JSON.stringify(json?.message));
      }
      const blob = await res.blob();
      downloadBlob(blob, 'test-invoice.pdf', true);
    } catch (err: any) {
      console.error(JSON.stringify(err));
      this.notificationService.error(JSON.stringify(err?.message));
    }
    this.invoicePreviewLoading = false;
    this.changeDetector.markForCheck();
  }
}
```

## File: packages/vendure-plugin-invoices/src/ui/invoices.module.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { SharedModule } from '@vendure/admin-ui/core';
import { InvoicesComponent } from './invoices.component';
import { InvoiceDetailViewComponent } from './invoices-detail-view/invoices-detail-view.component';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: InvoicesComponent,
        data: { breadcrumb: 'Invoices' },
      },
    ]),
  ],
  providers: [],
  declarations: [InvoicesComponent, InvoiceDetailViewComponent],
})
export class InvoicesModule {}
```

## File: packages/vendure-plugin-invoices/src/ui/providers.ts

```typescript
import {
  addNavMenuItem,
  registerBulkAction,
  getServerLocation,
  LocalStorageService,
  NotificationService,
} from '@vendure/admin-ui/core';
export default [
  addNavMenuItem(
    {
      id: 'invoice-list',
      label: 'Invoices',
      routerLink: ['/extensions/invoice-list'],
      requiresPermission: 'AllowInvoicesPermission',
      icon: 'star',
    },
    'sales'
  ),
  registerBulkAction({
    location: 'invoice-list',
    label: 'Download',
    icon: 'download',
    onClick: async ({ injector, selection }) => {
      const notificationService =
        injector.get<NotificationService>(NotificationService);
      try {
        const nrs = selection.map((i) => i.invoiceNumber as string).join(',');
        const localStorageService = injector.get(LocalStorageService);
        const serverPath = getServerLocation();
        const res = await fetch(`${serverPath}/invoices/download?nrs=${nrs}`, {
          headers: getHeaders(localStorageService),
        });
        if (!res.ok) {
          const json = await res.json();
          notificationService.error(JSON.stringify(json?.message));
          throw Error(JSON.stringify(json?.message));
        }
        const blob = await res.blob();
        downloadBlob(blob, 'invoices.zip');
      } catch (err: any) {
        notificationService.error(JSON.stringify(err?.message));
        throw Error(JSON.stringify(err));
      }
    },
  }),
];
export function getHeaders(
  localStorageService: LocalStorageService
): Record<string, string> {
  const headers: Record<string, string> = {};
  const channelToken = localStorageService.get('activeChannelToken');
  if (channelToken) {
    headers['vendure-token'] = channelToken;
  }
  const authToken = localStorageService.get('authToken');
  if (authToken) {
    headers.authorization = `Bearer ${authToken}`;
  }
  return headers;
}
export function downloadBlob(
  blob: Blob,
  fileName: string,
  openInNewTab = false
): void {
  const blobUrl = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  document.body.appendChild(a);
  a.setAttribute('hidden', 'true');
  a.href = blobUrl;
  if (!openInNewTab) {
    a.download = fileName;
  }
  a.setAttribute('target', '_blank');
  a.click();
}
```

## File: packages/vendure-plugin-invoices/src/ui/queries.graphql.ts

```typescript
import gql from 'graphql-tag';
export const upsertConfigMutation = gql`
  mutation upsertInvoiceConfig($input: InvoiceConfigInput!) {
    upsertInvoiceConfig(input: $input) {
      id
      enabled
      createCreditInvoices
      templateString
    }
  }
`;
export const getConfigQuery = gql`
  query invoiceConfig {
    invoiceConfig {
      id
      enabled
      createCreditInvoices
      templateString
    }
  }
`;
export const invoiceFragment = gql`
  fragment invoiceFields on Invoice {
    id
    createdAt
    invoiceNumber
    isCreditInvoice
    downloadUrl
    accountingReference {
      reference
      link
      errorMessage
    }
  }
`;
export const createInvoice = gql`
  ${invoiceFragment}
  mutation createInvoice($orderId: ID!) {
    createInvoice(orderId: $orderId) {
      ...invoiceFields
    }
  }
`;
export const exportToAccounting = gql`
  mutation exportInvoiceToAccountingPlatform($invoiceNumber: Int!) {
    exportInvoiceToAccountingPlatform(invoiceNumber: $invoiceNumber)
  }
`;
```

## File: packages/vendure-plugin-invoices/src/ui/routes.ts

```typescript
import { registerRouteComponent } from '@vendure/admin-ui/core';
import { InvoiceListComponent } from './invoice-list/invoice-list.component';
export default [
  registerRouteComponent({
    path: '',
    component: InvoiceListComponent,
    breadcrumb: 'Invoices',
  }),
];
```

## File: packages/vendure-plugin-invoices/src/ui/util.ts

```typescript
import { addActionBarItem } from '@vendure/admin-ui/core';
import { createInvoice } from './queries.graphql';
import { catchError } from 'rxjs/operators';
import { ApolloCache } from '@apollo/client/cache';
import { map } from 'rxjs';
import { GetOrderQueryVariables, GetOrderQuery } from '@vendure/admin-ui/core';
import gql from 'graphql-tag';
export const GET_ORDER = gql`
  query GetOrder($id: ID!) {
    order(id: $id) {
      id
      orderPlacedAt
      invoices {
        id
        createdAt
        invoiceNumber
        downloadUrl
        orderCode
        orderId
        isCreditInvoice
        orderTotals {
          totalWithTax
        }
      }
      state
      totalWithTax
    }
  }
`;
export function getRegenerateInvoiceButton(isWarningButton: boolean) {
  return addActionBarItem({
    id: isWarningButton ? 'regenerate-invoice-styled' : 'regenerate-invoice',
    label: 'Regenerate Invoice',
    locationId: 'order-detail',
    requiresPermission: ['AllowInvoicesPermission'],
    buttonColor: isWarningButton ? 'warning' : 'primary',
    buttonStyle: isWarningButton ? 'solid' : 'outline',
    onClick: (event, context) => {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      const orderId = context.route.snapshot.params['id'];
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      (event.target as HTMLButtonElement).disabled = true;
      context.dataService
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
        .mutate(createInvoice, { orderId }, (cache: ApolloCache<any>) => {
          cache.evict({ fieldName: 'invoices', id: `Order:${orderId}` });
        })
        .pipe(
          catchError((error) => {
            context.notificationService.error('Failed to regenerate invoices');
            (event.target as HTMLButtonElement).disabled = false;
            throw new Error(JSON.stringify(error));
          })
        )
        .subscribe((data: any) => {
          if (data?.createInvoice?.id) {
            context.notificationService.success(
              'Invoice has been regenerated successfully'
            );
          } else {
            context.notificationService.error('Failed to regenerate invoices');
          }
          (event.target as HTMLButtonElement).disabled = false;
        });
    },
    buttonState: (context) => {
      const orderId = context.route.snapshot.params['id'];
      const order$ = context.dataService.query<any, GetOrderQueryVariables>(
        GET_ORDER,
        { id: orderId }
      );
      return order$.stream$.pipe(
        map(({ order }) => {
          if (!order?.orderPlacedAt || order?.state === 'Cancelled') {
            return {
              disabled: true,
              visible: false,
            };
          }
          const orderTotalMatches =
            order?.invoices?.[0]?.orderTotals.totalWithTax ===
            order?.totalWithTax;
          if (isWarningButton) {
            return {
              disabled: false,
              visible: !orderTotalMatches,
            };
          } else {
            return {
              disabled: false,
              visible: orderTotalMatches,
            };
          }
        })
      );
    },
  });
}
```

## File: packages/vendure-plugin-invoices/src/util/default-template.ts

```typescript
export const defaultTemplate = `
<!DOCTYPE html>
<html style="margin: 0px">
  <head>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,200,700&display=swap"
    />
    <meta charset="utf-8" />
    <style>
      body {
        font-family: "Ubuntu", sans-serif;
        font-weight: 300;
        font-size: 0.6rem;
      }
      table td,
      table td * {
        vertical-align: top;
      }
      h6 {
        font-size: 0.6rem;
        margin: 0;
      }
      h4 {
        font-size: 0.6rem;
        margin: 0;
      }
      h5 {
        font-size: 0.6rem;
        margin: 0;
      }
      h20 {
        font-size: 0.6rem;
        font-weight: 300;
      }
      .product-info {
        width: 30%;
      }
      .vat-info {
        width: 5%;
      }
      .subtotal-info {
        float: right;
      }
      .stick-to-top {
        vertical-align: top;
      }
      .order-line > td {
        padding: 0.6em 0;
      }
    </style>
    <title>Order: {{ order.code }}</title>
  </head>
  <body style="width: 100%">
    <!-- INVOICE INFO + LOGO -->
    <table style="width: 96%">
      <tr>
        <td id="invoice-info">
          {{#if isCreditInvoice}}
          <h1>Credit invoice</h1>
          {{else}}
          <h1>Invoice</h1>
          {{/if}}
          <h20><strong>Order Date: </strong>{{ orderDate }}</h20><br />
          <h20><strong>Order: </strong>{{ order.code }}</h20><br />
          <h20><strong>Invoice Number: </strong>{{ invoiceNumber }}</h20><br />
          {{#if originalInvoiceNumber}}
          <h20
            ><strong>Credit for Invoice: </strong>{{ originalInvoiceNumber
            }}</h20
          ><br />
          {{/if}}
        </td>
        <td id="logo">
          <img
            src="https://pinelab.studio/pinelab.png"
            style="height: 50px; float: right"
          />
        </td>
      </tr>
    </table>
    <hr />
    <!-- LINE -->
    <!--CLIENT INFO + COMPANY INFO -->
    <br />
    <br />
    <table style="width: 100%">
      <tr>
        <td id="shipping-info">
          <h4>Shipping Info</h4>
          <h20
            >{{#with order.shippingAddress }} {{ fullName }}<br />
            {{#if company}} {{ company }}<br />
            {{/if}} {{#if streetLine1}} {{ streetLine1 }} {{ streetLine2 }}<br />
            {{/if}} {{#if postalCode}} {{ postalCode }}, {{ city }}<br />
            {{/if}} {{#if country}} {{ country }}<br />
            {{/if}} {{/with}}
          </h20>
        </td>
        <td id="billing-info">
          {{#if order.billingAddress.streetLine1}}
          <h4>Billing Info</h4>
          <h20
            >{{#with order.billingAddress }} {{ fullName }}<br />
            {{#if company}} {{ company }}<br />
            {{/if}} {{#if streetLine1}} {{ streetLine1 }} {{ streetLine2 }}<br />
            {{/if}} {{#if postalCode}} {{ postalCode }}, {{ city }}<br />
            {{/if}} {{#if country}} {{ country }}<br />
            {{/if}} {{/with}}
          </h20>
          {{/if}}
        </td>
      </tr>
    </table>
    <br />
    <br />
    <!-- Don't render order lines for credit invoices, just the totals -->
    {{#unless isCreditInvoice}}
    <!-- PRODUCTS, QUANTITY, AMOUNT IN -->
    <table style="width: 96%">
      <tr>
        <td class="product-info">
          <h4>Product</h4>
        </td>
        <td class="quantity-info">
          <h4>Qty</h4>
        </td>
        <td class="subtotal-info">
          <h4>Total</h4>
        </td>
      </tr>
    </table>
    <hr />
    <!-- LINE -->
    <!-- PRODUCT INFO -->
    <table style="width: 96%">
      {{#each order.lines }}
      <tr class="order-line">
        <td class="product-info stick-to-top">{{ productVariant.name }}</td>
        <td class="quantity-info">{{ quantity }}</td>
        <td class="subtotal-info">€ {{ formatMoney discountedLinePrice }}</td>
      </tr>
      {{/each}}
      <!-- SHIPPING COSTS -->
      {{#each order.shippingLines }}
      <tr>
        <td class="product-info"><strong>{{ shippingMethod.name }}</strong></td>
        <td class="quantity-info"></td>
        <td class="subtotal-info"><h20>€ {{ formatMoney price }}</h20></td>
      </tr>
      {{/each}}
      <!-- DISCOUNT -->
      {{#each order.discounts }}
      <tr>
        <td class="product-info"><h20>{{ description }}</h20></td>
        <td class="quantity-info"></td>
        <td class="subtotal-info"><h20>£{{ formatMoney amount }}</h20></td>
      </tr>
      {{/each}}
    </table>
    {{/unless}}
    <hr />
    <!-- LINE -->
    <!-- TAX INFO - (SUB)TOTAL PRICE -->
    <table style="width: 96%">
      <tr>
        <td id="tax-information" style="width: 50%">
          {{#if payment.metadata.method }}
          <h6>Paid with:</h6>
          {{ payment.metadata.method }} {{/if}} {{#each order.taxSummary }}
          {{#if taxTotal }}
          <h6>{{ description }}:</h6>
          {{ taxRate }}%: € {{ formatMoney taxTotal }} {{/if}} {{/each}}
        </td>
        <td id="total-amount ">
          <h5>Total Excl. Tax: € {{ formatMoney order.total }}</h5>
          <h2>Total: € {{ formatMoney order.totalWithTax }}</h2>
        </td>
      </tr>
    </table>
    <hr />
    <!-- LINE -->
    <td style="float: right"></td>
    <br />
    <br />
    <!-- COMPANY DETAILS -->
    <table style="width: 96%; margin-top: 20px">
      <tr>
        <td style="width: 60%; float: top">
          <b>Company Registration:</b> 767302223 <br />
          <b>VAT ID:</b> NL840334343<br />
          <b>Email:</b> martijn@pinelab.studio<br />
        </td>
        <td>
          <b>Pinelab</b><br />
          Pinestreet<br />
          Leeuwarden<br />
          XXXX Postalcode<br />
          The Netherlands<br />
          Tel: +31 111118888
        </td>
      </tr>
    </table>
  </body>
</html>
`;
```

## File: packages/vendure-plugin-invoices/src/util/file.util.ts

```typescript
import { Logger } from '@vendure/core';
import fs from 'fs/promises';
import * as tmp from 'tmp';
import { loggerCtx } from '../constants';
import AdmZip = require('adm-zip');
export async function createTempFile(postfix: string): Promise<string> {
  return new Promise((resolve, reject) => {
    tmp.file({ postfix }, (err, path) => {
      if (err) {
        reject(err);
      } else {
        resolve(path);
      }
    });
  });
}
export interface ZippableFile {
  name: string;
  path: string;
}
export async function exists(path: string): Promise<boolean> {
  let exists = false;
  try {
    await fs.access(path);
    exists = true;
  } catch (error) {
    exists = false;
  }
  return exists;
}
export function safeRemove(path: string): void {
  fs.unlink(path).catch((err: any) => {
    Logger.error(
      `Could not remove file ${path}: ${err?.message}`,
      loggerCtx,
      JSON.stringify(err?.stack)
    );
  });
}
export async function zipFiles(files: ZippableFile[]): Promise<string> {
  const zip = new AdmZip();
  for (const file of files) {
    zip.addLocalFile(file.path, undefined, file.name);
  }
  const tmpFilePath = await createTempFile('.zip');
  zip.writeZip(tmpFilePath);
  return tmpFilePath;
}
```

## File: packages/vendure-plugin-invoices/src/util/order-calculations.ts

```typescript
import { InvoiceOrderTotals } from '../ui/generated/graphql';
export function reverseOrderTotals(
  orderTotal: InvoiceOrderTotals
): InvoiceOrderTotals {
  const reversedSummaries = orderTotal.taxSummaries.map((summary) => {
    return {
      description: summary.description,
      taxRate: summary.taxRate,
      taxBase: -summary.taxBase,
      taxTotal: -summary.taxTotal,
    };
  });
  return {
    total: -orderTotal.total,
    totalWithTax: -orderTotal.totalWithTax,
    taxSummaries: reversedSummaries,
  };
}
```

## File: packages/vendure-plugin-invoices/src/util/v2-migration.ts

```typescript
import { InvoiceEntity } from '../entities/invoice.entity';
import { Order } from '@vendure/core';
import { QueryRunner } from 'typeorm';
type OrderWithInvoice = Order & { invoice: InvoiceEntity };
export async function migrateInvoices(queryRunner: QueryRunner): Promise<void> {
  const orderRepo = queryRunner.manager.getRepository(Order);
  const invoiceRepo = queryRunner.manager.getRepository(InvoiceEntity);
  const take = 100;
  let hasMore = true;
  let migratedInvoices = 0;
  let total: number | undefined = undefined;
  while (hasMore) {
    const [items, count] = await orderRepo
      .createQueryBuilder('order')
      .leftJoinAndSelect('order.lines', 'lines')
      .innerJoinAndMapOne(
        'order.invoice',
        InvoiceEntity,
        'invoice',
        'invoice.orderId = order.id'
      )
      .where('invoice.orderTotals IS NULL')
      .take(take)
      .getManyAndCount();
    const orders: OrderWithInvoice[] = items as any;
    if (!total) {
      total = count;
    }
    if (orders.length === 0) {
      hasMore = false;
      break;
    }
    const invoicesWithTotals = orders.map((order) => {
      order.invoice.orderTotals = {
        taxSummaries: order.taxSummary.map((t) => {
          return {
            description: t.description,
            taxRate: t.taxRate,
            taxBase: t.taxBase,
            taxTotal: t.taxTotal,
          };
        }),
        total: order.total,
        totalWithTax: order.totalWithTax,
      };
      return order.invoice;
    });
    await invoiceRepo.save(invoicesWithTotals);
    migratedInvoices += orders.length;
    console.log(
      `Migrated invoices ${migratedInvoices}/${total}. Last invoice nr.: ${
        orders[orders.length - 1].invoice.invoiceNumber
      }`
    );
  }
  console.log(`Successfully migrated ${migratedInvoices} invoices`);
}
```

## File: packages/vendure-plugin-invoices/src/constants.ts

```typescript
export const loggerCtx = 'InvoicePlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('INVOICE_PLUGIN_OPTIONS');
export const PLUGIN_NAME = 'vendure-plugin-invoices';
```

## File: packages/vendure-plugin-invoices/src/index.ts

```typescript
export * from './invoice.plugin';
export * from './api/invoice-admin.resolver';
export * from './api/invoice-common.resolver';
export * from './api/invoice.controller';
export * from './entities/invoice.entity';
export * from './entities/invoice.entity';
export * from './strategies/load-data-fn';
export * from './strategies/storage/google-storage-invoice-strategy';
export * from './strategies/storage/local-file-strategy';
export * from './strategies/storage/s3-storage.strategy';
export * from './strategies/storage/storage-strategy';
export * from './strategies/accounting/accounting-export-strategy';
export * from './strategies/accounting/xero-uk-export-strategy';
export * from './util/file.util';
export * from './util/order-calculations';
export * from './util/default-template';
export * from './util/v2-migration';
export * from './services/invoice.service';
export * from './ui/generated/graphql';
export * from './services/invoice-created-event';
```

## File: packages/vendure-plugin-invoices/src/invoice.plugin.ts

```typescript
import {
  Injector,
  Logger,
  PluginCommonModule,
  RuntimeVendureConfig,
  Type,
  VendurePlugin,
} from '@vendure/core';
import { OnApplicationBootstrap, OnModuleInit } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import {
  adminSchemaExtensions,
  shopSchemaExtensions,
} from './api/api-extensions';
import { InvoiceAdminResolver } from './api/invoice-admin.resolver';
import {
  InvoiceCommonResolver,
  invoicePermission,
} from './api/invoice-common.resolver';
import { InvoiceController } from './api/invoice.controller';
import { defaultLoadDataFn, LoadDataFn } from './strategies/load-data-fn';
import { LocalFileStrategy } from './strategies/storage/local-file-strategy';
import { PLUGIN_INIT_OPTIONS, loggerCtx } from './constants';
import { InvoiceConfigEntity } from './entities/invoice-config.entity';
import { InvoiceEntity } from './entities/invoice.entity';
import { StorageStrategy } from './strategies/storage/storage-strategy';
import { InvoiceService } from './services/invoice.service';
import {
  LicenseService,
  VendureHubPlugin,
} from '@vendure-hub/vendure-hub-plugin';
import { AccountingExportStrategy } from './strategies/accounting/accounting-export-strategy';
import { AccountingService } from './services/accounting.service';
export interface InvoicePluginConfigInput {
  vendureHost: string;
  licenseKey: string;
  loadDataFn?: LoadDataFn;
  storageStrategy?: StorageStrategy;
  startInvoiceNumber?: number;
  accountingExports?: AccountingExportStrategy[];
}
export interface InvoicePluginConfig extends InvoicePluginConfigInput {
  loadDataFn: LoadDataFn;
  storageStrategy: StorageStrategy;
  hasValidLicense: boolean;
  startInvoiceNumber: number;
}
@VendurePlugin({
  imports: [PluginCommonModule, VendureHubPlugin],
  entities: [InvoiceConfigEntity, InvoiceEntity],
  providers: [
    InvoiceService,
    { provide: PLUGIN_INIT_OPTIONS, useFactory: () => InvoicePlugin.config },
    AccountingService,
  ],
  controllers: [InvoiceController],
  adminApiExtensions: {
    schema: adminSchemaExtensions,
    resolvers: [InvoiceAdminResolver, InvoiceCommonResolver],
  },
  shopApiExtensions: {
    schema: shopSchemaExtensions,
    resolvers: [InvoiceCommonResolver],
  },
  compatibility: '>=2.2.0',
  configuration: (config: RuntimeVendureConfig) => {
    config.authOptions.customPermissions.push(invoicePermission);
    return config;
  },
})
export class InvoicePlugin implements OnApplicationBootstrap, OnModuleInit {
  static config: InvoicePluginConfig;
  constructor(
    private licenseService: LicenseService,
    private moduleRef: ModuleRef
  ) {}
  async onModuleInit(): Promise<void> {
    for (const strategy of InvoicePlugin.config.accountingExports || []) {
      if (strategy.init) {
        await strategy.init(new Injector(this.moduleRef));
        Logger.info(
          `Initialized accounting export strategy: ${strategy.constructor.name}`,
          loggerCtx
        );
      }
    }
    if (InvoicePlugin.config.storageStrategy) {
      await InvoicePlugin.config.storageStrategy.init();
      Logger.info(
        `Initialized storage strategy: ${InvoicePlugin.config.storageStrategy.constructor.name}`,
        loggerCtx
      );
    }
  }
  onApplicationBootstrap(): void {
    this.licenseService
      .checkLicenseKey(
        InvoicePlugin.config.licenseKey,
        '@vendure-hub/pinelab-invoice-plugin'
      )
      .then((result) => {
        if (!result.valid) {
          Logger.error(
            `Your license key is invalid. Make sure to obtain a valid license key from the Vendure Hub if you want to keep using this plugin. Viewing invoices is disabled. Invoice generation will continue as usual.`,
            loggerCtx
          );
          InvoicePlugin.config.hasValidLicense = false;
        } else {
          InvoicePlugin.config.hasValidLicense = true;
        }
      })
      .catch((err) => {
        Logger.error(
          `Error checking license key: ${err?.message}. Viewing invoices is disabled. Invoice generation will continue as usual.`,
          loggerCtx
        );
        InvoicePlugin.config.hasValidLicense = false;
      });
  }
  static init(config: InvoicePluginConfigInput): Type<InvoicePlugin> {
    InvoicePlugin.config = {
      ...config,
      storageStrategy: config.storageStrategy || new LocalFileStrategy(),
      loadDataFn: config.loadDataFn || defaultLoadDataFn,
      hasValidLicense: false,
      startInvoiceNumber: config.startInvoiceNumber || 10000,
    };
    return this;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'invoices',
        ngModuleFileName: 'invoices.module.ts',
        ngModuleName: 'InvoicesModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'invoices-nav.module.ts',
        ngModuleName: 'InvoicesNavModule',
      },
    ],
    routes: [{ filePath: 'routes.ts', route: 'invoice-list' }],
    providers: ['providers.ts'],
  };
}
```

## File: packages/vendure-plugin-invoices/test/dev-server.ts

```typescript
import { initialData } from '../../test/src/initial-data';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  JobQueueService,
  LogLevel,
  mergeConfig,
  RequestContextService,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { addShippingMethod } from '../../test/src/admin-utils';
import {
  InvoicePlugin,
  InvoiceService,
  LocalFileStrategy,
  XeroUKExportStrategy,
} from '../src';
import path from 'path';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import { createSettledOrder } from '../../test/src/shop-utils';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      InvoicePlugin.init({
        vendureHost: 'http://localhost:3050',
        storageStrategy: new LocalFileStrategy(),
        licenseKey: process.env.LICENSE_KEY!,
        startInvoiceNumber: Math.floor(100000 + Math.random() * 900000),
        accountingExports: [
          new XeroUKExportStrategy({
            clientId: process.env.XERO_CLIENT_ID!,
            clientSecret: process.env.XERO_CLIENT_SECRET!,
            shippingAccountCode: '0103',
            salesAccountCode: '0102',
            invoiceBrandingThemeId: '62f2bce1-32c4-4e8d-a9b1-87060fb7c791',
            getReference: () =>
              'THIS IS A TEST INVOICE, DONT APPROVE THIS PLEASE.',
            getVendureUrl: (order) =>
              `https://pinelab.studio/order/${order.code}`,
            getDueDate: (ctx, order, invoice) => {
              const payment = order.payments.find((p) => p.state === 'Settled');
              if (payment?.method === 'purchase-order') {
                const date = new Date();
                date.setDate(date.getDate() + 30);
                return date;
              } else {
                return new Date();
              }
            },
          }),
        ],
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [InvoicePlugin.ui],
          devMode: true,
        }),
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    apiOptions: {
      adminApiPlayground: true,
      shopApiPlayground: true,
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  const jobQueueService = server.app.get(JobQueueService);
  await jobQueueService.start();
  const ctx = await server.app.get(RequestContextService).create({
    apiType: 'admin',
  });
  await server.app.get(InvoiceService).upsertConfig(ctx, { enabled: true });
  await new Promise((resolve) => setTimeout(resolve, 3000));
  await addShippingMethod(adminClient, 'manual-fulfillment');
  const orders = 1;
  for (let i = 1; i <= orders; i++) {
    await createSettledOrder(
      shopClient,
      3,
      undefined,
      undefined,
      {
        input: {
          fullName: 'Pinelab Finance Department',
          streetLine1: 'Bankstreet',
          streetLine2: '899',
          city: 'Leeuwarden',
          postalCode: '233 DE',
          countryCode: 'NL',
        },
      },
      {
        input: {
          fullName: 'Martijn Pinelab',
          streetLine1: 'Pinestreet',
          streetLine2: '16',
          city: 'Leeuwarden',
          postalCode: '736 XX',
          countryCode: 'NL',
        },
      }
    );
  }
  console.log(`Created ${orders} orders`);
})();
```

## File: packages/vendure-plugin-invoices/test/e2e.spec.ts

```typescript
import {
  assertFound,
  DefaultLogger,
  EventBus,
  ID,
  LogLevel,
  mergeConfig,
  Order,
  OrderService,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import fetch from 'node-fetch';
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { addShippingMethod, cancelOrder } from '../../test/src/admin-utils';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import {
  defaultTemplate,
  Invoice,
  InvoiceEntity,
  InvoicePlugin,
  MutationUpsertInvoiceConfigArgs,
} from '../src';
import { InvoiceCreatedEvent } from '../src/services/invoice-created-event';
import { getOrderWithInvoices } from '../src/ui/invoices-detail-view/invoices-detail-view';
import {
  createInvoice as createInvoiceMutation,
  exportToAccounting,
  getConfigQuery,
  upsertConfigMutation,
} from '../src/ui/queries.graphql';
import { MockAccountingStrategy } from './mock-accounting-strategy';
import gql from 'graphql-tag';
import { waitFor } from '../../test/src/test-helpers';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
let serverStarted = false;
let latestInvoice: Invoice;
let order: Order;
let events: InvoiceCreatedEvent[] = [];
const mockAccountingStrategy = new MockAccountingStrategy(
  'e2e-default-channel'
);
const mockAccountingStrategySpy = {
  init: vi.spyOn(mockAccountingStrategy, 'init'),
  exportInvoice: vi.spyOn(mockAccountingStrategy, 'exportInvoice'),
  exportCreditInvoice: vi.spyOn(mockAccountingStrategy, 'exportCreditInvoice'),
};
async function getLatestInvoice(orderId: ID): Promise<Invoice | undefined> {
  const { order: result } = await adminClient.query(getOrderWithInvoices, {
    id: orderId,
  });
  return result.invoices[0];
}
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    apiOptions: {
      port: 3106,
    },
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      InvoicePlugin.init({
        vendureHost: 'http://localhost:3106',
        licenseKey: 'BogusLicenseKey',
        accountingExports: [mockAccountingStrategy],
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  serverStarted = true;
  await adminClient.asSuperAdmin();
  server.app
    .get(EventBus)
    .ofType(InvoiceCreatedEvent)
    .subscribe((event) => events.push(event));
}, 30000);
it('Should start successfully', async () => {
  await expect(serverStarted).toBe(true);
});
it('Initialized accounting export strategies', async () => {
  expect(
    mockAccountingStrategySpy.init.mock.calls.length
  ).toBeGreaterThanOrEqual(1);
});
describe('Generate with credit invoicing enabled', function () {
  it('Upserts config', async () => {
    await adminClient.asSuperAdmin();
    const result = await adminClient.query<
      any,
      MutationUpsertInvoiceConfigArgs
    >(upsertConfigMutation, {
      input: {
        enabled: true,
        createCreditInvoices: true,
        templateString: defaultTemplate,
      },
    });
    expect(result.upsertInvoiceConfig.id).toBeDefined();
    expect(result.upsertInvoiceConfig.enabled).toBe(true);
    expect(result.upsertInvoiceConfig.createCreditInvoices).toBe(true);
    expect(result.upsertInvoiceConfig.templateString).toBe(defaultTemplate);
  });
  it('Gets config', async () => {
    await adminClient.asSuperAdmin();
    const result = await adminClient.query(getConfigQuery);
    expect(result.invoiceConfig?.id).toBeDefined();
    expect(result.invoiceConfig?.enabled).toBe(true);
    expect(result.invoiceConfig?.templateString).toBe(defaultTemplate);
  });
  it('Creates a placed order', async () => {
    await addShippingMethod(adminClient, 'manual-fulfillment');
    order = (await createSettledOrder(shopClient, 3)) as any;
    expect((order as any).id).toBeDefined();
  });
  it('Gets invoices for order', async () => {
    latestInvoice = await waitFor(() => getLatestInvoice(order.id));
    expect(latestInvoice.id).toBeDefined();
    expect(latestInvoice.createdAt).toBeDefined();
    expect(latestInvoice.invoiceNumber).toBe(10001);
    expect(latestInvoice.isCreditInvoice).toBe(false);
    expect(latestInvoice.downloadUrl).toContain(
      `/invoices/e2e-default-channel/${order.code}/10001?email=hayden.zieme12%40hotmail.com`
    );
  });
  it('Emitted event for created invoice', async () => {
    const newInvoice = events[0].newInvoice;
    expect(newInvoice.createdAt).toBeDefined();
    expect(newInvoice.channelId).toBeDefined();
    expect(newInvoice.id).toBeDefined();
    expect(newInvoice.invoiceNumber).toBe(10001);
    expect(newInvoice.isCreditInvoice).toBe(false);
    expect(newInvoice.orderTotals.total).toBe(order.total);
    expect(newInvoice.orderTotals.totalWithTax).toBe(order.totalWithTax);
    expect(newInvoice.orderTotals.taxSummaries.length).toBe(2);
    expect(events[0].creditInvoice).toBeUndefined();
    expect(events[0].previousInvoice).toBeUndefined();
    expect(events[1]).toBeUndefined();
  });
  it('Triggered accounting export strategy', async () => {
    const getMockCalls = () =>
      mockAccountingStrategySpy.exportInvoice.mock.calls[0];
    const [ctx, invoice, order] = await waitFor(getMockCalls);
    expect(mockAccountingStrategySpy.exportInvoice).toHaveBeenCalledTimes(1);
    expect(ctx).toBeInstanceOf(RequestContext);
    expect(invoice).toBeInstanceOf(InvoiceEntity);
    expect(invoice.isCreditInvoiceFor).toBe(null);
    expect(order).toBeInstanceOf(Order);
  });
  it('Modifies order', async () => {
    const ctx = await getSuperadminContext(server.app);
    const orderId = String(order.id).replace('T_', ''); // replace T_ prefix
    await server.app
      .get(TransactionalConnection)
      .getRepository(ctx, Order)
      .update(orderId, {
        // Ugly modification, but good enough for testing invoice regeneration
        subTotal: 1234,
        subTotalWithTax: 1480,
        shipping: 0,
        shippingWithTax: 0,
      });
    order = await assertFound(
      server.app.get(OrderService).findOne(ctx, orderId)
    );
    expect(order.total).toBe(1234);
    expect(order.totalWithTax).toBe(1480);
  });
  it('Fails to export to accounting, because order totals dont match the invoice anymore', async () => {
    await adminClient.query(exportToAccounting, {
      invoiceNumber: 10001,
    });
    const invoice = await waitFor(async () => {
      const invoice = await getLatestInvoice(1);
      if (invoice?.accountingReference?.errorMessage) {
        return invoice;
      }
    });
    expect(invoice.accountingReference?.errorMessage).toContain(
      'has changed compared to the invoice'
    );
  });
  it('Creates credit and new invoice on createInvoice mutation', async () => {
    const result = await adminClient.query(createInvoiceMutation, {
      orderId: order.id,
    });
    latestInvoice = result.createInvoice;
    expect(latestInvoice.invoiceNumber).toBe(10003);
    expect(latestInvoice.isCreditInvoice).toBe(false);
    expect(latestInvoice.downloadUrl).toContain(
      `/invoices/e2e-default-channel/${order.code}/10003?email=hayden.zieme12%40hotmail.com`
    );
  });
  it('Emitted event for credit and new invoice', async () => {
    const newInvoice = events[1].newInvoice;
    const creditInvoice = events[1].creditInvoice!;
    const previousInvoice = events[1].previousInvoice!;
    expect(previousInvoice.invoiceNumber).toBe(10001);
    expect(creditInvoice.invoiceNumber).toBe(10002);
    expect(newInvoice.invoiceNumber).toBe(10003);
    expect(creditInvoice?.isCreditInvoice).toBe(true);
    expect(previousInvoice.isCreditInvoice).toBe(false);
    expect(newInvoice.isCreditInvoice).toBe(false);
    expect(creditInvoice.orderTotals.total).toBe(
      -previousInvoice.orderTotals.total
    );
    expect(creditInvoice.orderTotals.totalWithTax).toBe(
      -previousInvoice.orderTotals.totalWithTax
    );
    expect(newInvoice.orderTotals.total).toBe(1234);
    expect(newInvoice.orderTotals.totalWithTax).toBe(1480);
    expect(events[2]).toBeUndefined();
  });
  it('Triggered accounting export strategy for credit invoice', async () => {
    const [ctx, invoice, isCreditInvoiceFor, order] = await waitFor(() => {
      return mockAccountingStrategySpy.exportCreditInvoice.mock.calls[0];
    });
    expect(ctx).toBeInstanceOf(RequestContext);
    expect(invoice).toBeInstanceOf(InvoiceEntity);
    expect(isCreditInvoiceFor?.invoiceNumber).toBe(10001);
    expect(order).toBeInstanceOf(Order);
  });
  it('Triggered accounting export strategy for new invoice after credit invoice', async () => {
    const [ctx, invoice, order] = await waitFor(() => {
      return mockAccountingStrategySpy.exportInvoice.mock.calls[1];
    });
    expect(ctx).toBeInstanceOf(RequestContext);
    expect(invoice).toBeInstanceOf(InvoiceEntity);
    expect(order).toBeInstanceOf(Order);
  });
  it('Returns all invoices for order', async () => {
    const { order: result } = await adminClient.query(getOrderWithInvoices, {
      id: order.id,
    });
    const invoices: Invoice[] = result.invoices;
    expect(invoices.length).toBe(3);
    expect(invoices[2].invoiceNumber).toBe(10001);
    expect(invoices[1].invoiceNumber).toBe(10002);
    expect(invoices[1].isCreditInvoice).toBe(true);
    expect(invoices[0].invoiceNumber).toBe(10003);
  });
  it('Exports the credit invoice to accounting again via mutation', async () => {
    const { exportInvoiceToAccountingPlatform } = await adminClient.query(gql`
      mutation {
        exportInvoiceToAccountingPlatform(invoiceNumber: 10002)
      }
    `);
    const [ctx, invoice, isCreditInvoiceFor] = await waitFor(() => {
      return mockAccountingStrategySpy.exportCreditInvoice.mock.calls[1];
    });
    expect(exportInvoiceToAccountingPlatform).toBe(true);
    expect(invoice.invoiceNumber).toBe(10002);
    expect(isCreditInvoiceFor?.invoiceNumber).toBe(10001);
  });
  it('Cancels order and creates credit invoice', async () => {
    await cancelOrder(adminClient, order as any);
    const latestInvoice = await waitFor(async () => {
      const invoice = await getLatestInvoice(order.id);
      // Only return if a creditInvoice was created, otherwise wait and try again
      if (invoice?.isCreditInvoice) {
        return invoice;
      }
    });
    expect(latestInvoice.isCreditInvoice).toBe(true);
    // Event for credit invoice should have been emitted
    expect(events[2].creditInvoice).toBeUndefined();
    expect(events[2].newInvoice.isCreditInvoice).toBe(true);
  });
});
describe('Download invoices', function () {
  it('Downloads first invoice when no invoice number is specified', async () => {
    const res = await fetch(
      `http:
    );
    expect(res.status).toBe(200);
    expect(res.headers.get('Content-type')).toBe('application/pdf');
    expect(res.body.pipe).toBeDefined();
  });
  it('Downloads a pdf via URL with invoice number', async () => {
    const res = await fetch(
      `http://localhost:3106/invoices/e2e-default-channel/${order.code}/10001?email=hayden.zieme12%40hotmail.com`
    );
    expect(res.status).toBe(200);
    expect(res.headers.get('Content-type')).toBe('application/pdf');
    expect(res.body.pipe).toBeDefined();
  });
  it('Download fails for invalid email', async () => {
    const res = await fetch(
      `http://localhost:3106/invoices/e2e-default-channel/${order.code}?email=malicious@gmail.com`
    );
    expect(res.status).toBe(403);
  });
  it('Download fails for invalid channel', async () => {
    const res = await fetch(
      `http://localhost:3106/invoices/wrong-channel/${order.code}?email=hayden.zieme12%40hotmail.com`
    );
    expect(res.status).toBe(403);
    const json = await res.json();
    expect(json.message).toBeDefined();
  });
  it('Previews a PDF', async () => {
    const res = await adminClient.fetch(
      `http://localhost:3106/invoices/preview/${order.code}`,
      {
        method: 'POST',
        body: JSON.stringify({ template: defaultTemplate }),
      }
    );
    expect(res.status).toBe(201);
  });
  it('Fails to preview for unauthenticated calls', async () => {
    const res = await fetch(
      `http://localhost:3106/invoices/preview/${order.code}`,
      {
        method: 'POST',
        body: JSON.stringify({ template: defaultTemplate }),
      }
    );
    expect(res.status).toBe(403);
  });
});
describe('Generate without credit invoicing', function () {
  it('Resets events', async () => {
    events = [];
  });
  it('Disables credit invoice generation', async () => {
    await adminClient.asSuperAdmin();
    const result = await adminClient.query<
      any,
      MutationUpsertInvoiceConfigArgs
    >(upsertConfigMutation, {
      input: {
        enabled: true,
        createCreditInvoices: false,
        templateString: defaultTemplate,
      },
    });
    expect(result.upsertInvoiceConfig.id).toBeDefined();
    expect(result.upsertInvoiceConfig.enabled).toBe(true);
    expect(result.upsertInvoiceConfig.templateString).toBe(defaultTemplate);
    expect(result.upsertInvoiceConfig.createCreditInvoices).toBe(false);
  });
  it('Creates settled order', async () => {
    order = (await createSettledOrder(shopClient, 3)) as any;
    expect((order as any).id).toBeDefined();
  });
  it('Created invoice', async () => {
    latestInvoice = await waitFor(() => getLatestInvoice(order.id));
    expect(latestInvoice.id).toBeDefined();
    expect(latestInvoice.createdAt).toBeDefined();
    expect(latestInvoice.invoiceNumber).toBe(10005);
    expect(latestInvoice.isCreditInvoice).toBe(false);
    expect(latestInvoice.downloadUrl).toContain(
      `/invoices/e2e-default-channel/${order.code}/10005?email=hayden.zieme12%40hotmail.com`
    );
  });
  it('Emitted event', async () => {
    expect(events[0].newInvoice).toBeDefined();
    expect(events[0].previousInvoice).toBeUndefined();
    expect(events[0].creditInvoice).toBeUndefined();
  });
  it('Creates new invoice without credit invoice on createInvoices mutation', async () => {
    const result = await adminClient.query(createInvoiceMutation, {
      orderId: order.id,
    });
    latestInvoice = result.createInvoice;
    expect(latestInvoice.invoiceNumber).toBe(10006);
    expect(latestInvoice.isCreditInvoice).toBe(false);
    expect(latestInvoice.downloadUrl).toContain(
      `/invoices/e2e-default-channel/${order.code}/10006?email=hayden.zieme12%40hotmail.com`
    );
  });
  it('Emitted event without credit invoice', async () => {
    expect(events[1].newInvoice).toBeDefined();
    expect(events[1].previousInvoice).toBeDefined();
    expect(events[1].creditInvoice).toBeUndefined();
  });
});
if (process.env.TEST_ADMIN_UI) {
  it('Should compile admin', async () => {
    const files = await getFilesInAdminUiFolder(__dirname, InvoicePlugin.ui);
    expect(files?.length).toBeGreaterThan(0);
  }, 200000);
}
afterAll(async () => {
  await server.destroy();
});
```

## File: packages/vendure-plugin-invoices/test/mock-accounting-strategy.ts

```typescript
import { Injector, RequestContext, Order } from '@vendure/core';
import {
  AccountingExportStrategy,
  ExternalReference,
  InvoiceEntity,
} from '../src';
export class MockAccountingStrategy implements AccountingExportStrategy {
  constructor(public channelToken?: string) {}
  init(injector: Injector): void {
    return;
  }
  exportInvoice(
    ctx: RequestContext,
    invoice: InvoiceEntity,
    order: Order
  ): ExternalReference {
    return {
      reference: 'mockReference',
      link: 'mockLink',
    };
  }
  exportCreditInvoice(
    ctx: RequestContext,
    invoice: InvoiceEntity,
    isCreditInvoiceFor: InvoiceEntity,
    order: Order
  ): ExternalReference {
    return {
      reference: 'mockCreditReference',
      link: 'mockCreditLink',
    };
  }
}
```

## File: packages/vendure-plugin-klaviyo/src/api/api-extensions.ts

```typescript
import { gql } from 'graphql-tag';
export const shopApiExtensions = gql`
  extend type Mutation {
    """
    This mutation indicates that a customer has started the checkout process.
    The frontend should call this mutation. It will make the Klaviyo plugin emit a CheckoutStartedEvent.
    """
    klaviyoCheckoutStarted: Boolean!
    """
    Subscribe an email address to a Klaviyo list.
    Klaviyo also sends a confirmation before the subscription is active (double opt-in).
    """
    subscribeToKlaviyoList(emailAddress: String!, listId: String!): Boolean!
  }
`;
```

## File: packages/vendure-plugin-klaviyo/src/api/klaviyo-shop-resolver.ts

```typescript
import { Args, Mutation, Resolver } from '@nestjs/graphql';
import {
  ActiveOrderService,
  Ctx,
  EventBus,
  ForbiddenError,
  RequestContext,
} from '@vendure/core';
import { CheckoutStartedEvent } from '../service/checkout-started-event';
import { KlaviyoService } from '../service/klaviyo.service';
@Resolver()
export class KlaviyoShopResolver {
  constructor(
    private readonly activeOrderService: ActiveOrderService,
    private readonly klaviyoService: KlaviyoService,
    private readonly eventBus: EventBus
  ) {}
  @Mutation()
  async klaviyoCheckoutStarted(@Ctx() ctx: RequestContext): Promise<boolean> {
    const activeOrder = await this.activeOrderService.getActiveOrder(
      ctx,
      undefined
    );
    if (activeOrder) {
      await this.eventBus.publish(new CheckoutStartedEvent(ctx, activeOrder));
      return true;
    }
    return false;
  }
  @Mutation()
  async subscribeToKlaviyoList(
    @Ctx() ctx: RequestContext,
    @Args('emailAddress') emailAddress: string,
    @Args('listId') list: string
  ): Promise<boolean> {
    if (!ctx.session?.token) {
      throw new ForbiddenError();
    }
    await this.klaviyoService.subscribeToList(ctx, emailAddress, list);
    return true;
  }
}
```

## File: packages/vendure-plugin-klaviyo/src/event-handler/checkout-started-event-handler.ts

```typescript
import {
  KlaviyoEventHandler,
  KlaviyoGenericEvent,
} from '../event-handler/klaviyo-event-handler';
import { EntityHydrator, Logger } from '@vendure/core';
import { CheckoutStartedEvent } from '../service/checkout-started-event';
import { loggerCtx } from '../constants';
export const startedCheckoutHandler: KlaviyoEventHandler<CheckoutStartedEvent> =
  {
    vendureEvent: CheckoutStartedEvent,
    mapToKlaviyoEvent: async ({ ctx, order }, injector) => {
      await injector.get(EntityHydrator).hydrate(ctx, order, {
        relations: ['customer', 'lines.productVariant'],
      });
      if (!order.customer?.emailAddress) {
        return false;
      }
      const address = order.billingAddress?.streetLine1
        ? order.billingAddress
        : order.shippingAddress;
      const event: KlaviyoGenericEvent = {
        eventName: 'Checkout Started',
        uniqueId: order.code,
        customProperties: {
          orderCode: order.code,
          orderItems: order.lines.map((line) => ({
            productName: line.productVariant.name,
            quantity: line.quantity,
          })),
        },
        profile: {
          emailAddress: order.customer.emailAddress,
          externalId: order.customer.id.toString(),
          firstName: order.customer.firstName,
          lastName: order.customer.lastName,
          phoneNumber: order.customer.phoneNumber,
          address: {
            address1: address?.streetLine1,
            address2: address?.streetLine2,
            city: address?.city,
            postalCode: address?.postalCode,
            countryCode: address.countryCode,
          },
        },
      };
      Logger.info(
        `Sent '${event.eventName}' to Klaviyo for order ${order.code}`,
        loggerCtx
      );
      return event;
    },
  };
```

## File: packages/vendure-plugin-klaviyo/src/event-handler/default-order-placed-event-handler.ts

```typescript
import { OrderAddress } from '@vendure/common/lib/generated-types';
import {
  Address,
  Logger,
  OrderPlacedEvent,
  OrderService,
  translateDeep,
} from '@vendure/core';
import { loggerCtx } from '../constants';
import { toKlaviyoMoney } from '../util/to-klaviyo-money';
import { KlaviyoOrderPlacedEventHandler } from './klaviyo-event-handler';
export const defaultOrderPlacedEventHandler: KlaviyoOrderPlacedEventHandler = {
  vendureEvent: OrderPlacedEvent,
  mapToKlaviyoEvent: async ({ order: { id, code }, ctx }, injector) => {
    const order = await injector
      .get(OrderService)
      .findOne(ctx, id, [
        'lines.productVariant.product.facetValues.facet',
        'lines.productVariant.product.translations',
        'lines.productVariant.collections.children',
        'lines.productVariant.featuredAsset',
        'shippingLines.shippingMethod',
        'customer.addresses.country',
        'customer.user',
      ]);
    if (!order?.customer) {
      Logger.error(
        `Can not send Order placed Event to Klaviyo, because order ${code} has no customer`,
        loggerCtx
      );
      return false;
    }
    order.lines.forEach((line) => {
      line.productVariant = translateDeep(
        line.productVariant,
        ctx.languageCode
      );
    });
    let address: Address | OrderAddress | undefined =
      order.customer.addresses.find((a) => a.defaultShippingAddress);
    if (!address) {
      address = order.shippingAddress;
    }
    return {
      eventName: 'Order Placed',
      uniqueId: order.code,
      orderId: order.code,
      orderPlacedAt: order.orderPlacedAt ?? order.updatedAt,
      totalOrderValue: toKlaviyoMoney(order.totalWithTax),
      profile: {
        emailAddress: order.customer.emailAddress,
        externalId: order.customer.id.toString(),
        firstName: order.customer.firstName,
        lastName: order.customer.lastName,
        phoneNumber: order.customer.phoneNumber,
        address: {
          address1: address?.streetLine1,
          address2: address?.streetLine2,
          city: address?.city,
          postalCode: address?.postalCode,
          countryCode:
            (address as OrderAddress).countryCode ??
            (address as Address)?.country?.code,
        },
      },
      orderItems: order.lines.map((line) => ({
        ProductID: line.productVariant.id.toString(),
        SKU: line.productVariant.sku,
        ProductName: line.productVariant.name,
        Quantity: line.quantity,
        ItemPrice: toKlaviyoMoney(line.proratedUnitPriceWithTax),
        RowTotal: toKlaviyoMoney(line.proratedLinePriceWithTax),
        ImageURL: line.featuredAsset?.preview,
      })),
      customProperties: {},
    };
  },
};
```

## File: packages/vendure-plugin-klaviyo/src/event-handler/klaviyo-event-handler.ts

```typescript
import {
  Injector,
  OrderPlacedEvent,
  RequestContext,
  Type,
  VendureEvent,
} from '@vendure/core';
export declare type EventWithContext = VendureEvent & {
  ctx: RequestContext;
};
export interface KlaviyoOrderItem {
  ProductID: string;
  SKU: string;
  ProductName: string;
  Quantity: number;
  ItemPrice: number;
  RowTotal: number;
  ProductURL?: string;
  ImageURL?: string;
  Categories?: string[];
  Brand?: string;
  customProperties?: CustomProperties;
  excludeFromOrderedProductEvent?: boolean;
}
type CustomProperties = Record<string, unknown>;
export interface KlaviyoGenericEvent {
  uniqueId: string;
  eventName: string;
  profile: {
    emailAddress: string;
    externalId: string;
    firstName?: string;
    lastName?: string;
    phoneNumber?: string;
    customProperties?: CustomProperties;
    address?: {
      address1?: string;
      address2?: string;
      city?: string;
      postalCode?: string;
      countryCode?: string;
    };
  };
  customProperties?: CustomProperties;
}
export interface KlaviyoOrderPlacedEvent extends KlaviyoGenericEvent {
  eventName: 'Order Placed';
  orderId: string;
  orderPlacedAt: Date;
  totalOrderValue: number;
  orderItems: KlaviyoOrderItem[];
  discountCode?: string;
}
export type KlaviyoEventMapFn<
  EventType extends EventWithContext,
  ReturnType
> = (
  event: EventType,
  injector: Injector
) => Promise<ReturnType | false> | ReturnType | false;
export interface KlaviyoEventHandler<T extends EventWithContext> {
  vendureEvent: Type<T>;
  mapToKlaviyoEvent: KlaviyoEventMapFn<T, KlaviyoGenericEvent>;
}
export interface KlaviyoOrderPlacedEventHandler
  extends KlaviyoEventHandler<OrderPlacedEvent> {
  mapToKlaviyoEvent: KlaviyoEventMapFn<
    OrderPlacedEvent,
    KlaviyoOrderPlacedEvent
  >;
}
```

## File: packages/vendure-plugin-klaviyo/src/service/checkout-started-event.ts

```typescript
import { Order, RequestContext, VendureEvent } from '@vendure/core';
export class CheckoutStartedEvent extends VendureEvent {
  constructor(public ctx: RequestContext, public order: Order) {
    super();
  }
}
```

## File: packages/vendure-plugin-klaviyo/src/service/klaviyo.service.ts

```typescript
import { Inject, OnApplicationBootstrap } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  EventBus,
  Injector,
  JobQueue,
  JobQueueService,
  Logger,
  RequestContext,
  SerializedRequestContext,
} from '@vendure/core';
import { isAxiosError } from 'axios';
import {
  ApiKeySession,
  EventCreateQueryV2,
  EventsApi,
  ProfilesApi,
} from 'klaviyo-api';
import { PLUGIN_INIT_OPTIONS, loggerCtx } from '../constants';
import {
  EventWithContext,
  KlaviyoEventHandler,
  KlaviyoGenericEvent,
  KlaviyoOrderPlacedEvent,
} from '../event-handler/klaviyo-event-handler';
import { KlaviyoPluginOptions } from '../klaviyo.plugin';
import {
  mapToKlaviyoEventInput,
  mapToKlaviyoOrderPlacedInput,
  mapToOrderedProductEvent,
} from '../util/map-to-klaviyo-input';
type JobData = {
  ctx: SerializedRequestContext;
  event: KlaviyoGenericEvent;
};
export class KlaviyoService implements OnApplicationBootstrap {
  private jobQueue!: JobQueue<any>;
  constructor(
    private readonly jobQueueService: JobQueueService,
    private readonly moduleRef: ModuleRef,
    @Inject(PLUGIN_INIT_OPTIONS) private readonly options: KlaviyoPluginOptions,
    private readonly eventBus: EventBus
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'klaviyo',
      process: async ({ data: _data }) => {
        const data = _data as JobData;
        const ctx = RequestContext.deserialize(data.ctx);
        try {
          await this.handleEventJob(ctx, data.event);
          Logger.info(
            `Successfully handled job '${data.event.eventName}'`,
            loggerCtx
          );
        } catch (e) {
          Logger.warn(
            `Failed to handle job '${data.event.eventName}': ${
              (e as Error).message
            }. Job data: ${JSON.stringify(data.event)}`,
            loggerCtx
          );
          throw e;
        }
      },
    });
    if (this.options.eventHandlers.length === 0) {
      Logger.error(
        `No event handlers configured for Klaviyo. No events will be sent to Klaviyo. This means the plugin isn't doing anything.`,
        loggerCtx
      );
      return;
    }
    this.options.eventHandlers.forEach((handler) => {
      this.eventBus.ofType(handler.vendureEvent).subscribe((event) => {
        this.createEventJob(event, handler).catch((err) => {
          Logger.error(
            `Error creating job for '${event?.constructor.name}' event: ${err}`,
            loggerCtx,
            (err as Error)?.stack
          );
        });
      });
    });
    Logger.info(
      `Listening for events: ${this.options.eventHandlers
        .map((e) => e.vendureEvent.name)
        .join(', ')}`,
      loggerCtx
    );
  }
  async createEventJob<T extends EventWithContext>(
    vendureEvent: T,
    eventHandler: KlaviyoEventHandler<T>,
    retries = 10
  ): Promise<void> {
    const session = await this.getKlaviyoSession(vendureEvent.ctx);
    if (!session) {
      Logger.debug(
        `No API key provided for Klaviyo, this means klaviyo is not enabled for channel '${vendureEvent.ctx.channel.token};`,
        loggerCtx
      );
      return;
    }
    const event = await eventHandler.mapToKlaviyoEvent(
      vendureEvent,
      new Injector(this.moduleRef)
    );
    if (event) {
      const jobData: JobData = {
        ctx: vendureEvent.ctx.serialize(),
        event,
      };
      await this.jobQueue.add(jobData, { retries });
    }
  }
  async handleEventJob(
    ctx: RequestContext,
    event: KlaviyoGenericEvent | KlaviyoOrderPlacedEvent
  ): Promise<void> {
    const session = await this.getKlaviyoSession(ctx);
    if (!session) {
      return;
    }
    const klaviyoEventsApi = new EventsApi(session);
    if (event.eventName !== 'Order Placed') {
      await this.createEvent(klaviyoEventsApi, mapToKlaviyoEventInput(event));
      Logger.info(
        `Sent '${event.eventName}' event with event ID '${event.uniqueId}' to Klaviyo.`,
        loggerCtx
      );
      return;
    }
    const orderPlacedEvent = event as KlaviyoOrderPlacedEvent;
    await this.createEvent(
      klaviyoEventsApi,
      mapToKlaviyoOrderPlacedInput(orderPlacedEvent)
    );
    Logger.info(
      `Sent 'Placed Order' event to Klaviyo for order ${orderPlacedEvent.orderId}`,
      loggerCtx
    );
    for (const [index, orderItem] of orderPlacedEvent.orderItems.entries()) {
      if (orderItem.excludeFromOrderedProductEvent) {
        continue;
      }
      const orderedProductEvent = mapToOrderedProductEvent(
        orderItem,
        index,
        orderPlacedEvent
      );
      await this.createEvent(klaviyoEventsApi, orderedProductEvent);
    }
    Logger.info(
      `Sent 'Ordered Product' event to Klaviyo for order ${orderPlacedEvent.orderId} for ${orderPlacedEvent.orderItems.length} order lines`,
      loggerCtx
    );
  }
  async getKlaviyoSession(
    ctx: RequestContext
  ): Promise<ApiKeySession | undefined> {
    const apiKey =
      typeof this.options.apiKey === 'function'
        ? this.options.apiKey(ctx)
        : this.options.apiKey;
    if (!apiKey) {
      return;
    }
    return new ApiKeySession(apiKey);
  }
  async createEvent(
    klaviyoEventsApi: EventsApi,
    event: EventCreateQueryV2
  ): Promise<void> {
    try {
      const {
        response: { status, statusText },
      } = await klaviyoEventsApi.createEvent(event);
      if (status < 200 || status > 299) {
        throw new Error(
          `[${loggerCtx}]: Failed to create event '${event.data.attributes.metric.data.attributes.name}': ${statusText} (${status})`
        );
      }
    } catch (e: unknown) {
      if (isAxiosError(e) && e.response?.data?.errors[0]?.detail) {
        throw Error(
          e.response?.data.errors.map((error: any) => error?.detail)?.join(', ')
        );
      } else {
        throw e;
      }
    }
  }
  async subscribeToList(
    ctx: RequestContext,
    emailAddress: string,
    listId: string
  ): Promise<void> {
    const session = await this.getKlaviyoSession(ctx);
    if (!session) {
      return;
    }
    const klaviyoApi = new ProfilesApi(session);
    await klaviyoApi.subscribeProfiles({
      data: {
        type: 'profile-subscription-bulk-create-job',
        attributes: {
          profiles: {
            data: [
              {
                type: 'profile',
                attributes: {
                  email: emailAddress,
                  subscriptions: {
                    email: {
                      marketing: {
                        consent: 'SUBSCRIBED',
                      },
                    },
                  },
                },
              },
            ],
          },
        },
        relationships: {
          list: {
            data: {
              id: listId,
              type: 'list',
            },
          },
        },
      },
    });
    Logger.info(`Subscribed '${emailAddress}' to list '${listId}'`);
  }
}
```

## File: packages/vendure-plugin-klaviyo/src/util/map-to-klaviyo-input.ts

```typescript
import { uniq } from 'lodash';
import {
  KlaviyoGenericEvent,
  KlaviyoOrderItem,
  KlaviyoOrderPlacedEvent,
} from '../event-handler/klaviyo-event-handler';
import {
  EventCreateQueryV2,
  EventCreateQueryV2ResourceObjectAttributesProfile,
  OnsiteProfileCreateQueryResourceObjectAttributes,
} from 'klaviyo-api';
import { phone } from 'phone';
import { Logger } from '@vendure/core';
import { loggerCtx } from '../constants';
function getE164PhoneNumber(
  phoneNumberString?: string,
  countryCode = 'NL'
): string | undefined {
  if (!phoneNumberString) {
    return undefined;
  }
  const { isValid, phoneNumber } = phone(phoneNumberString, {
    country: countryCode,
  });
  if (isValid) {
    return phoneNumber;
  }
  Logger.info(
    `Not sending invalid phone number '${phoneNumberString}' to Klaviyo`,
    loggerCtx
  );
}
function mapToProfile(
  eventProfile: KlaviyoGenericEvent['profile']
): EventCreateQueryV2ResourceObjectAttributesProfile {
  const profile: OnsiteProfileCreateQueryResourceObjectAttributes = {
    email: eventProfile.emailAddress,
    externalId: eventProfile.externalId,
    firstName: eventProfile.firstName,
    lastName: eventProfile.lastName,
    phoneNumber: getE164PhoneNumber(
      eventProfile.phoneNumber,
      eventProfile.address?.countryCode
    ),
    properties: {
      ...eventProfile.customProperties,
    },
    location: {
      ...eventProfile.address,
      country: eventProfile.address?.countryCode,
    },
  };
  return {
    data: {
      type: 'profile',
      attributes: profile,
    },
  };
}
export function mapToKlaviyoOrderPlacedInput(
  event: KlaviyoOrderPlacedEvent
): EventCreateQueryV2 {
  const collections = uniq(
    event.orderItems
      .map((item) => item.Categories)
      .flat()
      .filter(Boolean)
  );
  const brands = uniq(
    event.orderItems.map((item) => item.Brand).filter(Boolean)
  );
  const orderProperties: Record<string, any> = {
    OrderId: event.orderId,
    Categories: collections,
    ItemNames: event.orderItems.map((item) => item.ProductName),
    Brands: brands,
    Items: event.orderItems.map((item) => ({
      ...item,
      ItemPrice: item.ItemPrice,
      RowTotal: item.RowTotal,
    })),
  };
  if (event.discountCode) {
    orderProperties.DiscountCode = event.discountCode;
  }
  if (event.customProperties) {
    orderProperties.CustomProperties = event.customProperties;
  }
  return {
    data: {
      type: 'event',
      attributes: {
        uniqueId: event.uniqueId,
        properties: orderProperties,
        time: new Date(event.orderPlacedAt),
        value: event.totalOrderValue,
        metric: {
          data: {
            type: 'metric',
            attributes: {
              name: 'Placed Order',
            },
          },
        },
        profile: mapToProfile(event.profile),
      },
    },
  };
}
export function mapToKlaviyoEventInput(
  event: KlaviyoGenericEvent
): EventCreateQueryV2 {
  return {
    data: {
      type: 'event',
      attributes: {
        uniqueId: event.uniqueId,
        profile: mapToProfile(event.profile),
        metric: {
          data: {
            type: 'metric',
            attributes: {
              name: event.eventName,
            },
          },
        },
        properties: event.customProperties ?? {},
      },
    },
  };
}
export function mapToOrderedProductEvent(
  orderItem: KlaviyoOrderItem,
  orderItemNr: number,
  orderEvent: KlaviyoOrderPlacedEvent
): EventCreateQueryV2 {
  return {
    data: {
      type: 'event',
      attributes: {
        uniqueId: `${orderEvent.uniqueId}_${orderItemNr}`,
        properties: {
          ...orderItem,
          ItemPrice: orderItem.ItemPrice,
          RowTotal: orderItem.RowTotal,
        },
        time: new Date(orderEvent.orderPlacedAt),
        value: orderItem.RowTotal,
        metric: {
          data: {
            type: 'metric',
            attributes: {
              name: 'Ordered Product',
            },
          },
        },
        profile: mapToProfile(orderEvent.profile),
      },
    },
  };
}
```

## File: packages/vendure-plugin-klaviyo/src/util/to-klaviyo-money.ts

```typescript
export function toKlaviyoMoney(vendureValue: number): number {
  return vendureValue / 100;
}
```

## File: packages/vendure-plugin-klaviyo/src/constants.ts

```typescript
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
export const loggerCtx = 'KlaviyoPlugin';
```

## File: packages/vendure-plugin-klaviyo/src/index.ts

```typescript
export * from './klaviyo.plugin';
export * from './event-handler/klaviyo-event-handler';
export * from './service/klaviyo.service';
export * from './event-handler/default-order-placed-event-handler';
export * from './event-handler/checkout-started-event-handler';
export * from './util/to-klaviyo-money';
export * from './service/checkout-started-event';
```

## File: packages/vendure-plugin-klaviyo/src/klaviyo.plugin.ts

```typescript
import {
  PluginCommonModule,
  RequestContext,
  VendurePlugin,
} from '@vendure/core';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { defaultOrderPlacedEventHandler } from './event-handler/default-order-placed-event-handler';
import {
  KlaviyoEventHandler,
  KlaviyoOrderPlacedEventHandler,
} from './event-handler/klaviyo-event-handler';
import { KlaviyoService } from './service/klaviyo.service';
import { KlaviyoShopResolver } from './api/klaviyo-shop-resolver';
import { shopApiExtensions } from './api/api-extensions';
import { startedCheckoutHandler } from './event-handler/checkout-started-event-handler';
interface KlaviyoPluginOptionsInput {
  apiKey: string | ((ctx: RequestContext) => string | undefined);
  eventHandlers?: Array<
    KlaviyoOrderPlacedEventHandler | KlaviyoEventHandler<any>
  >;
}
export type KlaviyoPluginOptions = Required<KlaviyoPluginOptionsInput>;
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => KlaviyoPlugin.options,
    },
    KlaviyoService,
  ],
  shopApiExtensions: {
    resolvers: [KlaviyoShopResolver],
    schema: shopApiExtensions,
  },
  compatibility: '>=2.2.0',
})
export class KlaviyoPlugin {
  static options: KlaviyoPluginOptions;
  static init(options: KlaviyoPluginOptionsInput): typeof KlaviyoPlugin {
    this.options = {
      ...options,
      eventHandlers: options.eventHandlers ?? [
        defaultOrderPlacedEventHandler,
        startedCheckoutHandler,
      ],
    };
    return KlaviyoPlugin;
  }
}
```

## File: packages/vendure-plugin-klaviyo/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { KlaviyoPlugin, defaultOrderPlacedEventHandler } from '../src';
import { mockCustomEventHandler } from './mock-custom-event-handler';
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      KlaviyoPlugin.init({
        apiKey: process.env.KLAVIYO_PRIVATE_API_KEY!,
        eventHandlers: [defaultOrderPlacedEventHandler, mockCustomEventHandler],
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-klaviyo/test/e2e.spec.ts

```typescript
import { DefaultLogger, EventBus, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import { EventCreateQueryV2 } from 'klaviyo-api';
import nock from 'nock';
import { afterAll, afterEach, beforeAll, describe, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { addItem, createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { defaultOrderPlacedEventHandler, KlaviyoPlugin } from '../src';
import { mockOrderPlacedHandler } from './mock-order-placed-handler';
import { mockCustomEventHandler } from './mock-custom-event-handler';
import { CheckoutStartedEvent, startedCheckoutHandler } from '../src/';
import gql from 'graphql-tag';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      KlaviyoPlugin.init({
        apiKey: 'some_private_api_key',
        eventHandlers: [
          defaultOrderPlacedEventHandler,
          startedCheckoutHandler,
          mockOrderPlacedHandler,
          mockCustomEventHandler,
        ],
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  await adminClient.asSuperAdmin();
}, 30000);
afterAll(async () => {
  await server.destroy();
}, 100000);
afterEach(() => nock.cleanAll());
describe('Klaviyo', () => {
  const klaviyoRequests: EventCreateQueryV2[] = [];
  it('Started the server', () => {
    expect(server.app.getHttpServer()).toBeDefined();
  });
  it('Places an order', async () => {
    nock('https://a.klaviyo.com/api/')
      .post('/events/', (reqBody) => {
        klaviyoRequests.push(reqBody);
        return true;
      })
      .reply(200, {})
      .persist();
    const order = await createSettledOrder(shopClient, 1);
    await new Promise((resolve) => setTimeout(resolve, 1000));
    expect(order.code).toBeDefined();
  });
  it("Has sent 'Placed Order Event' to Klaviyo", () => {
    const orderEvent = klaviyoRequests.find(
      (r) => r.data.attributes.metric.data.attributes.name === 'Placed Order'
    );
    const attributes = orderEvent?.data.attributes as any;
    expect(attributes.properties.OrderId).toBeDefined();
    expect(attributes.properties.ItemNames).toEqual([
      'Laptop 13 inch 8GB',
      'Laptop 15 inch 8GB',
    ]);
    const time = new Date(attributes.time!).getTime();
    expect(isNaN(time)).toBe(false);
    expect(attributes?.value).toBe(4921.4);
    expect(attributes?.unique_id).toBeDefined();
    const orderItem = (orderEvent?.data.attributes.properties as any).Items[0];
    expect(orderItem.ProductID).toBeDefined();
    expect(orderItem.SKU).toBe('L2201308');
    expect(orderItem.ProductName).toBe('Laptop 13 inch 8GB');
    expect(orderItem.Quantity).toBe(1);
    expect(orderItem.ItemPrice).toBe(1558.8);
    expect(orderItem.RowTotal).toBe(1558.8);
    const profile = orderEvent?.data.attributes.profile.data.attributes as any;
    expect(profile.email).toBe('hayden.zieme12@hotmail.com');
    expect(profile.external_id).toBe('1');
    expect(profile.first_name).toBe('Hayden');
    expect(profile.last_name).toBe('Zieme');
    expect(profile.location.address1).toBe('Verzetsstraat');
    expect(profile.location.address2).toBe('12a');
    expect(profile.location.city).toBe('Liwwa');
    expect(profile.location.country).toBe('NL');
  });
  it("Has sent 'Ordered Product' to Klaviyo", () => {
    const productEvent = klaviyoRequests.filter(
      (r) => r.data.attributes.metric.data.attributes.name === 'Ordered Product'
    );
    const orderItem1 = productEvent[0].data.attributes.properties as any;
    const orderItem2 = productEvent[1].data.attributes.properties as any;
    expect(orderItem1).toEqual({
      ProductID: '1',
      SKU: 'L2201308',
      ProductName: 'Laptop 13 inch 8GB',
      Quantity: 1,
      ItemPrice: 1558.8,
      RowTotal: 1558.8,
    });
    expect(orderItem2).toEqual({
      ProductID: '2',
      SKU: 'L2201508',
      ProductName: 'Laptop 15 inch 8GB',
      Quantity: 2,
      ItemPrice: 1678.8,
      RowTotal: 3357.6,
    });
  });
  it("Has sent 'Custom Order Placed' event to Klaviyo", () => {
    const orderEvents = klaviyoRequests.filter(
      (r) => r.data.attributes.metric.data.attributes.name === 'Placed Order'
    );
    const orderEvent = orderEvents[orderEvents.length - 1];
    const properties = orderEvent.data.attributes.properties as any;
    expect(properties.Categories).toEqual(['Some mock category']);
    expect(properties.Brands).toEqual(['Test Brand']);
    expect(properties.CustomProperties).toEqual({
      customOrderProp: 'my custom order value',
    });
    expect(properties.Items[0].customProperties).toEqual({
      customOrderItemProp: 'my custom order item value',
    });
    expect(properties.Items[0].ProductURL).toBe(
      'https://pinelab.studio/product/some-product'
    );
    expect(properties.Items[0].ImageURL).toBe('custom-image-url.png');
  });
  it("Has not sent 'Ordered Product' events for our custom Order Placed handler", () => {
    const orderedProductEvents = klaviyoRequests.filter(
      (r) =>
        r.data.attributes.metric.data.attributes.name === 'Ordered Product' &&
        r.data
    );
    expect(orderedProductEvents.length).toBe(2);
  });
  it("Has sent 'Custom Order Placed' event to Klaviyo", () => {
    const customEvent = klaviyoRequests.find(
      (r) =>
        r.data.attributes.metric.data.attributes.name === 'Custom Testing Event'
    );
    expect(
      (customEvent?.data.attributes.properties as any).customTestEventProp
    ).toEqual('some information');
  });
  it('Emits CheckoutStartedEvent on calling checkoutStarted() mutation', async () => {
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    await addItem(shopClient, 'T_1', 1);
    nock('https://a.klaviyo.com/api/')
      .post('/events/', (reqBody) => {
        klaviyoRequests.push(reqBody);
        return true;
      })
      .reply(200, {})
      .persist();
    const events: CheckoutStartedEvent[] = [];
    server.app
      .get(EventBus)
      .ofType(CheckoutStartedEvent)
      .subscribe((e) => events.push(e));
    await shopClient.query(
      gql`
        mutation {
          klaviyoCheckoutStarted
        }
      `
    );
    // Give worker some time to send event to klaviyo
    await new Promise((resolve) => setTimeout(resolve, 1000));
    const checkoutStartedEvent = klaviyoRequests.find(
      (r) =>
        r.data.attributes.metric.data.attributes.name === 'Checkout Started'
    );
    expect(events[0].order.id).toBeDefined();
    const profile = checkoutStartedEvent?.data.attributes.profile.data
      .attributes as any;
    expect(profile.email).toBe('hayden.zieme12@hotmail.com');
    expect(checkoutStartedEvent).toBeDefined();
  });
  it('Does not allow signup for unauthenticated calls', async () => {
    await shopClient.asAnonymousUser();
    const signUpPromise = shopClient.query(
      gql`
        mutation {
          subscribeToKlaviyoList(
            emailAddress: "testing@pinelab.studio"
            listId: "test-list-id"
          )
        }
      `
    );
    expect(signUpPromise).rejects.toThrow(
      'You are not currently authorized to perform this action'
    );
  });
  it('Sign up to list', async () => {
    // Create active order
    await shopClient.asAnonymousUser();
    await addItem(shopClient, 'T_1', 1);
    // Mock API response
    let signupRequest: any;
    nock('https://a.klaviyo.com/api/')
      .post('/profile-subscription-bulk-create-jobs/', (reqBody) => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        signupRequest = reqBody;
        return true;
      })
      .reply(200, {})
      .persist();
    await shopClient.query(
      gql`
        mutation {
          subscribeToKlaviyoList(
            emailAddress: "testing@pinelab.studio"
            listId: "test-list-id"
          )
        }
      `
    );
    expect(
      signupRequest.data.attributes.profiles.data[0].attributes.email
    ).toBe('testing@pinelab.studio');
    expect(signupRequest.data.relationships.list.data.id).toBe('test-list-id');
  });
});
```

## File: packages/vendure-plugin-klaviyo/test/mock-custom-event-handler.ts

```typescript
import { OrderPlacedEvent } from '@vendure/core';
import { KlaviyoEventHandler, KlaviyoGenericEvent } from '../src';
export const mockCustomEventHandler: KlaviyoEventHandler<OrderPlacedEvent> = {
  vendureEvent: OrderPlacedEvent,
  mapToKlaviyoEvent: async ({ order, ctx }, injector) => {
    if (!order.customer) {
      return false;
    }
    return <KlaviyoGenericEvent>{
      eventName: 'Custom Testing Event',
      uniqueId: order.code,
      profile: {
        emailAddress: order.customer.emailAddress,
        externalId: order.customer.id.toString(),
        firstName: order.customer.firstName,
        lastName: order.customer.lastName,
        phoneNumber: order.customer.phoneNumber,
        address: {},
      },
      customProperties: {
        customTestEventProp: 'some information',
      },
    };
  },
};
```

## File: packages/vendure-plugin-klaviyo/test/mock-order-placed-handler.ts

```typescript
import { EntityHydrator, OrderPlacedEvent, translateDeep } from '@vendure/core';
import {
  KlaviyoEventHandler,
  KlaviyoOrderItem,
  KlaviyoOrderPlacedEvent,
  toKlaviyoMoney,
} from '../src';
export const mockOrderPlacedHandler: KlaviyoEventHandler<OrderPlacedEvent> = {
  vendureEvent: OrderPlacedEvent,
  mapToKlaviyoEvent: async ({ order, ctx }, injector) => {
    await injector.get(EntityHydrator).hydrate(ctx, order, {
      relations: [
        'lines.productVariant.product.facetValues.facet',
        'lines.productVariant.product.translations',
        'lines.productVariant.collections.children',
        'lines.productVariant.featuredAsset',
        'shippingLines.shippingMethod',
        'customer.addresses.country',
        'customer.user',
      ],
    });
    order.lines.forEach((line) => {
      line.productVariant.product = translateDeep(
        line.productVariant.product,
        ctx.languageCode
      );
    });
    if (!order.customer) {
      return false;
    }
    return <KlaviyoOrderPlacedEvent>{
      eventName: 'Order Placed',
      uniqueId: order.code,
      orderId: order.code,
      orderPlacedAt: order.orderPlacedAt ?? order.updatedAt,
      totalOrderValue: toKlaviyoMoney(order.totalWithTax),
      profile: {
        emailAddress: order.customer.emailAddress,
        externalId: order.customer.id.toString(),
        firstName: order.customer.firstName,
        lastName: order.customer.lastName,
        phoneNumber: order.customer.phoneNumber,
        address: {},
      },
      orderItems: <KlaviyoOrderItem[]>order.lines.map((line, index) => ({
        Brand: 'Test Brand',
        ProductURL: 'https://pinelab.studio/product/some-product',
        Categories: ['Some mock category'],
        customProperties: {
          customOrderItemProp: 'my custom order item value',
        },
        ProductID: line.productVariant.id.toString(),
        SKU: line.productVariant.sku,
        ProductName: line.productVariant.name,
        Quantity: line.quantity,
        ItemPrice: toKlaviyoMoney(line.proratedUnitPriceWithTax),
        RowTotal: toKlaviyoMoney(line.proratedLinePriceWithTax),
        ImageURL: 'custom-image-url.png',
        excludeFromOrderedProductEvent: true,
      })),
      customProperties: {
        customOrderProp: 'my custom order value',
      },
    };
  },
};
```

## File: packages/vendure-plugin-limited-products/src/api/add-item-override.resolver.ts

```typescript
import { ModuleRef } from '@nestjs/core';
import { Args, Mutation, Resolver } from '@nestjs/graphql';
import {
  MutationAddItemToOrderArgs,
  MutationAdjustOrderLineArgs,
  UpdateOrderItemsResult,
} from '@vendure/common/lib/generated-shop-types';
import {
  Allow,
  Ctx,
  EntityHydrator,
  Injector,
  OrderLine,
  Permission,
  RelationPaths,
  Relations,
  RequestContext,
  Transaction,
  UserInputError,
} from '@vendure/core';
import { ShopOrderResolver } from '@vendure/core/dist/api/resolvers/shop/shop-order.resolver';
import { ErrorResultUnion } from '@vendure/core/dist/common/error/error-result';
import { Order } from '@vendure/core/dist/entity/order/order.entity';
import { getChannelAwareValue } from '../util';
@Resolver()
export class AddItemOverrideResolver {
  private injector: Injector;
  constructor(
    private readonly entityHydrator: EntityHydrator,
    moduleRef: ModuleRef
  ) {
    this.injector = new Injector(moduleRef);
  }
  @Transaction()
  @Mutation()
  @Allow(Permission.UpdateOrder, Permission.Owner)
  async addItemToOrder(
    @Ctx() ctx: RequestContext,
    @Args() args: MutationAddItemToOrderArgs,
    @Relations({ entity: Order, omit: ['aggregateOrder', 'sellerOrders'] })
    relations: RelationPaths<Order>
  ): Promise<ErrorResultUnion<UpdateOrderItemsResult, Order>> {
    const result = await this.injector
      .get(ShopOrderResolver)
      .addItemToOrder(ctx, args, relations);
    if (!(result as Order).code) {
      return result;
    }
    const order = result as Order;
    const orderLine = order.lines.find(
      (line) => line.productVariant.id == args.productVariantId
    );
    if (orderLine) {
      await this.validate(ctx, orderLine);
    }
    return result;
  }
  @Transaction()
  @Mutation()
  @Allow(Permission.UpdateOrder, Permission.Owner)
  async adjustOrderLine(
    @Ctx() ctx: RequestContext,
    @Args() args: MutationAdjustOrderLineArgs,
    @Relations({ entity: Order, omit: ['aggregateOrder', 'sellerOrders'] })
    relations: RelationPaths<Order>
  ): Promise<ErrorResultUnion<UpdateOrderItemsResult, Order>> {
    const result = await this.injector
      .get(ShopOrderResolver)
      .adjustOrderLine(ctx, args, relations);
    if (!(result as Order).code) {
      return result;
    }
    const order = result as Order;
    const orderLine = order.lines.find((line) => line.id == args.orderLineId);
    if (orderLine) {
      await this.validate(ctx, orderLine);
    }
    return result;
  }
  private async validate(
    ctx: RequestContext,
    orderLine: OrderLine
  ): Promise<void> {
    await this.entityHydrator.hydrate(ctx, orderLine, {
      relations: ['productVariant'],
    });
    await this.entityHydrator.hydrate(ctx, orderLine.productVariant, {
      relations: ['product'],
    });
    const maxPerOrder = getChannelAwareValue(
      ctx,
      orderLine.productVariant.product.customFields.maxPerOrder
    );
    const onlyAllowPer = getChannelAwareValue(
      ctx,
      orderLine.productVariant.product.customFields.onlyAllowPer
    );
    if (maxPerOrder && orderLine.quantity > maxPerOrder) {
      throw new UserInputError(
        `You are only allowed to order max ${maxPerOrder} of item '${orderLine.productVariant.name}'`
      );
    }
    if (onlyAllowPer && orderLine.quantity % onlyAllowPer !== 0) {
      throw new UserInputError(
        `You are only allowed to order a multiple of ${onlyAllowPer} item '${orderLine.productVariant.name}'`
      );
    }
  }
}
```

## File: packages/vendure-plugin-limited-products/src/api/api-extensions.ts

```typescript
import gql from 'graphql-tag';
export const shopSchemaExtensions = gql`
  extend type Product {
    maxQuantityPerOrder: Int
    limitPurchasePerMultipleOf: Int
  }
`;
```

## File: packages/vendure-plugin-limited-products/src/api/limit-fields.resolver.ts

```typescript
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { Ctx, Product, RequestContext } from '@vendure/core';
import { getChannelAwareValue } from '../util';
@Resolver()
export class LimitFieldsResolver {
  @ResolveField('maxQuantityPerOrder')
  @Resolver('Product')
  maxQuantityPerOrder(
    @Ctx() ctx: RequestContext,
    @Parent() product: Product
  ): number | undefined {
    return (
      getChannelAwareValue(ctx, product.customFields.maxPerOrder) || undefined
    );
  }
  @ResolveField('limitPurchasePerMultipleOf')
  @Resolver('Product')
  limitPurchasePerMultipleOf(
    @Ctx() ctx: RequestContext,
    @Parent() product: Product
  ): number | undefined {
    return (
      getChannelAwareValue(ctx, product.customFields.onlyAllowPer) || undefined
    );
  }
}
```

## File: packages/vendure-plugin-limited-products/src/ui/channel-aware-int-custom-field/channel-aware-int-custom-field.component.ts

```typescript
import { Component, OnInit, ChangeDetectorRef } from '@angular/core';
import { FormControl } from '@angular/forms';
import {
  IntCustomFieldConfig,
  SharedModule,
  FormInputComponent,
  Channel,
  DataService,
} from '@vendure/admin-ui/core';
import { Observable } from 'rxjs';
import { GET_ACTIVE_CHANNEL } from './channel-aware-int-custom-field.graphql';
import { ID } from '@vendure/common/lib/shared-types';
import { ActivatedRoute } from '@angular/router';
type ChannelAwareIntValue = {
  channelId: ID;
  value: number;
};
@Component({
  template: `
    <input type="number" min="0" step="1" [formControl]="valueFormControl" />
  `,
  standalone: true,
  imports: [SharedModule],
})
export class ChannelAwareIntCustomFieldComponent
  implements FormInputComponent<IntCustomFieldConfig>, OnInit
{
  isListInput?: boolean | undefined = true;
  readonly!: boolean;
  activeChannel$!: Observable<{
    activeChannel: Pick<Channel, 'id' | 'defaultCurrencyCode'>;
  }>;
  config!: IntCustomFieldConfig;
  formControl!: FormControl<string[]>;
  values!: ChannelAwareIntValue[];
  valueFormControl!: FormControl<number | null>;
  activeChannelId!: ID;
  constructor(
    private dataService: DataService,
    private cdr: ChangeDetectorRef,
    private route: ActivatedRoute
  ) {}
  ngOnInit(): void {
    this.route.params.subscribe(() => {
      setTimeout(() => this.parseFormControlValue(), 10);
    });
  }
  parseFormControlValue() {
    if (this.formControl.value?.length) {
      this.values = this.formControl.value.map(
        (v) => JSON.parse(v) as ChannelAwareIntValue
      );
    } else {
      this.values = [];
    }
    this.activeChannel$ = this.dataService.query<{
      activeChannel: Pick<Channel, 'id' | 'defaultCurrencyCode'>;
    }>(GET_ACTIVE_CHANNEL).stream$;
    this.activeChannel$.subscribe((data) => {
      this.activeChannelId = data.activeChannel.id;
      const channelValue = this.values.find((v) =>
        this.idsAreEqual(v.channelId, this.activeChannelId)
      )?.value;
      this.valueFormControl = new FormControl<number | null>(channelValue ?? 0);
      this.valueFormControl.valueChanges.subscribe((value) => {
        if (!value) {
          this.values = this.values.filter(
            (v) => !this.idsAreEqual(v.channelId, this.activeChannelId)
          );
          return;
        }
        const channelData = this.values.find((v) =>
          this.idsAreEqual(v.channelId, this.activeChannelId)
        );
        if (channelData) {
          channelData.value = value;
        } else {
          this.values.push({ channelId: this.activeChannelId, value });
        }
        this.formControl.setValue(this.values.map((v) => JSON.stringify(v)));
        this.formControl.markAsDirty();
      });
      this.cdr.detectChanges();
    });
  }
  idsAreEqual(id1?: ID, id2?: ID): boolean {
    if (id1 === undefined || id2 === undefined || !id2 || !id1) {
      return false;
    }
    return id1.toString() === id2.toString();
  }
}
```

## File: packages/vendure-plugin-limited-products/src/ui/channel-aware-int-custom-field/channel-aware-int-custom-field.graphql.ts

```typescript
import { gql } from 'graphql-tag';
export const GET_ACTIVE_CHANNEL = gql`
  query GetActiveChannel {
    activeChannel {
      id
    }
  }
`;
```

## File: packages/vendure-plugin-limited-products/src/ui/providers.ts

```typescript
import { registerFormInputComponent } from '@vendure/admin-ui/core';
import { ChannelAwareIntCustomFieldComponent } from './channel-aware-int-custom-field/channel-aware-int-custom-field.component';
export default [
  registerFormInputComponent(
    'channel-aware-int-form-input',
    ChannelAwareIntCustomFieldComponent
  ),
];
```

## File: packages/vendure-plugin-limited-products/src/index.ts

```typescript
export * from './limited-products.plugin';
```

## File: packages/vendure-plugin-limited-products/src/limited-products.plugin.ts

```typescript
import { LanguageCode, PluginCommonModule, VendurePlugin } from '@vendure/core';
import { AddItemOverrideResolver } from './api/add-item-override.resolver';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { shopSchemaExtensions } from './api/api-extensions';
import { LimitFieldsResolver } from './api/limit-fields.resolver';
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [],
  shopApiExtensions: {
    schema: shopSchemaExtensions,
    resolvers: [AddItemOverrideResolver, LimitFieldsResolver],
  },
  configuration: (config) => {
    config.customFields.Product.push({
      name: 'maxPerOrder',
      type: 'text',
      list: true,
      public: false,
      nullable: true,
      ui: { component: 'channel-aware-int-form-input', tab: 'Limitations' },
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'Maximum amount per order',
        },
      ],
      description: [
        {
          languageCode: LanguageCode.en,
          value:
            'Limit how many of this product can be bought in a single order. Empty or 0 means a customer can order as many as he wants',
        },
      ],
    });
    config.customFields.Product.push({
      name: 'onlyAllowPer',
      type: 'text',
      public: false,
      list: true,
      ui: { component: 'channel-aware-int-form-input', tab: 'Limitations' },
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'Multiple of per order',
        },
      ],
      description: [
        {
          languageCode: LanguageCode.en,
          value:
            'The customer will only be allowed to add a multiple of "onlyAllowPer" of this product per order. Empty or 0 means a customer can order as many as he wants',
        },
      ],
    });
    return config;
  },
  compatibility: '>=2.2.0',
})
export class LimitedProductsPlugin {
  public static uiExtensions: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    providers: ['providers.ts'],
  };
}
```

## File: packages/vendure-plugin-limited-products/src/types.ts

```typescript
import { ID } from '@vendure/core';
import { CustomProductFields } from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core' {
  interface CustomProductFields {
    maxPerOrder?: string[];
    onlyAllowPer?: string[];
  }
}
export type ChannelAwareIntValue = {
  channelId: ID;
  value: number;
};
```

## File: packages/vendure-plugin-limited-products/src/util.ts

```typescript
import { RequestContext, idsAreEqual } from '@vendure/core';
import { ChannelAwareIntValue } from './types';
export function getChannelAwareValue(
  ctx: RequestContext,
  value: string[] = []
): number {
  return (
    (value ?? [])
      .map((v) => JSON.parse(v) as ChannelAwareIntValue)
      .find((channelValue) =>
        idsAreEqual(channelValue.channelId, ctx.channelId)
      )?.value ?? 0
  );
}
```

## File: packages/vendure-plugin-limited-products/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  AutoIncrementIdStrategy,
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import gql from 'graphql-tag';
import path from 'path';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { LimitedProductsPlugin } from '../src';
import '../src/types';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      LimitedProductsPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, './__admin-ui'),
          extensions: [LimitedProductsPlugin.uiExtensions],
          devMode: true,
        }),
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    entityOptions: {
      entityIdStrategy: new AutoIncrementIdStrategy(),
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
  const { updateProduct } = await adminClient.query(
    gql`
      mutation updateProduct($onlyAllowPer: [String!]) {
        updateProduct(
          input: { id: "1", customFields: { onlyAllowPer: $onlyAllowPer } }
        ) {
          ... on Product {
            customFields {
              maxPerOrder
              onlyAllowPer
            }
          }
        }
      }
    `,
    {
      onlyAllowPer: [JSON.stringify({ channelId: '1', value: 2 })],
    }
  );
})();
```

## File: packages/vendure-plugin-limited-products/test/e2e.spec.ts

```typescript
import {
  AutoIncrementIdStrategy,
  DefaultLogger,
  idsAreEqual,
  LogLevel,
  mergeConfig,
  Order,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { initialData } from '../../test/src/initial-data';
import gql from 'graphql-tag';
import { LimitedProductsPlugin } from '../src/limited-products.plugin';
import { addItem } from '../../test/src/shop-utils';
import { expect, describe, beforeAll, afterAll, it } from 'vitest';
import { ChannelAwareIntValue } from '../src/types';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
describe('Limit variants per order plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3106,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [LimitedProductsPlugin],
      entityOptions: {
        entityIdStrategy: new AutoIncrementIdStrategy(),
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
  }, 60000);
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Sets maxPerOrder to 6, and onlyAllowPer to 2', async () => {
    await adminClient.asSuperAdmin();
    const { updateProduct: product } = await adminClient.query(
      gql`
        mutation updateProduct(
          $maxPerOrder: [String!]
          $onlyAllowPer: [String!]
        ) {
          updateProduct(
            input: {
              id: "1"
              customFields: {
                maxPerOrder: $maxPerOrder
                onlyAllowPer: $onlyAllowPer
              }
            }
          ) {
            ... on Product {
              customFields {
                maxPerOrder
                onlyAllowPer
              }
            }
          }
        }
      `,
      {
        maxPerOrder: [JSON.stringify({ value: 6, channelId: '1' })],
        onlyAllowPer: [JSON.stringify({ value: 2, channelId: '1' })],
      }
    );
    expect(product.customFields.maxPerOrder).toEqual([
      JSON.stringify({ value: 6, channelId: '1' }),
    ]);
    expect(product.customFields.onlyAllowPer).toEqual([
      JSON.stringify({ value: 2, channelId: '1' }),
    ]);
  });
  it('Exposes the limits via the shop api', async () => {
    const { product } = await shopClient.query(gql`
      {
        product(id: 1) {
          maxQuantityPerOrder
          limitPurchasePerMultipleOf
        }
      }
    `);
    expect(product.maxQuantityPerOrder).toBe(6);
    expect(product.limitPurchasePerMultipleOf).toBe(2);
  });
  it('Can add 2 to cart', async () => {
    const order = await addItem(shopClient, '1', 2);
    expect(order.lines[0].quantity).toBe(2);
  });
  it("Can't add 1 more to cart, because only multiples of 2 are allowed", async () => {
    await expect(addItem(shopClient, '1', 1)).rejects.toThrow(
      "You are only allowed to order a multiple of 2 item 'Laptop 13 inch 8GB'"
    );
  });
  it('Can add 2 more to cart, because the total will be a multiple of 2', async () => {
    const order = await addItem(shopClient, '1', 2);
    expect(order.lines[0].quantity).toBe(4);
  });
  it("Can't adjust order line to 3, because only multiples of 2 are allowed", async () => {
    const promise = shopClient.query(
      gql`
        mutation adjustOrderLine($quantity: Int!) {
          adjustOrderLine(orderLineId: 1, quantity: $quantity) {
            ... on Order {
              lines {
                quantity
              }
            }
          }
        }
      `,
      { quantity: 3 }
    );
    await expect(promise).rejects.toThrow(
      "You are only allowed to order a multiple of 2 item 'Laptop 13 inch 8GB'"
    );
  });
  it('Can adjust order line to 2', async () => {
    const { adjustOrderLine: order } = await shopClient.query(
      gql`
        mutation adjustOrderLine($quantity: Int!) {
          adjustOrderLine(orderLineId: 1, quantity: $quantity) {
            ... on Order {
              lines {
                quantity
              }
            }
          }
        }
      `,
      { quantity: 2 }
    );
    expect(order.lines[0].quantity).toBe(2);
  });
  it('Fails to  adjust order line to 7, because that is greater than maxQuantityPerOrder', async () => {
    const promise = shopClient.query(
      gql`
        mutation adjustOrderLine($quantity: Int!) {
          adjustOrderLine(orderLineId: 1, quantity: $quantity) {
            ... on Order {
              lines {
                quantity
              }
            }
          }
        }
      `,
      { quantity: 7 }
    );
    await expect(promise).rejects.toThrow(
      "You are only allowed to order max 6 of item 'Laptop 13 inch 8GB'"
    );
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        LimitedProductsPlugin.uiExtensions
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(() => {
    return server.destroy();
  });
});
```

## File: packages/vendure-plugin-metrics/src/api/metrics/average-order-value.ts

```typescript
import {
  Injector,
  Logger,
  Order,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { loggerCtx } from '../../constants';
import { AdvancedMetricType } from '../../ui/generated/graphql';
import { MetricStrategy, NamedDatapoint } from '../metric-strategy';
export class AverageOrderValueMetric implements MetricStrategy<Order> {
  readonly metricType: AdvancedMetricType = AdvancedMetricType.Currency;
  readonly code = 'aov';
  readonly allowProductSelection = false;
  getTitle(ctx: RequestContext): string {
    return `Average order value`;
  }
  getSortableField(entity: Order): Date {
    return entity.orderPlacedAt ?? entity.updatedAt;
  }
  async loadEntities(
    ctx: RequestContext,
    injector: Injector,
    from: Date,
    to: Date
  ): Promise<Order[]> {
    let skip = 0;
    const take = 5000;
    let hasMoreOrders = true;
    const orders: Order[] = [];
    while (hasMoreOrders) {
      let query = injector
        .get(TransactionalConnection)
        .getRepository(ctx, Order)
        .createQueryBuilder('order')
        .leftJoin('order.channels', 'orderChannel')
        .where(`orderChannel.id=:channelId`, { channelId: ctx.channelId })
        .andWhere('order.orderPlacedAt BETWEEN :fromDate AND :toDate', {
          fromDate: from.toISOString(),
          toDate: to.toISOString(),
        })
        .offset(skip)
        .limit(take);
      const [items, totalOrders] = await query.getManyAndCount();
      orders.push(...items);
      Logger.debug(
        `Fetched orders ${skip}-${skip + take} for metric ${
          this.code
        } for channel${ctx.channel.token}`,
        loggerCtx
      );
      skip += items.length;
      if (orders.length >= totalOrders) {
        hasMoreOrders = false;
      }
    }
    return orders;
  }
  calculateDataPoints(
    ctx: RequestContext,
    entities: Order[]
  ): NamedDatapoint[] {
    let legendLabel = 'Average order value';
    if (ctx.channel.pricesIncludeTax) {
      legendLabel += ' (incl. tax)';
    } else {
      legendLabel += ' (excl. tax)';
    }
    if (!entities.length) {
      return [
        {
          legendLabel,
          value: 0,
        },
      ];
    }
    const totalFieldName = ctx.channel.pricesIncludeTax
      ? 'totalWithTax'
      : 'total';
    const total = entities
      .map((o) => o[totalFieldName])
      .reduce((total, current) => total + current, 0);
    const average = Math.round(total / entities.length) / 100;
    return [
      {
        legendLabel,
        value: average,
      },
    ];
  }
}
```

## File: packages/vendure-plugin-metrics/src/api/metrics/revenue-per-product.ts

```typescript
import {
  Injector,
  Logger,
  OrderLine,
  ProductVariant,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { AdvancedMetricType } from '../../ui/generated/graphql';
import { MetricStrategy, NamedDatapoint } from '../metric-strategy';
import { loggerCtx } from '../../constants';
export class RevenuePerProduct implements MetricStrategy<OrderLine> {
  readonly metricType: AdvancedMetricType = AdvancedMetricType.Currency;
  readonly code = 'revenue-per-product';
  readonly allowProductSelection = true;
  getTitle(ctx: RequestContext): string {
    return `Revenue`;
  }
  getSortableField(entity: OrderLine): Date {
    return entity.order.orderPlacedAt ?? entity.order.updatedAt;
  }
  async loadEntities(
    ctx: RequestContext,
    injector: Injector,
    from: Date,
    to: Date,
    variants: ProductVariant[]
  ): Promise<OrderLine[]> {
    let skip = 0;
    const take = 1000;
    let hasMoreOrderLines = true;
    const lines: OrderLine[] = [];
    while (hasMoreOrderLines) {
      let query = injector
        .get(TransactionalConnection)
        .getRepository(ctx, OrderLine)
        .createQueryBuilder('orderLine')
        .leftJoinAndSelect('orderLine.order', 'order')
        .leftJoin('order.channels', 'channel')
        .where(`channel.id=:channelId`, { channelId: ctx.channelId })
        .andWhere('order.orderPlacedAt BETWEEN :fromDate AND :toDate', {
          fromDate: from.toISOString(),
          toDate: to.toISOString(),
        })
        .offset(skip)
        .limit(take);
      if (variants.length) {
        query = query
          .leftJoin('orderLine.productVariant', 'productVariant')
          .addSelect(['productVariant.sku', 'productVariant.id'])
          .andWhere(`productVariant.id IN(:...variantIds)`, {
            variantIds: variants.map((v) => v.id),
          });
      }
      const [items, totalItems] = await query.getManyAndCount();
      lines.push(...items);
      Logger.debug(
        `Fetched order lines ${skip}-${skip + take} for metric ${
          this.code
        } for channel${ctx.channel.token}`,
        loggerCtx
      );
      skip += items.length;
      if (lines.length >= totalItems) {
        hasMoreOrderLines = false;
      }
    }
    return lines;
  }
  calculateDataPoints(
    ctx: RequestContext,
    lines: OrderLine[],
    variants: ProductVariant[]
  ): NamedDatapoint[] {
    if (!variants.length) {
      let legendLabel = 'Total Revenue';
      if (ctx.channel.pricesIncludeTax) {
        legendLabel += ' (incl. tax)';
      } else {
        legendLabel += ' (excl. tax)';
      }
      const revenuePerOrder: { [orderId: string]: number } = {};
      const totalFieldName = ctx.channel.pricesIncludeTax
        ? 'totalWithTax'
        : 'total';
      lines.forEach((line) => {
        revenuePerOrder[line.order.id] = line.order[totalFieldName];
      });
      const totalRevenue = Object.values(revenuePerOrder).reduce(
        (total, current) => total + current,
        0
      );
      return [
        {
          legendLabel,
          value: totalRevenue / 100,
        },
      ];
    }
    const dataPoints: NamedDatapoint[] = [];
    const totalFieldName = ctx.channel.pricesIncludeTax
      ? 'proratedLinePriceWithTax'
      : 'proratedLinePrice';
    variants.forEach((variant) => {
      const linesForVariant = lines.filter(
        (line) => line.productVariant.id === variant.id
      );
      const revenue = linesForVariant.reduce(
        (total, current) => total + current[totalFieldName],
        0
      );
      dataPoints.push({
        legendLabel: variant.name,
        value: revenue / 100,
      });
    });
    return dataPoints;
  }
}
```

## File: packages/vendure-plugin-metrics/src/api/metrics/units-sold-metric.ts

```typescript
import {
  Injector,
  Logger,
  OrderLine,
  ProductVariant,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { AdvancedMetricType } from '../../ui/generated/graphql';
import { MetricStrategy, NamedDatapoint } from '../metric-strategy';
import { loggerCtx } from '../../constants';
export class UnitsSoldMetric implements MetricStrategy<OrderLine> {
  readonly metricType: AdvancedMetricType = AdvancedMetricType.Number;
  readonly code = 'units-sold';
  readonly allowProductSelection = true;
  getTitle(ctx: RequestContext): string {
    return `Units sold`;
  }
  getSortableField(entity: OrderLine): Date {
    return entity.order.orderPlacedAt ?? entity.order.updatedAt;
  }
  async loadEntities(
    ctx: RequestContext,
    injector: Injector,
    from: Date,
    to: Date,
    variants: ProductVariant[]
  ): Promise<OrderLine[]> {
    let skip = 0;
    const take = 1000;
    let hasMoreOrderLines = true;
    const lines: OrderLine[] = [];
    while (hasMoreOrderLines) {
      let query = injector
        .get(TransactionalConnection)
        .getRepository(ctx, OrderLine)
        .createQueryBuilder('orderLine')
        .leftJoin('orderLine.order', 'order')
        .select([
          'order.id',
          'order.orderPlacedAt',
          'orderLine.id',
          'orderLine.quantity',
        ])
        .leftJoin('order.channels', 'channel')
        .where(`channel.id=:channelId`, { channelId: ctx.channelId })
        .andWhere('order.orderPlacedAt BETWEEN :fromDate AND :toDate', {
          fromDate: from.toISOString(),
          toDate: to.toISOString(),
        })
        .skip(skip)
        .take(take);
      if (variants.length) {
        query = query
          .leftJoin('orderLine.productVariant', 'productVariant')
          .addSelect(['productVariant.sku', 'productVariant.id'])
          .andWhere(`productVariant.id IN(:...variantIds)`, {
            variantIds: variants.map((v) => v.id),
          });
      }
      const [items, totalItems] = await query.getManyAndCount();
      lines.push(...items);
      Logger.debug(
        `Fetched order lines ${skip}-${skip + take} for metric ${
          this.code
        } for channel${ctx.channel.token}`,
        loggerCtx
      );
      skip += items.length;
      if (lines.length >= totalItems) {
        hasMoreOrderLines = false;
      }
    }
    return lines;
  }
  calculateDataPoints(
    ctx: RequestContext,
    lines: OrderLine[],
    variants: ProductVariant[]
  ): NamedDatapoint[] {
    if (!variants.length) {
      const total = lines
        .map((line) => line.quantity)
        .reduce((total, current) => total + current, 0);
      return [
        {
          legendLabel: 'Total of all variants',
          value: total,
        },
      ];
    }
    const dataPoints: NamedDatapoint[] = [];
    variants.forEach((variant) => {
      const linesForVariant = lines.filter(
        (line) => line.productVariant.id === variant.id
      );
      const sum = linesForVariant.reduce(
        (total, current) => total + current.quantity,
        0
      );
      dataPoints.push({
        legendLabel: variant.name,
        value: sum,
      });
    });
    return dataPoints;
  }
}
```

## File: packages/vendure-plugin-metrics/src/api/cache.ts

```typescript
interface EntryDate {
  createdAt: Date;
}
export class Cache<T> {
  constructor(private maxAgeInSeconds: number = 60 * 60 * 12) {}
  private cache = new Map<string, T & EntryDate>();
  set(key: string, value: T): void {
    this.cache.set(key, {
      ...value,
      createdAt: new Date(),
    });
  }
  get(key: string): T | undefined {
    const res = this.cache.get(key);
    if (!res) {
      return undefined;
    }
    const now = new Date();
    if (now.getTime() - res.createdAt.getTime() > this.maxAgeInSeconds * 1000) {
      this.cache.delete(key);
      return undefined;
    }
    return res;
  }
}
```

## File: packages/vendure-plugin-metrics/src/api/metric-strategy.ts

```typescript
import {
  AdvancedMetricSummaryInput,
  AdvancedMetricType,
} from '../ui/generated/graphql';
import { RequestContext, Injector, ProductVariant } from '@vendure/core';
export interface NamedDatapoint {
  legendLabel: string;
  value: number;
}
export interface MetricStrategy<T> {
  code: string;
  metricType: AdvancedMetricType;
  allowProductSelection: boolean;
  getTitle(ctx: RequestContext): string;
  getSortableField?(entity: T): Date;
  loadEntities(
    ctx: RequestContext,
    injector: Injector,
    from: Date,
    to: Date,
    variants: ProductVariant[]
  ): Promise<T[]>;
  calculateDataPoints(
    ctx: RequestContext,
    entities: T[],
    variants: ProductVariant[]
  ): NamedDatapoint[];
}
```

## File: packages/vendure-plugin-metrics/src/api/metrics.resolver.ts

```typescript
import { Args, Query, Resolver } from '@nestjs/graphql';
import { Allow, Ctx, Permission, RequestContext } from '@vendure/core';
import {
  AdvancedMetricSummary,
  AdvancedMetricSummaryInput,
  AdvancedMetricType,
} from '../ui/generated/graphql';
import { MetricsService } from './metrics.service';
@Resolver()
export class MetricsResolver {
  constructor(private readonly metricsService: MetricsService) {}
  @Query()
  @Allow(Permission.ReadOrder)
  async advancedMetricSummaries(
    @Ctx() ctx: RequestContext,
    @Args('input') input: AdvancedMetricSummaryInput
  ): Promise<AdvancedMetricSummary[]> {
    return this.metricsService.getMetrics(ctx, input);
  }
}
```

## File: packages/vendure-plugin-metrics/src/api/metrics.service.ts

```typescript
import { Injectable, Inject } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  Injector,
  Logger,
  ProductVariantService,
  RequestContext,
} from '@vendure/core';
import { addMonths, endOfDay, isBefore, startOfMonth, sub } from 'date-fns';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { MetricsPluginOptions } from '../metrics.plugin';
import {
  AdvancedMetricSeries,
  AdvancedMetricSummary,
  AdvancedMetricSummaryInput,
} from '../ui/generated/graphql';
import { Cache } from './cache';
import { MetricStrategy } from './metric-strategy';
type DataPointsPerLegend = Map<string, number[]>;
interface EntitiesPerMonth<T> {
  monthNr: number;
  year: number;
  entities: T[];
}
@Injectable()
export class MetricsService {
  cache = new Cache<AdvancedMetricSummary>();
  metricStrategies: MetricStrategy<unknown>[];
  constructor(
    private moduleRef: ModuleRef,
    private variantService: ProductVariantService,
    @Inject(PLUGIN_INIT_OPTIONS) private pluginOptions: MetricsPluginOptions
  ) {
    this.metricStrategies = this.pluginOptions.metrics;
  }
  async getMetrics(
    ctx: RequestContext,
    input?: AdvancedMetricSummaryInput
  ): Promise<AdvancedMetricSummary[]> {
    const variants = await this.variantService.findByIds(
      ctx,
      input?.variantIds ?? []
    );
    const today = endOfDay(new Date());
    const startDate = startOfMonth(
      sub(today, { months: this.pluginOptions.displayPastMonths })
    );
    return Promise.all(
      this.metricStrategies.map(async (metricStrategy) => {
        const cacheKeyObject = {
          code: metricStrategy.code,
          from: startDate.toDateString(),
          to: today.toDateString(),
          channel: ctx.channel.token,
          variantIds: [] as string[],
        };
        if (metricStrategy.allowProductSelection) {
          cacheKeyObject.variantIds = input?.variantIds?.sort() ?? [];
        }
        const cacheKey = JSON.stringify(cacheKeyObject);
        const cachedMetricSummary = this.cache.get(cacheKey);
        if (cachedMetricSummary) {
          Logger.info(
            `Using cached data for metric "${metricStrategy.code}"`,
            loggerCtx
          );
          return cachedMetricSummary;
        }
        const start = performance.now();
        const allEntities = await metricStrategy.loadEntities(
          ctx,
          new Injector(this.moduleRef),
          startDate,
          today,
          variants
        );
        const entitiesPerMonth = this.splitEntitiesInMonths(
          metricStrategy,
          allEntities,
          startDate,
          today
        );
        const dataPointsPerName: DataPointsPerLegend = new Map<
          string,
          number[]
        >();
        entitiesPerMonth.forEach((entityMap) => {
          const calculatedDataPoints = metricStrategy.calculateDataPoints(
            ctx,
            entityMap.entities,
            variants
          );
          calculatedDataPoints.forEach((dataPoint) => {
            const entry = dataPointsPerName.get(dataPoint.legendLabel) ?? [];
            entry.push(dataPoint.value);
            dataPointsPerName.set(dataPoint.legendLabel, entry);
          });
        });
        const monthNames = entitiesPerMonth.map((d) =>
          this.getMonthName(d.monthNr)
        );
        const summary: AdvancedMetricSummary = {
          code: metricStrategy.code,
          title: metricStrategy.getTitle(ctx),
          allowProductSelection: metricStrategy.allowProductSelection,
          labels: monthNames,
          series: this.mapToSeries(dataPointsPerName),
          type: metricStrategy.metricType,
        };
        const stop = performance.now();
        Logger.info(
          `No cache hit, loaded data for metric "${
            metricStrategy.code
          }" in ${Math.round(stop - start)}ms`,
          loggerCtx
        );
        this.cache.set(cacheKey, summary);
        return summary;
      })
    );
  }
  mapToSeries(dataPointsPerMonth: DataPointsPerLegend): AdvancedMetricSeries[] {
    const series: AdvancedMetricSeries[] = [];
    dataPointsPerMonth.forEach((dataPoints, name) => {
      series.push({
        name,
        values: dataPoints,
      });
    });
    return series;
  }
  splitEntitiesInMonths<T>(
    strategy: MetricStrategy<T>,
    entities: T[],
    from: Date,
    to: Date
  ): EntitiesPerMonth<T>[] {
    const getYearMonth = (date: Date) =>
      `${date.getFullYear()}-${date.getMonth()}`;
    const entitiesPerMonth = new Map<string, EntitiesPerMonth<T>>();
    for (let i = from; isBefore(i, to); i = addMonths(i, 1)) {
      const yearMonth = getYearMonth(i);
      entitiesPerMonth.set(yearMonth, {
        monthNr: i.getMonth(),
        year: i.getFullYear(),
        entities: [],
      });
    }
    entities.forEach((entity) => {
      const date =
        strategy.getSortableField?.(entity) ??
        ((entity as any).createdAt as Date);
      if (!(date instanceof Date) || isNaN(date as any)) {
        throw Error(
          `${date} is not a valid date! Can not calculate metrics for "${strategy.code}"`
        );
      }
      const yearMonth = getYearMonth(date);
      const entry = entitiesPerMonth.get(yearMonth);
      if (!entry) {
        return;
      }
      entry.entities.push(entity);
      entitiesPerMonth.set(yearMonth, entry);
    });
    return Array.from(entitiesPerMonth.values());
  }
  getMonthName(monthNr: number): string {
    const monthNames = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];
    return monthNames[monthNr];
  }
}
```

## File: packages/vendure-plugin-metrics/src/api/scalars.graphql.ts

```typescript
import gql from 'graphql-tag';
const scalars = gql`
  scalar DateTime
`;
```

## File: packages/vendure-plugin-metrics/src/api/schema.graphql.ts

```typescript
import gql from 'graphql-tag';
export const schema = gql`
  type AdvancedMetricSummary {
    code: String!
    title: String!
    type: AdvancedMetricType!
    allowProductSelection: Boolean!
    # The number of labels always matches the number of values.
    # E.g [january, february, march] belong to values [10, 20, 30]
    labels: [String!]!
    series: [AdvancedMetricSeries!]!
  }
  enum AdvancedMetricType {
    currency
    number
  }
  type AdvancedMetricSeries {
    name: String!
    values: [Float!]!
  }
  input AdvancedMetricSummaryInput {
    variantIds: [ID!]
  }
  extend type Query {
    advancedMetricSummaries(
      input: AdvancedMetricSummaryInput
    ): [AdvancedMetricSummary!]!
  }
`;
```

## File: packages/vendure-plugin-metrics/src/ui/chartist/chartist.component.ts

```typescript
import {
  ChangeDetectionStrategy,
  Component,
  ElementRef,
  Input,
  OnChanges,
  OnDestroy,
  OnInit,
  SimpleChanges,
  ViewChild,
  ChangeDetectorRef,
} from '@angular/core';
import { CurrencyPipe } from '@angular/common';
import { LineChart, LineChartData, LineChartOptions, easings } from 'chartist';
import ChartistTooltip from 'chartist-plugin-tooltips-updated';
import { legend } from './legend';
import { AdvancedMetricSummary } from '../generated/graphql';
export interface ChartFormatOptions {
  formatValueAs: 'currency' | 'number';
  currencyCode?: string;
  locale?: string;
}
export interface ChartEntry {
  summary: AdvancedMetricSummary;
  formatOptions: ChartFormatOptions;
}
@Component({
  selector: 'vdr-chartist',
  templateUrl: './chartist.component.html',
  styleUrls: ['./chartist.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ChartistComponent implements OnInit, OnChanges, OnDestroy {
  @Input() entries: ChartEntry | undefined;
  @Input() options?: LineChartOptions = {};
  @ViewChild('chartistDiv', { static: true })
  private chartDivRef: ElementRef<HTMLDivElement>;
  private chart: LineChart;
  constructor(private cdr: ChangeDetectorRef) {}
  ngOnInit() {
    this.chart = new LineChart(
      this.chartDivRef.nativeElement,
      this.entriesToLineChartData(this.entries),
      {
        low: 0,
        showArea: true,
        showLine: true,
        showPoint: true,
        fullWidth: true,
        axisY: {
          labelInterpolationFnc: (value: number, _: number) => {
            return this.formatCurrencyToValue(value);
          },
        },
        plugins: [
          ChartistTooltip({
            currency: '$',
            currencyFormatCallback: (value: number, _: any) => {
              return this.formatCurrencyToValue(value);
            },
          }),
          legend(),
        ],
        ...this.options,
      }
    );
    this.chart?.on('draw', (data) => {
      if (data.type === 'line' || data.type === 'area') {
        data.element.animate({
          d: {
            begin: 1000 * data.index,
            dur: 1000,
            from: data.path
              .clone()
              .scale(1, 0)
              .translate(0, data.chartRect.height())
              .stringify(),
            to: data.path.clone().stringify(),
            easing: easings.easeOutQuint,
          },
        });
      }
    });
    this.chart.on('created', (ctx) => {
      const defs = ctx.svg.elem('defs');
      defs
        .elem('linearGradient', {
          id: 'gradient',
          x1: 0,
          y1: 1,
          x2: 0,
          y2: 0,
        })
        .elem('stop', {
          offset: 0,
          'stop-color': 'var(--color-primary-400)',
          'stop-opacity': 0.2,
        })
        .parent()
        ?.elem('stop', {
          offset: 1,
          'stop-color': 'var(--color-primary-500)',
        });
    });
  }
  formatCurrencyToValue(value: number) {
    const entries = this.entries;
    if (entries) {
      const localeFrom =
        localStorage.getItem('vnd__contentLanguageCode') ?? 'en';
      const formatter = new CurrencyPipe(
        entries.formatOptions.locale ?? localeFrom,
        entries.formatOptions.currencyCode
      );
      const format = (l: number) =>
        entries.formatOptions.formatValueAs === 'currency'
          ? formatter.transform(l) ?? l
          : l;
      return format(value);
    }
    return value;
  }
  ngOnChanges(changes: SimpleChanges) {
    if ('entries' in changes && this.chart) {
      this.chart.update(this.entriesToLineChartData(this.entries));
    }
  }
  ngOnDestroy() {
    this.chart?.detach();
  }
  private entriesToLineChartData(entry: ChartEntry | undefined): LineChartData {
    if (entry?.summary.labels?.length) {
      const labels = entry.summary.labels;
      const series = entry.summary.series.map((s) => {
        return s.values.map((v) => {
          return {
            legend: s.name,
            value: v,
          };
        });
      });
      this.cdr.detectChanges();
      return { labels, series };
    }
    return { labels: [], series: [] };
  }
}
```

## File: packages/vendure-plugin-metrics/src/ui/chartist/legend.ts

```typescript
import { extend, alphaNumerate, PieChart } from 'chartist';
var defaultOptions = {
  className: '',
  classNames: false,
  removeAll: false,
  legendNames: false,
  clickable: false,
  onClick: null,
  position: 'top',
};
export function legend(options?: any) {
  if (options && options.position) {
    if (
      !(
        options.position === 'top' ||
        options.position === 'bottom' ||
        options.position instanceof HTMLElement
      )
    ) {
      throw Error('The position you entered is not a valid position');
    }
    if (options.position instanceof HTMLElement) {
      var cachedDOMPosition = options.position;
      delete options.position;
    }
  }
  options = extend({}, defaultOptions, options);
  if (cachedDOMPosition) {
    options.position = cachedDOMPosition;
  }
  return function legend(chart) {
    function removeLegendElement() {
      var legendElement = chart.container.querySelector('.ct-legend');
      if (legendElement) {
        legendElement.parentNode.removeChild(legendElement);
      }
    }
    function setSeriesClassNames() {
      chart.data.series = chart.data.series.map(function (series, seriesIndex) {
        if (typeof series !== 'object') {
          series = {
            value: series,
          };
        }
        series.className =
          series.className ||
          chart.options.classNames.series + '-' + alphaNumerate(seriesIndex);
        return series;
      });
    }
    function createLegendElement() {
      var legendElement = document.createElement('ul');
      legendElement.className = 'ct-legend';
      if (chart instanceof PieChart) {
        legendElement.classList.add('ct-legend-inside');
      }
      if (
        typeof options.className === 'string' &&
        options.className.length > 0
      ) {
        legendElement.classList.add(options.className);
      }
      if (chart.options.width) {
        legendElement.style.cssText =
          'width: ' + chart.options.width + 'px;margin: 0 auto;';
      }
      return legendElement;
    }
    function getLegendNames(useLabels) {
      return (
        options.legendNames ||
        (useLabels ? chart.data.labels : chart.data.series)
      );
    }
    function initSeriesMetadata(useLabels) {
      var seriesMetadata = new Array(chart.data.series.length);
      for (var i = 0; i < chart.data.series.length; i++) {
        seriesMetadata[i] = {
          data: chart.data.series[i],
          label: useLabels ? chart.data.labels[i] : null,
          legend: -1,
        };
      }
      return seriesMetadata;
    }
    function createNameElement(i, legendText, classNamesViable) {
      var li = document.createElement('li');
      li.classList.add('ct-series-' + i);
      if (classNamesViable) {
        li.classList.add(options.classNames[i]);
      }
      li.setAttribute('data-legend', i);
      li.textContent = legendText;
      return li;
    }
    function appendLegendToDOM(legendElement) {
      if (!(options.position instanceof HTMLElement)) {
        switch (options.position) {
          case 'top':
            chart.container.insertBefore(
              legendElement,
              chart.container.childNodes[0]
            );
            break;
          case 'bottom':
            chart.container.insertBefore(legendElement, null);
            break;
        }
      } else {
        options.position.insertBefore(legendElement, null);
      }
    }
    function addClickHandler(
      legendElement,
      legends,
      seriesMetadata,
      useLabels
    ) {
      legendElement.addEventListener('click', function (e) {
        var li = e.target;
        if (li.parentNode !== legendElement || !li.hasAttribute('data-legend'))
          return;
        e.preventDefault();
        var legendIndex = parseInt(li.getAttribute('data-legend'));
        var legend = legends[legendIndex];
        if (!legend.active) {
          legend.active = true;
          li.classList.remove('inactive');
        } else {
          legend.active = false;
          li.classList.add('inactive');
          var activeCount = legends.filter(function (legend) {
            return legend.active;
          }).length;
          if (!options.removeAll && activeCount == 0) {
            for (var i = 0; i < legends.length; i++) {
              legends[i].active = true;
              legendElement.childNodes[i].classList.remove('inactive');
            }
          }
        }
        var newSeries: any[] = [];
        var newLabels: any[] = [];
        for (var i = 0; i < seriesMetadata.length; i++) {
          if (
            seriesMetadata[i].legend != -1 &&
            legends[seriesMetadata[i].legend].active
          ) {
            newSeries.push(seriesMetadata[i].data);
            newLabels.push(seriesMetadata[i].label);
          }
        }
        chart.data.series = newSeries;
        if (useLabels) {
          chart.data.labels = newLabels;
        }
        chart.update();
        if (options.onClick) {
          options.onClick(chart, e);
        }
      });
    }
    function createLegend(legendNames) {
      removeLegendElement();
      var legendElement = createLegendElement();
      var useLabels = true;
      var legendNames = chart.data.series.map((s) => s[0].legend);
      var seriesMetadata = initSeriesMetadata(useLabels);
      var legends: any[] = [];
      var classNamesViable =
        Array.isArray(options.classNames) &&
        options.classNames.length === legendNames.length;
      legendNames.forEach(function (legend, i) {
        var legendText = legend.name || legend;
        var legendSeries = legend.series || [i];
        var li = createNameElement(i, legendText, classNamesViable);
        legendElement.appendChild(li);
        legendSeries.forEach(function (seriesIndex) {
          seriesMetadata[seriesIndex].legend = i;
        });
        legends.push({
          text: legendText,
          series: legendSeries,
          active: true,
        });
      });
      appendLegendToDOM(legendElement);
      if (options.clickable) {
        setSeriesClassNames();
        addClickHandler(legendElement, legends, seriesMetadata, useLabels);
      }
    }
    chart.on('created', function (data) {
      createLegend(chart.data.series.map((s) => s[0].name));
    });
  };
}
```

## File: packages/vendure-plugin-metrics/src/ui/metrics-ui.service.ts

```typescript
import { Injectable } from '@angular/core';
import { DataService, ChartFormatOptions } from '@vendure/admin-ui/core';
import { AdvancedMetricSummary, AdvancedMetricType } from './generated/graphql';
import { BehaviorSubject, Observable, combineLatest } from 'rxjs';
import { GET_METRICS } from './queries.graphql';
import { switchMap } from 'rxjs/operators';
import { ChartEntry } from './chartist/chartist.component';
export interface AdvancedChartEntry {
  label: string;
  value: number;
  formatOptions: ChartFormatOptions;
  code: string;
  name: string;
}
@Injectable({
  providedIn: 'root',
})
export class MetricsUiService {
  currencyCode$: Observable<any>;
  uiState$: Observable<any>;
  constructor(private dataService: DataService) {
    this.currencyCode$ = this.dataService.settings
      .getActiveChannel()
      .refetchOnChannelChange()
      .mapStream((data) => data.activeChannel.defaultCurrencyCode || undefined);
    this.uiState$ = this.dataService.client
      .uiState()
      .mapStream((data) => data.uiState);
  }
  queryData(selectedVariantIds?: string[]) {
    return combineLatest(this.currencyCode$, this.uiState$).pipe(
      switchMap(([currencyCode, uiState]) =>
        this.dataService
          .query(GET_METRICS, {
            input: {
              ...(selectedVariantIds ? { variantIds: selectedVariantIds } : []),
            },
          })
          .refetchOnChannelChange()
          .mapStream((metricSummary: any) => {
            return this.toChartEntry(
              metricSummary.advancedMetricSummaries,
              `${uiState.language}-${uiState.locale}`,
              currencyCode
            );
          })
      )
    );
  }
  toChartEntry(
    input: AdvancedMetricSummary[],
    locale: string,
    currencyCode: string
  ): ChartEntry[] {
    return input.map((r) => {
      const formatValueAs: 'currency' | 'number' =
        r.type === AdvancedMetricType.Number ? 'number' : 'currency';
      const formatOptions: ChartFormatOptions = {
        formatValueAs,
        currencyCode,
        locale,
      };
      return {
        formatOptions,
        summary: r,
      };
    });
  }
}
```

## File: packages/vendure-plugin-metrics/src/ui/metrics-widget.module.ts

```typescript
import { MetricsWidgetComponent } from './metrics-widget';
import { SharedModule } from '@vendure/admin-ui/core';
import { NgModule } from '@angular/core';
import { ChartistComponent } from './chartist/chartist.component';
@NgModule({
  imports: [SharedModule],
  declarations: [MetricsWidgetComponent, ChartistComponent],
})
export class MetricsWidgetModule {}
```

## File: packages/vendure-plugin-metrics/src/ui/metrics-widget.shared-module.ts

```typescript
import { NgModule } from '@angular/core';
import {
  registerDashboardWidget,
  setDashboardWidgetLayout,
} from '@vendure/admin-ui/core';
import { MetricsWidgetModule } from './metrics-widget.module';
@NgModule({
  imports: [MetricsWidgetModule],
  declarations: [],
  providers: [
    registerDashboardWidget('advanced-metrics', {
      title: 'Advanced metrics',
      supportedWidths: [6, 8, 12],
      loadComponent: () =>
        import('./metrics-widget').then((m) => m.MetricsWidgetComponent),
    }),
    setDashboardWidgetLayout([{ id: 'advanced-metrics', width: 12 }]),
  ],
})
export class MetricsWidgetSharedModule {}
```

## File: packages/vendure-plugin-metrics/src/ui/metrics-widget.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import {
  ModalService,
  ProductMultiSelectorDialogComponent,
} from '@vendure/admin-ui/core';
import { Observable } from 'rxjs';
import { ChartEntry } from './chartist/chartist.component';
import { MetricsUiService } from './metrics-ui.service';
@Component({
  selector: 'product-metrics-widget',
  template: `
    <div style="position: relative;">
      <div>
        <div *ngIf="loading" class="spinner-overlay">
          <div class="spinner">Loading...</div>
        </div>
        <button
          [disabled]="!selectedMetric?.summary.allowProductSelection"
          (click)="openProductSelectionDialog()"
          class="btn btn-sm btn-secondary"
        >
          {{
            'common.items-selected-count'
              | translate : { count: selectedVariantIds?.length ?? 0 }
          }}...
        </button>
        <button
          class="btn btn-sm circular-button"
          [attr.disabled]="selectedVariantIds.length == 0 ? 'disabled' : null"
          (click)="clearProductVariantSelection()"
        >
          <clr-icon shape="times"></clr-icon>
        </button>
        <small *ngIf="selectedVariantNames.length">
          {{ selectedVariantNames.join(' + ') }}
        </small>
      </div>
      <br />
      <br />
      <vdr-chartist [entries]="selectedMetric" style="padding-left: 50px; " />
      <br />
      <br />
      <div class="flex">
        <button
          *ngFor="let metric of metrics$ | async"
          class="button-small"
          (click)="selectedMetric = metric"
          [class.active]="selectedMetric?.summary.code === metric.summary.code"
        >
          {{ metric.summary.title }}
        </button>
      </div>
    </div>
  `,
  styles: [
    `
      .circular-button {
        width: 16px !important;
        min-width: 16px !important;
        height: 16px !important;
        min-height: 16px !important;
        border-radius: 50% !important;
        padding: 0px 0px !important;
        margin-left: 10.55px !important;
        margin-right: 10.55px !important;
        margin-bottom: 5px !important;
        padding-top: 7.5px !important;
        position: relative;
        top: 4px;
      }
    `,
    `
      clr-icon[shape='times'] {
        margin-top: -7.75px !important;
        margin-left: 0.2px !important;
      }
    `,
    `
      .button-small.active {
        background-color: var(--color-primary-200);
        color: var(--color-primary-900);
      }
    `,
    `
      .flex {
        gap: 0.5rem;
      }
    `,
    `
      .spinner-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 99;
      }
    `,
  ],
})
export class MetricsWidgetComponent implements OnInit {
  metrics$: Observable<ChartEntry[]> | undefined;
  selectedMetric: ChartEntry | undefined;
  variantName: string;
  dropDownName = 'Select Variant';
  nrOfOrdersChart?: any;
  selectedVariantIds: string[] = [];
  selectedVariantNames: string[] = [];
  loading = true;
  constructor(
    private changeDetectorRef: ChangeDetectorRef,
    private modalService: ModalService,
    private metricsService: MetricsUiService
  ) {}
  async ngOnInit() {
    this.loadChartData();
  }
  onDropdownItemClick(variantId: string, variantName: string) {
    this.loadChartData();
    this.dropDownName = variantName;
  }
  openProductSelectionDialog() {
    this.modalService
      .fromComponent(ProductMultiSelectorDialogComponent, {
        size: 'xl',
        locals: {
          mode: 'variant',
          initialSelectionIds: this.selectedVariantIds ?? [],
        },
      })
      .subscribe((selection) => {
        if (selection) {
          this.selectedVariantNames = selection.map(
            (s) => s.productVariantName
          );
          (this.selectedVariantIds = selection.map((s) => s.productVariantId)),
            this.changeDetectorRef.detectChanges();
          this.loadChartData();
        }
      });
  }
  clearProductVariantSelection() {
    this.selectedVariantIds = [];
    this.selectedVariantNames = [];
    this.changeDetectorRef.detectChanges();
    this.loadChartData();
  }
  loadChartData() {
    this.loading = true;
    this.metrics$ = this.metricsService.queryData(this.selectedVariantIds);
    this.changeDetectorRef.detectChanges();
    this.metrics$?.subscribe(async (metrics) => {
      this.loading = false;
      if (this.selectedMetric) {
        this.selectedMetric = metrics.find(
          (e) => e.summary.code == this.selectedMetric?.summary.code
        );
      } else {
        this.selectedMetric = metrics[0];
      }
      this.changeDetectorRef.detectChanges();
    });
  }
}
```

## File: packages/vendure-plugin-metrics/src/ui/queries.graphql.ts

```typescript
import gql from 'graphql-tag';
export const GET_METRICS = gql`
  query advancedMetricSummaries($input: AdvancedMetricSummaryInput) {
    advancedMetricSummaries(input: $input) {
      code
      title
      type
      allowProductSelection
      labels
      series {
        name
        values
      }
    }
  }
`;
```

## File: packages/vendure-plugin-metrics/src/constants.ts

```typescript
export const loggerCtx = 'MetricsPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-metrics/src/index.ts

```typescript
export * from './metrics.plugin';
export * from './api/metrics.service';
export * from './api/metrics.resolver';
export * from './ui/generated/graphql';
export * from './api/metrics/average-order-value';
export * from './api/metrics/revenue-per-product';
export * from './api/metrics/units-sold-metric';
```

## File: packages/vendure-plugin-metrics/src/metrics.plugin.ts

```typescript
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import path from 'path';
import { schema } from './api/schema.graphql';
import { MetricsResolver } from './api/metrics.resolver';
import { MetricsService } from './api/metrics.service';
import { MetricStrategy } from './api/metric-strategy';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { RevenuePerProduct } from './api/metrics/revenue-per-product';
import { AverageOrderValueMetric } from './api/metrics/average-order-value';
import { UnitsSoldMetric } from './api/metrics/units-sold-metric';
export interface MetricsPluginOptions {
  metrics: MetricStrategy<any>[];
  displayPastMonths: number;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  adminApiExtensions: {
    schema,
    resolvers: [MetricsResolver],
  },
  providers: [
    MetricsService,
    { provide: PLUGIN_INIT_OPTIONS, useFactory: () => MetricsPlugin.options },
  ],
  compatibility: '>=2.2.0',
})
export class MetricsPlugin {
  static options: MetricsPluginOptions = {
    metrics: [
      new RevenuePerProduct(),
      new AverageOrderValueMetric(),
      new UnitsSoldMetric(),
    ],
    displayPastMonths: 13,
  };
  static init(options: Partial<MetricsPluginOptions>): typeof MetricsPlugin {
    this.options = {
      ...this.options,
      ...options,
    };
    return MetricsPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'shared',
        ngModuleFileName: 'metrics-widget.shared-module.ts',
        ngModuleName: 'MetricsWidgetSharedModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-metrics/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import path from 'path';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import { MetricsPlugin } from '../src/';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { addItem, createSettledOrder } from '../../test/src/shop-utils';
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      MetricsPlugin.init({
        displayPastMonths: 19,
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [MetricsPlugin.ui],
          devMode: true,
        }),
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  for (let i = 0; i < 10; i++) {
    await shopClient.asAnonymousUser();
    await addItem(shopClient, '1', 1);
  }
})();
```

## File: packages/vendure-plugin-metrics/test/metrics.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import {
  AdvancedMetricSummariesQuery,
  AdvancedMetricSummary,
  MetricsPlugin,
} from '../src';
import { GET_METRICS } from '../src/ui/queries.graphql';
describe('Metrics', () => {
  let shopClient: SimpleGraphQLClient;
  let adminClient: SimpleGraphQLClient;
  let server: TestServer;
  let metrics: AdvancedMetricSummary[];
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const devConfig = mergeConfig(testConfig, {
      apiOptions: {
        port: 3050,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [MetricsPlugin],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    const env = createTestEnvironment(devConfig);
    shopClient = env.shopClient;
    adminClient = env.adminClient;
    server = env.server;
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
  }, 60000);
  it('Creates 3 settled orders', async () => {
    const variants = [
      { id: 'T_1', quantity: 1 },
      { id: 'T_2', quantity: 2 },
    ];
    await createSettledOrder(shopClient, 1, true, variants);
    await createSettledOrder(shopClient, 1, true, variants);
    await createSettledOrder(shopClient, 1, true, variants);
  });
  it('Fails to fetch metrics when unauthenticated', async () => {
    const promise = adminClient.query(GET_METRICS);
    await expect(promise).rejects.toThrow('authorized');
  });
  it('Fetches metrics for past 14 months', async () => {
    await adminClient.asSuperAdmin();
    const { advancedMetricSummaries } =
      await adminClient.query<AdvancedMetricSummariesQuery>(GET_METRICS);
    const averageOrderValue = advancedMetricSummaries.find(
      (m) => m.code === 'aov'
    )!;
    const revenuePerProduct = advancedMetricSummaries.find(
      (m) => m.code === 'revenue-per-product'
    )!;
    const salesPerProduct = advancedMetricSummaries.find(
      (m) => m.code === 'units-sold'
    )!;
    expect(advancedMetricSummaries.length).toEqual(3);
    expect(averageOrderValue.series[0].values.length).toEqual(14);
    expect(averageOrderValue.labels.length).toEqual(14);
    expect(averageOrderValue.series[0].values[13]).toEqual(4102);
    expect(revenuePerProduct.series[0].values.length).toEqual(14);
    expect(revenuePerProduct.labels.length).toEqual(14);
    expect(revenuePerProduct.series[0].values[13]).toEqual(3 * 4102);
    expect(salesPerProduct.series[0].values.length).toEqual(14);
    expect(salesPerProduct.labels.length).toEqual(14);
  });
  it('Fetches metrics for specific variant', async () => {
    await adminClient.asSuperAdmin();
    const { advancedMetricSummaries } =
      await adminClient.query<AdvancedMetricSummariesQuery>(GET_METRICS, {
        input: { variantIds: [1, 2] },
      });
    expect(advancedMetricSummaries.length).toEqual(3);
    const revenuePerProduct = advancedMetricSummaries.find(
      (m) => m.code === 'revenue-per-product'
    )!;
    expect(revenuePerProduct.series[0].values.length).toEqual(14);
    expect(revenuePerProduct.series[1].values.length).toEqual(14);
    expect(revenuePerProduct.labels.length).toEqual(14);
    expect(revenuePerProduct.series[0].values[13]).toEqual(3897);
    expect(revenuePerProduct.series[1].values[13]).toEqual(8394);
    const salesPerProduct = advancedMetricSummaries.find(
      (m) => m.code === 'units-sold'
    )!;
    expect(salesPerProduct.series[0].values.length).toEqual(14);
    expect(salesPerProduct.series[1].values.length).toEqual(14);
    expect(salesPerProduct.labels.length).toEqual(14);
    expect(salesPerProduct.series[0].values[13]).toEqual(3);
    expect(salesPerProduct.series[1].values[13]).toEqual(6);
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(__dirname, MetricsPlugin.ui);
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-modify-customer-orders/src/api/api.extension.ts

```typescript
import { gql } from 'graphql-tag';
export const adminApiExtension = gql`
  extend type Mutation {
    convertOrderToDraft(id: ID!): Order
  }
`;
```

## File: packages/vendure-plugin-modify-customer-orders/src/api/api.resolver.ts

```typescript
import { Resolver, Mutation, Args } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  RequestContext,
  Permission,
  ID,
  Order,
} from '@vendure/core';
import { ModifyCustomerOrderService } from './modify-customer-order.service';
@Resolver()
export class AdminApiResolver {
  constructor(
    private readonly modifyCustomerOrder: ModifyCustomerOrderService
  ) {}
  @Mutation()
  @Allow(Permission.CreateOrder)
  async convertOrderToDraft(
    @Ctx() ctx: RequestContext,
    @Args('id') id: ID
  ): Promise<Order> {
    return this.modifyCustomerOrder.transitionToDraftState(ctx, id);
  }
}
```

## File: packages/vendure-plugin-modify-customer-orders/src/api/modify-customer-order.service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { filter } from 'rxjs';
import {
  ConfigService,
  EventBus,
  ID,
  Logger,
  Order,
  OrderService,
  OrderState,
  OrderStateTransitionError,
  OrderStateTransitionEvent,
  ProcessContext,
  RequestContext,
  Session,
  SessionService,
  TransactionalConnection,
  UserInputError,
  assertFound,
} from '@vendure/core';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { ModifyCustomerOrdersPluginOptions } from '../modify-customer-orders.plugin';
@Injectable()
export class ModifyCustomerOrderService implements OnApplicationBootstrap {
  constructor(
    private readonly eventBus: EventBus,
    private readonly orderService: OrderService,
    private readonly connection: TransactionalConnection,
    private readonly sessionService: SessionService,
    private readonly configService: ConfigService,
    private readonly processContext: ProcessContext,
    @Inject(PLUGIN_INIT_OPTIONS)
    private readonly options: ModifyCustomerOrdersPluginOptions
  ) {}
  onApplicationBootstrap(): void {
    if (this.options.autoAssignDraftOrdersToCustomer) {
      Logger.info(
        'Listening for Draft order completion, to auto assign draft orders to customers',
        loggerCtx
      );
      this.eventBus
        .ofType(OrderStateTransitionEvent)
        .pipe(
          filter((event) => event.fromState === 'Draft'),
          filter((event) => event.toState === 'ArrangingPayment')
        )
        .subscribe(({ ctx, order: draftOrder }) =>
          this.assignOrderToCustomer(ctx, draftOrder).catch((e: any) => {
            Logger.error(
              `Error assigning draft order ${draftOrder.code} to customer`,
              loggerCtx,
              e?.stack
            );
          })
        );
    }
  }
  async transitionToDraftState(ctx: RequestContext, id: ID) {
    const order = await this.orderService.findOne(ctx, id);
    if (order?.state !== 'AddingItems') {
      throw new UserInputError(
        `Only active orders can be changed to a draft order`
      );
    }
    await this.unsetActiveOrder(ctx, order);
    const transitionResult = await this.orderService.transitionToState(
      ctx,
      id,
      'Draft'
    );
    if (transitionResult instanceof Order) {
      Logger.info(
        `Transitioned Order with id ${transitionResult.id} from 'AddingItems' to 'Draft'`,
        loggerCtx
      );
      return await assertFound(
        this.orderService.findOne(ctx, transitionResult.id)
      );
    }
    Logger.error(
      `Failed to transition Order with id ${id} to 'Draft' state`,
      loggerCtx
    );
    throw transitionResult;
  }
  async assignOrderToCustomer(
    ctx: RequestContext,
    draftOrder: Order
  ): Promise<void> {
    if (!draftOrder.customer?.user?.id) {
      Logger.info(
        `Draft order ${draftOrder.code} has no customer, skipping auto assign`,
        loggerCtx
      );
      return;
    }
    const currentActiveOrder = await this.orderService.getActiveOrderForUser(
      ctx,
      draftOrder.customer.user.id
    );
    if (currentActiveOrder) {
      await this.transitionToDraftState(ctx, currentActiveOrder.id);
    }
    await this.setOrderState(ctx, draftOrder, 'AddingItems');
    await this.setAsActiveOrder(ctx, draftOrder, draftOrder.customer.user.id);
    Logger.info(
      `Assigned draft order ${draftOrder.code} as active order to ${draftOrder.customer?.emailAddress}`,
      loggerCtx
    );
  }
  async setAsActiveOrder(
    ctx: RequestContext,
    order: Order,
    userId: ID
  ): Promise<void> {
    await this.connection
      .getRepository(ctx, Order)
      .update({ id: order.id }, { active: true });
    const session = await this.connection
      .getRepository(ctx, Session)
      .createQueryBuilder('session')
      .leftJoinAndSelect('session.user', 'user')
      .leftJoinAndSelect('user.roles', 'roles')
      .leftJoinAndSelect('roles.channels', 'channels')
      .where('session.userId = :userId', { userId })
      .getOne();
    if (session) {
      session.activeOrder = order;
      await this.connection
        .getRepository(ctx, Session)
        .save(session, { reload: false });
      const updatedSerializedSession =
        this.sessionService.serializeSession(session);
      await this.configService.authOptions.sessionCacheStrategy.set(
        updatedSerializedSession
      );
    }
  }
  async unsetActiveOrder(ctx: RequestContext, order: Order): Promise<void> {
    await this.connection
      .getRepository(ctx, Order)
      .update({ id: order.id }, { active: false });
    const sessions = await this.connection.getRepository(ctx, Session).find({
      where: { activeOrderId: order.id },
      relations: ['user', 'user.roles', 'user.roles.channels'],
    });
    for (const session of sessions) {
      session.activeOrder = null;
      await this.connection.getRepository(ctx, Session).save(session);
      const updatedSerializedSession =
        this.sessionService.serializeSession(session);
      await this.configService.authOptions.sessionCacheStrategy.set(
        updatedSerializedSession
      );
    }
    Logger.info(
      `Unset active order ${order.code} for customer ${order.customer?.emailAddress}`,
      loggerCtx
    );
  }
  async setOrderState(
    ctx: RequestContext,
    order: Order,
    state: OrderState
  ): Promise<Order | OrderStateTransitionError> {
    const transitionToStateResult = await this.orderService.transitionToState(
      ctx,
      order.id,
      state
    );
    if (transitionToStateResult instanceof OrderStateTransitionError) {
      throw Error(
        `Error transitioning order ${order.code} from ${transitionToStateResult.fromState} to ${transitionToStateResult.toState}: ${transitionToStateResult.message}`
      );
    }
    return transitionToStateResult;
  }
}
```

## File: packages/vendure-plugin-modify-customer-orders/src/ui/convert-to-draft-button.module.ts

```typescript
import { addActionBarItem, SharedModule } from '@vendure/admin-ui/core';
import { NgModule } from '@angular/core';
import { createNewDraftOrder } from './order-state.util';
import { RouterModule } from '@angular/router';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forRoot([], { onSameUrlNavigation: 'reload' }),
  ],
  providers: [
    addActionBarItem({
      id: 'active-to-draft',
      label: 'Convert to Draft',
      buttonColor: 'success',
      buttonStyle: 'outline',
      icon: 'history',
      locationId: 'order-detail',
      routerLink: [],
      requiresPermission: 'CreateOrder',
      onClick: async (event, { route, dataService, notificationService }) => {
        const orderId = route.snapshot.params.id;
        await createNewDraftOrder(dataService, orderId);
        notificationService.success(`Successfully created a Draft order`);
      },
    }),
  ],
})
export class ConvertToDraftButtonModule {}
```

## File: packages/vendure-plugin-modify-customer-orders/src/ui/index.ts

```typescript
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
export const convertToDraftButton: AdminUiExtension = {
  extensionPath: path.join(__dirname, ''),
  ngModules: [
    {
      type: 'shared',
      ngModuleFileName: 'convert-to-draft-button.module.ts',
      ngModuleName: 'ConvertToDraftButtonModule',
    },
  ],
};
```

## File: packages/vendure-plugin-modify-customer-orders/src/ui/order-state.util.ts

```typescript
import { DataService, ORDER_DETAIL_FRAGMENT } from '@vendure/admin-ui/core';
import { take } from 'rxjs/operators';
import { gql } from 'graphql-tag';
import { ID } from '@vendure/core';
import { lastValueFrom } from 'rxjs';
export async function createNewDraftOrder(
  dataService: DataService,
  oldOrderID: ID
): Promise<Boolean> {
  await lastValueFrom(
    dataService
      .mutate(
        gql`
          mutation ConvertToDraft($id: ID!) {
            convertOrderToDraft(id: $id) {
              ... on Order {
                ...OrderDetail
              }
            }
          }
          ${ORDER_DETAIL_FRAGMENT}
        `,
        { id: oldOrderID }
      )
      .pipe(take(1))
  );
  return true;
}
```

## File: packages/vendure-plugin-modify-customer-orders/src/constants.ts

```typescript
export const loggerCtx = 'ModifyCustomerOrdersPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-modify-customer-orders/src/custom-order-process.ts

```typescript
import { OrderProcess } from '@vendure/core';
export const convertToDraft: OrderProcess<'AddingItems'> = {
  transitions: {
    AddingItems: {
      to: ['Draft'],
      mergeStrategy: 'merge',
    },
  },
};
```

## File: packages/vendure-plugin-modify-customer-orders/src/index.ts

```typescript
export * from './modify-customer-orders.plugin';
export * from './api/api.extension';
export * from './api/api.resolver';
export * from './api/modify-customer-order.service';
```

## File: packages/vendure-plugin-modify-customer-orders/src/modify-customer-orders.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { adminApiExtension } from './api/api.extension';
import { AdminApiResolver } from './api/api.resolver';
import { convertToDraftButton } from './ui';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { convertToDraft } from './custom-order-process';
import { ModifyCustomerOrderService } from './api/modify-customer-order.service';
export interface ModifyCustomerOrdersPluginOptions {
  autoAssignDraftOrdersToCustomer: boolean;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  adminApiExtensions: {
    resolvers: [AdminApiResolver],
    schema: adminApiExtension,
  },
  providers: [
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => ModifyCustomerOrdersPlugin.options,
    },
    ModifyCustomerOrderService,
  ],
  configuration: (config) => {
    config.orderOptions.process.push(convertToDraft);
    return config;
  },
  compatibility: '>=2.2.0',
  exports: [ModifyCustomerOrderService],
})
export class ModifyCustomerOrdersPlugin {
  static options: ModifyCustomerOrdersPluginOptions = {
    autoAssignDraftOrdersToCustomer: false,
  };
  static ui: AdminUiExtension = convertToDraftButton;
  static init(
    options: ModifyCustomerOrdersPluginOptions
  ): typeof ModifyCustomerOrdersPlugin {
    this.options = options;
    return ModifyCustomerOrdersPlugin;
  }
}
```

## File: packages/vendure-plugin-modify-customer-orders/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler/';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { addItem, createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import path from 'path';
import { ModifyCustomerOrdersPlugin } from '../src';
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      DefaultSearchPlugin,
      ModifyCustomerOrdersPlugin.init({
        autoAssignDraftOrdersToCustomer: true,
      }),
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [ModifyCustomerOrdersPlugin.ui],
          devMode: true,
        }),
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await createSettledOrder(shopClient, 1);
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await addItem(shopClient as any, 'T_1', 1);
})();
```

## File: packages/vendure-plugin-modify-customer-orders/test/modify-customer-orders.spec.ts

```typescript
import {
  DefaultLogger,
  LogLevel,
  mergeConfig,
  Order,
  OrderLine,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { initialData } from '../../test/src/initial-data';
import {
  addItem,
  createSettledOrder,
  getActiveOrder,
} from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { ModifyCustomerOrdersPlugin } from '../src';
import { convertToDraftMutation, TRANSITION_ORDER_TO } from './test-helper';
import { setAddressAndShipping } from '../../test/src/shop-utils';
import { SetShippingMethod } from '../../test/src/generated/shop-graphql';
import { getOrder } from '../../test/src/admin-utils';
import { waitFor } from '../../test/src/test-helpers';
let server: TestServer;
let adminClient: any;
let shopClient: any;
let convertedOrder: Order;
let newActiveOrder: Order;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: console,
    plugins: [
      ModifyCustomerOrdersPlugin.init({
        autoAssignDraftOrdersToCustomer: true,
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 5,
  });
  await adminClient.asSuperAdmin();
}, 60000);
it('Should start successfully', async () => {
  expect(server.app.getHttpServer).toBeDefined;
});
it('Should change active order to draft order', async () => {
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  const testActiveOrder = await addItem(shopClient, 'T_1', 1);
  const res = await shopClient.query(SetShippingMethod, {
    ids: ['T_1'],
  });
  const { convertOrderToDraft: draftOrder } = await adminClient.query(
    convertToDraftMutation,
    {
      id: testActiveOrder.id,
    }
  );
  convertedOrder = draftOrder;
  const activeOrder = await addItem(shopClient, 'T_1', 1);
  expect(draftOrder.state).toBe('Draft');
  expect(draftOrder.lines.length).toBe(testActiveOrder.lines.length);
  for (let line of testActiveOrder.lines) {
    expect(
      draftOrder.lines.some(
        (l: OrderLine) => l.productVariant.id == line.productVariant.id
      )
    ).toBe(true);
  }
  expect(draftOrder.shippingAddress.fullName).toBe(
    testActiveOrder.shippingAddress.fullName
  );
  expect(draftOrder.customer.emailAddress).toBe(
    testActiveOrder.customer?.emailAddress
  );
  expect(draftOrder.code).not.toBe(activeOrder.code);
  expect(draftOrder.active).toBe(false);
});
it('Should not change non active order to draft order', async () => {
  const testNonActiveOrder = await createSettledOrder(shopClient, 1);
  try {
    await adminClient.query(convertToDraftMutation, {
      id: testNonActiveOrder.id,
    });
  } catch (e) {
    expect((e as any).response.errors[0].message).toBe(
      'Only active orders can be changed to a draft order'
    );
  }
});
it('Creates a new active order for customer', async () => {
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  const order = await addItem(shopClient, 'T_1', 1);
  newActiveOrder = order;
  expect(order.state).toBe('AddingItems');
});
it('Assigned the draft order to customer as active order', async () => {
  const { transitionOrderToState } = await adminClient.query(
    TRANSITION_ORDER_TO,
    {
      id: convertedOrder.id,
      state: 'ArrangingPayment',
    }
  );
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  const activeOrder = await waitFor(async () => {
    const activeOrder = await getActiveOrder(shopClient);
    if (activeOrder?.code === convertedOrder.code) {
      return activeOrder;
    }
  }, 200);
  expect(transitionOrderToState.state).toBe('ArrangingPayment');
  expect(transitionOrderToState.active).toBe(true);
  expect(transitionOrderToState.code).toBe(activeOrder?.code);
});
it('Transitioned previous active order to draft', async () => {
  const draftOrder = await getOrder(adminClient, newActiveOrder?.id);
  expect(draftOrder?.active).toBe(false);
  expect(draftOrder?.state).toBe('Draft');
});
if (process.env.TEST_ADMIN_UI) {
  it('Should compile admin', async () => {
    const files = await getFilesInAdminUiFolder(
      __dirname,
      ModifyCustomerOrdersPlugin.ui
    );
    expect(files?.length).toBeGreaterThan(0);
  }, 200000);
}
afterAll(async () => {
  await server.destroy();
}, 100000);
```

## File: packages/vendure-plugin-modify-customer-orders/test/test-helper.ts

```typescript
import { gql } from 'graphql-tag';
export const convertToDraftMutation = gql`
  mutation ConvertToDraft($id: ID!) {
    convertOrderToDraft(id: $id) {
      id
      code
      state
      active
      total
      totalWithTax
      customer {
        emailAddress
      }
      shippingAddress {
        fullName
      }
      lines {
        id
        quantity
        productVariant {
          id
        }
        discounts {
          adjustmentSource
          amount
          amountWithTax
          description
          type
        }
      }
    }
  }
`;
export const TRANSITION_ORDER_TO = gql`
  mutation TransitionOrderToState($id: ID!, $state: String!) {
    transitionOrderToState(id: $id, state: $state) {
      ... on Order {
        id
        code
        totalWithTax
        total
        state
        active
      }
      ... on OrderStateTransitionError {
        errorCode
        message
        transitionError
      }
    }
  }
`;
```

## File: packages/vendure-plugin-multiserver-db-sessioncache/src/index.ts

```typescript
export * from './plugin';
export * from './session-cache';
export * from './session-cache.strategy';
```

## File: packages/vendure-plugin-multiserver-db-sessioncache/src/plugin.ts

```typescript
import { VendurePlugin } from '@vendure/core';
import { SessionCache } from './session-cache';
import { MultiServerDbSessionCacheStrategy } from './session-cache.strategy';
@VendurePlugin({
  entities: [SessionCache],
  configuration: (config) => {
    config.authOptions.sessionCacheStrategy =
      new MultiServerDbSessionCacheStrategy();
    return config;
  },
  compatibility: '>=2.2.0',
})
export class MultiServerDbSessionCachePlugin {}
```

## File: packages/vendure-plugin-multiserver-db-sessioncache/src/session-cache.strategy.ts

```typescript
import {
  CachedSession,
  Injector,
  InternalServerError,
  Logger,
  SessionCacheStrategy,
} from '@vendure/core';
import { DataSource, Repository } from 'typeorm';
import { SessionCache } from './session-cache';
const loggerCtx = `MutliServerDbSessionCacheStrategy`;
export class MultiServerDbSessionCacheStrategy implements SessionCacheStrategy {
  multiServerDBSessionCache?: Repository<SessionCache>;
  init(injector: Injector) {
    this.multiServerDBSessionCache = injector
      .get(DataSource)
      .getRepository(SessionCache);
  }
  async get(sessionToken: string): Promise<CachedSession | undefined> {
    if (!this.multiServerDBSessionCache) {
      Logger.error(
        'MultiServerDbSessionCache repository not initialized',
        loggerCtx
      );
      return;
    }
    const retrieved = await this.multiServerDBSessionCache.findOneBy({
      id: sessionToken,
    });
    return retrieved?.session;
  }
  async set(session: CachedSession) {
    if (!this.multiServerDBSessionCache) {
      Logger.error(
        'MultiServerDbSessionCache repository not initialized',
        loggerCtx
      );
      return;
    }
    const sessionData = new SessionCache();
    sessionData.id = session.token;
    sessionData.session = session;
    await this.multiServerDBSessionCache
      .upsert(sessionData, ['id'])
      .catch((e: any) => {
        if (e instanceof Error) {
          Logger.error(e.message, loggerCtx, e.stack);
        } else {
          Logger.error(e, loggerCtx);
        }
      });
  }
  async delete(sessionToken: string) {
    if (!this.multiServerDBSessionCache) {
      Logger.error(
        'MultiServerDbSessionCache repository not initialized',
        loggerCtx
      );
      return;
    }
    await this.multiServerDBSessionCache.delete({ id: sessionToken });
  }
  async clear() {
    if (this.multiServerDBSessionCache) {
      await this.multiServerDBSessionCache.delete({});
    }
  }
}
```

## File: packages/vendure-plugin-multiserver-db-sessioncache/src/session-cache.ts

```typescript
import { VendureEntity, DeepPartial, CachedSession } from '@vendure/core';
import { Column, Entity, PrimaryColumn } from 'typeorm';
@Entity()
export class SessionCache extends VendureEntity {
  constructor(input?: DeepPartial<SessionCache>) {
    super(input);
  }
  @PrimaryColumn('varchar', { nullable: false, unique: true })
  id!: string;
  @Column('simple-json', { nullable: false })
  session!: CachedSession;
}
```

## File: packages/vendure-plugin-multiserver-db-sessioncache/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import path from 'path';
import { MultiServerDbSessionCachePlugin } from '../src/plugin';
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    plugins: [
      DefaultSearchPlugin,
      MultiServerDbSessionCachePlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-multiserver-db-sessioncache/test/multiserver-db-cache.spec.ts

```typescript
import {
  CachedSession,
  DefaultLogger,
  ID,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { DataSource } from 'typeorm';
import { initialData } from '../../test/src/initial-data';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
import { MultiServerDbSessionCachePlugin } from '../src/plugin';
import { gql } from 'graphql-tag';
import { SessionCache } from '../src/session-cache';
describe('Multi-Server Db Session Cache Plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  let activeUserId: ID;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [MultiServerDbSessionCachePlugin],
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData,
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 5,
    });
    serverStarted = true;
  }, 60000);
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  it('Should add item to order', async () => {
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const { addItemToOrder } = await shopClient.query(
      gql`
        mutation AddItemToOrder($productVariantId: ID!, $quantity: Int!) {
          addItemToOrder(
            productVariantId: $productVariantId
            quantity: $quantity
          ) {
            ... on Order {
              id
              customer {
                emailAddress
                user {
                  id
                }
              }
            }
            ... on ErrorResult {
              message
            }
          }
        }
      `,
      {
        productVariantId: 'T_1',
        quantity: 1,
      }
    );
    expect(addItemToOrder.id).toBeDefined();
    expect(addItemToOrder.customer.emailAddress).toEqual(
      'hayden.zieme12@hotmail.com'
    );
    activeUserId = addItemToOrder.customer.user.id;
  });
  it('Should have cached session id', async () => {
    const dataSource = server.app.get(DataSource);
    const multiServerDbSessionCacheRepo =
      dataSource.getRepository(SessionCache);
    const allSessions = await multiServerDbSessionCacheRepo.find();
    const sessionData = allSessions[0].session;
    expect(allSessions.length).toBe(1);
    expect(activeUserId).toEqual(`T_${sessionData.user?.id}`);
  });
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel-config.entity.ts

```typescript
import { Column, Entity } from 'typeorm';
import { DeepPartial, VendureEntity } from '@vendure/core';
@Entity()
export class MyparcelConfigEntity extends VendureEntity {
  constructor(input?: DeepPartial<MyparcelConfigEntity>) {
    super(input);
  }
  @Column({ unique: true })
  channelId!: string;
  @Column()
  apiKey!: string;
}
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel-default-shipment.strategy.ts

```typescript
import { Order } from '@vendure/core';
import { OrderAddress } from '@vendure/common/lib/generated-types';
import {
  MyParcelError,
  MyParcelShipmentStrategy,
  MyparcelRecipient,
  MyparcelShipment,
  MyparcelShipmentOptions,
} from './types';
export class MyParcalDefaultShipmentStrategy
  implements MyParcelShipmentStrategy
{
  getHousenumber(nrAndSuffix: string): [string, string] {
    if (!nrAndSuffix) {
      throw new MyParcelError(`No houseNr given`);
    }
    const [_, houseNr, suffix] = nrAndSuffix.split(/^[^\d]*(\d+)/);
    if (!houseNr) {
      throw new MyParcelError(`Invalid houseNumber ${nrAndSuffix}`);
    }
    return [houseNr, suffix];
  }
  getOptions(address: OrderAddress, order: Order, customsContent: string) {
    return {
      package_type: 1,
      label_description: order.code,
    };
  }
  getRecipient(address: OrderAddress, order: Order, customsContent: string) {
    const [nr, nrSuffix] = this.getHousenumber(address.streetLine2!);
    return {
      cc: address.countryCode!,
      region: address.province || undefined,
      city: address.city!,
      street: address.streetLine1!,
      number: nr,
      number_suffix: nrSuffix,
      postal_code: address.postalCode!,
      person: address.fullName!,
      phone: address.phoneNumber || undefined,
      email: order.customer?.emailAddress,
    };
  }
  getShipment(address: OrderAddress, order: Order, customsContent: string) {
    const shipment: MyparcelShipment = {
      carrier: 1,
      reference_identifier: order.code,
      options: this.getOptions(address, order, customsContent),
      recipient: this.getRecipient(address, order, customsContent),
    };
    return shipment;
  }
}
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel.admin.graphql.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  RequestContext,
  PermissionDefinition,
} from '@vendure/core';
import { MyparcelService } from './myparcel.service';
import { MyparcelConfigEntity } from './myparcel-config.entity';
import gql from 'graphql-tag';
export const myparcelPermission = new PermissionDefinition({
  name: 'SetMyparcelConfig',
  description: 'Allows setting MyParcel configurations',
});
export const adminSchema = gql`
  input MyparcelConfigInput {
    apiKey: String
  }
  type MyparcelConfig {
    apiKey: String
  }
  extend type Mutation {
    updateMyparcelConfig(input: MyparcelConfigInput!): MyparcelConfig
  }
  extend type Query {
    myparcelConfig: MyparcelConfig
  }
`;
@Resolver()
export class MyparcelAdminResolver {
  constructor(private service: MyparcelService) {}
  @Query()
  @Allow(myparcelPermission.Permission)
  async myparcelConfig(
    @Ctx() ctx: RequestContext
  ): Promise<MyparcelConfigEntity | null> {
    return this.service.getConfig(ctx);
  }
  @Mutation()
  @Allow(myparcelPermission.Permission)
  async updateMyparcelConfig(
    @Ctx() ctx: RequestContext,
    @Args('input') input: { apiKey: string }
  ): Promise<MyparcelConfigEntity | null> {
    return this.service.upsertConfig(ctx, input.apiKey);
  }
}
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel.controller.ts

```typescript
import { Body, Controller, Headers, Post } from '@nestjs/common';
import { MyparcelService, MyparcelStatusChangeEvent } from './myparcel.service';
import { Logger, RequestContext, Ctx } from '@vendure/core';
import { loggerCtx } from '../constants';
@Controller('myparcel')
export class MyparcelController {
  constructor(private myparcelService: MyparcelService) {}
  @Post('update-status')
  async webhook(
    @Ctx() ctx: RequestContext,
    @Body() body: MyparcelStatusChangeEvent,
    @Headers('X-MyParcel-Authorization') auth: string
  ): Promise<void> {
    const status = body?.data?.hooks?.[0]?.status;
    const shipmentId = body?.data?.hooks?.[0]?.shipment_id;
    Logger.info(`Incoming webhook ${shipmentId}`, loggerCtx);
    const incomingKey = Buffer.from(auth, 'base64').toString();
    if (!shipmentId || !status) {
      return Logger.error(
        `Invalid incoming webhook: ${JSON.stringify(body.data)}`,
        loggerCtx
      );
    }
    const config = await this.myparcelService
      .getConfigByKey(ctx, incomingKey)
      .catch((error) => {
        Logger.error('Failed to get config for incoming key', loggerCtx, error);
        throw error;
      });
    Logger.info(
      `Incoming status-change for shipment ${shipmentId} for channel ${config.channelId} with status ${status}`,
      loggerCtx
    );
    await this.myparcelService.updateStatus(
      ctx,
      config.channelId,
      shipmentId,
      status
    );
  }
}
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel.handler.ts

```typescript
import {
  FulfillmentHandler,
  Injector,
  LanguageCode,
  Logger,
} from '@vendure/core';
import { MyparcelService } from './myparcel.service';
import { loggerCtx } from '../constants';
let myparcelService: MyparcelService;
export const myparcelHandler = new FulfillmentHandler({
  code: 'my-parcel',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Send order to MyParcel',
    },
  ],
  args: {
    customsContents: {
      type: 'string',
      required: false,
      defaultValue: '',
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'Type of contents in the package.',
        },
      ],
      description: [
        {
          languageCode: LanguageCode.en,
          value: 'Only select this for shipments outside the EU!',
        },
      ],
      ui: {
        component: 'select-form-input',
        options: [
          {
            value: '',
            label: [{ languageCode: LanguageCode.en, value: '-' }],
          },
          {
            value: 1,
            label: [
              { languageCode: LanguageCode.en, value: '1. Commercial goods' },
            ],
          },
          {
            value: 2,
            label: [
              { languageCode: LanguageCode.en, value: '2. Commercial samples' },
            ],
          },
          {
            value: 3,
            label: [{ languageCode: LanguageCode.en, value: '3. Documents' }],
          },
          {
            value: 4,
            label: [{ languageCode: LanguageCode.en, value: '4. Gifts' }],
          },
          {
            value: 5,
            label: [
              { languageCode: LanguageCode.en, value: '5. Return shipment' },
            ],
          },
        ],
      },
    },
  },
  init: (injector: Injector) => {
    myparcelService = injector.get(MyparcelService);
  },
  createFulfillment: async (ctx, orders, orderItems, args) => {
    const shipmentId = await myparcelService
      .createShipments(ctx, orders, args.customsContents)
      .catch((err) => {
        Logger.error(err?.message, loggerCtx, err?.stack);
        throw err;
      });
    return {
      method: shipmentId,
    };
  },
});
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel.service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import {
  Channel,
  EntityHydrator,
  FulfillmentService,
  FulfillmentState,
  LanguageCode,
  Logger,
  Order,
  OrderLine,
  RequestContext,
  TransactionalConnection,
  UserInputError,
} from '@vendure/core';
import { OrderAddress } from '@vendure/common/lib/generated-types';
import axios from 'axios';
import { Fulfillment } from '@vendure/core';
import { MyparcelConfigEntity } from './myparcel-config.entity';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import {
  MyparcelDropOffPoint,
  MyparcelDropOffPointInput,
} from '../generated/graphql';
import {
  CustomsItem,
  MyparcelConfig,
  MyParcelError,
  MyparcelShipment,
} from './types';
@Injectable()
export class MyparcelService implements OnApplicationBootstrap {
  client = axios.create({ baseURL: 'https://api.myparcel.nl/' });
  constructor(
    private fulfillmentService: FulfillmentService,
    private connection: TransactionalConnection,
    @Inject(PLUGIN_INIT_OPTIONS) private config: MyparcelConfig,
    private hydrator: EntityHydrator
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    if (this.config.syncWebhookOnStartup) {
      const defualtChannel = await this.connection.rawConnection
        .getRepository(Channel)
        .find({ where: { code: '__default_channel__' } });
      const ctx = new RequestContext({
        apiType: 'admin',
        isAuthorized: true,
        authorizedAsOwnerOnly: false,
        channel: defualtChannel[0],
      });
      this.setWebhooksForAllChannels(ctx)
        .then(() => Logger.info(`Initialized MyParcel plugin`, loggerCtx))
        .catch((err) =>
          Logger.error(`Failed to initialized MyParcel plugin`, loggerCtx, err)
        );
    } else {
      Logger.info(
        `Initialized MyParcel plugin without syncing webhook to MyParcel`,
        loggerCtx
      );
    }
  }
  async setWebhooksForAllChannels(ctx: RequestContext): Promise<void> {
    const webhook = `${this.config.vendureHost}/myparcel/update-status`;
    const configs = await this.getAllConfigs(ctx);
    await Promise.all(
      configs.map(({ channelId, apiKey }) => {
        return this.request('webhook_subscriptions', 'POST', apiKey, {
          webhook_subscriptions: [
            {
              hook: 'shipment_status_change',
              url: webhook,
            },
          ],
        })
          .then(() =>
            Logger.info(`Set webhook for ${channelId} to ${webhook}`, loggerCtx)
          )
          .catch((error: Error) =>
            Logger.error(
              `Failed to set webhook for ${channelId}`,
              loggerCtx,
              error.stack
            )
          );
      })
    );
  }
  async upsertConfig(
    ctx: RequestContext,
    apiKey: string
  ): Promise<MyparcelConfigEntity | null> {
    const existing = await this.connection
      .getRepository(ctx, MyparcelConfigEntity)
      .findOne({ where: { channelId: ctx.channelId as string } });
    if ((!apiKey || apiKey === '') && existing) {
      await this.connection
        .getRepository(ctx, MyparcelConfigEntity)
        .delete(existing.id);
    } else if (existing) {
      await this.connection
        .getRepository(ctx, MyparcelConfigEntity)
        .update(existing.id, { apiKey: apiKey });
    } else {
      await this.connection
        .getRepository(ctx, MyparcelConfigEntity)
        .insert({ apiKey, channelId: ctx.channelId as string });
    }
    return this.connection
      .getRepository(ctx, MyparcelConfigEntity)
      .findOne({ where: { channelId: ctx.channelId as string } });
  }
  async getDropOffPoints(
    ctx: RequestContext,
    input: MyparcelDropOffPointInput
  ): Promise<MyparcelDropOffPoint[]> {
    const config = await this.getConfig(ctx);
    if (!config || !config?.apiKey) {
      Logger.info(
        `MyParcel is not enabled for channel ${ctx.channel.token}, can not fetch dropoff points`,
        loggerCtx
      );
      return [];
    }
    const searchParams = new URLSearchParams({
      postal_code: input.postalCode,
      limit: '30',
    });
    if (input.carrierId) {
      searchParams.append('carried_id', input.carrierId);
    }
    if (input.countryCode) {
      searchParams.append('cc', input.countryCode);
    }
    const path = `drop_off_points?${searchParams.toString()}`;
    const res = await this.request(path, 'GET', config.apiKey);
    let results = res.data.drop_off_points || [];
    if (input.carrierId) {
      results = results.filter((r: any) => r.carrier_id == input.carrierId);
    }
    Logger.debug(
      `Fetched ${results.length} drop off points from MyParcel for channel ${ctx.channel.token}`,
      loggerCtx
    );
    return results.slice(0, 10);
  }
  async getConfig(ctx: RequestContext): Promise<MyparcelConfigEntity | null> {
    return this.connection
      .getRepository(ctx, MyparcelConfigEntity)
      .findOne({ where: { channelId: ctx.channelId as string } });
  }
  async getConfigByKey(
    ctx: RequestContext,
    apiKey: string
  ): Promise<MyparcelConfigEntity> {
    const config = await this.connection
      .getRepository(ctx, MyparcelConfigEntity)
      .findOne({ where: { apiKey } });
    if (!config) {
      throw new MyParcelError(`No config found for apiKey ${apiKey}`);
    }
    return config;
  }
  async getAllConfigs(ctx: RequestContext): Promise<MyparcelConfigEntity[]> {
    const configs = await this.connection
      .getRepository(ctx, MyparcelConfigEntity)
      .find();
    return configs || [];
  }
  async updateStatus(
    ctx: RequestContext,
    channelId: string,
    shipmentId: string,
    status: number
  ): Promise<void> {
    const fulfillmentReference = this.getFulfillmentReference(shipmentId);
    const channel = await this.connection
      .getRepository(ctx, Channel)
      .findOneOrFail({ where: { id: ctx.channelId } });
    const fulfillment = await this.connection
      .getRepository(ctx, Fulfillment)
      .findOne({ where: { method: fulfillmentReference } });
    if (!fulfillment) {
      return Logger.warn(
        `No fulfillment found with method ${fulfillmentReference} for channel with id ${ctx.channelId}`,
        loggerCtx
      );
    }
    const fulfillmentStatus = myparcelStatusses[status];
    if (!fulfillmentStatus) {
      return Logger.info(
        `No fulfillmentStatus found for myparcelStatus ${status}, not updating fulfillment ${shipmentId}`,
        loggerCtx
      );
    }
    await this.fulfillmentService.transitionToState(
      ctx,
      fulfillment.id,
      fulfillmentStatus
    );
    Logger.info(
      `Updated fulfillment ${fulfillmentReference} to ${fulfillmentStatus}`,
      loggerCtx
    );
  }
  async createShipments(
    ctx: RequestContext,
    orders: Order[],
    customsContent: string
  ): Promise<string> {
    const config = await this.getConfig(ctx);
    if (!config) {
      throw new MyParcelError(`No config found for channel ${ctx.channelId}`);
    }
    await Promise.all(
      orders.map((order) =>
        this.hydrator.hydrate(ctx, order, {
          relations: ['customer', 'lines.productVariant.product'],
        })
      )
    );
    const shipments = this.toShipment(orders, customsContent);
    const res = await this.request('shipments', 'POST', config.apiKey, {
      shipments,
    });
    const id = res.data?.ids?.[0]?.id;
    return this.getFulfillmentReference(id);
  }
  toShipment(orders: Order[], customsContent: string): MyparcelShipment[] {
    return orders.map((order) => {
      Logger.info(`Creating shipment for ${order.code}`, loggerCtx);
      const address: OrderAddress = order.shippingAddress;
      const shipment = this.config.shipmentStrategy.getShipment(
        address,
        order,
        customsContent
      );
      if (customsContent) {
        const items = order.lines.map((line) =>
          this.getCustomsItem(line, order.currencyCode)
        );
        const totalWeight = items.reduce(
          (acc, curr) => curr.weight * curr.amount + acc,
          0
        );
        shipment.physical_properties = {
          weight: totalWeight,
        };
        shipment.customs_declaration = {
          contents: parseInt(customsContent),
          invoice: order.code,
          weight: totalWeight,
          items,
        };
      }
      return shipment;
    });
  }
  private getCustomsItem(line: OrderLine, currencyCode: string): CustomsItem {
    if (!this.config.getCustomsInformationFn) {
      throw new UserInputError(
        `No "getCustomsInformationFn" configured. Can not create customs information`
      );
    }
    const { classification, countryCodeOfOrigin, weightInGrams } =
      this.config.getCustomsInformationFn(line);
    const name =
      line.productVariant.product.translations.find(
        (t) => t.languageCode === LanguageCode.en
      )?.name || line.productVariant.product.translations[0].name;
    return {
      description: name,
      amount: line.quantity,
      weight: weightInGrams,
      item_value: {
        amount: line.proratedLinePriceWithTax,
        currency: currencyCode,
      },
      classification,
      country: countryCodeOfOrigin,
    };
  }
  private getFulfillmentReference(shipmentId: string | number): string {
    return `MyParcel ${shipmentId}`;
  }
  private async request(
    path: 'shipments' | 'webhook_subscriptions' | 'drop_off_points' | string,
    method: 'GET' | 'POST',
    apiKey: string,
    body?: unknown
  ): Promise<MyparcelResponse> {
    const shipmentContentType =
      'application/vnd.shipment+json;version=1.1;charset=utf-8';
    const defaultContentType = 'application/json';
    const contentType =
      path === 'shipments' ? shipmentContentType : defaultContentType;
    const buff = Buffer.from(apiKey);
    const encodedKey = buff.toString('base64');
    const headers = {
      Authorization: `basic ${encodedKey}`,
      'Content-Type': contentType,
      'User-Agent': 'CustomApiCall/2',
    };
    try {
      if (method === 'POST') {
        const res = await this.client.post(
          path,
          {
            data: body,
          },
          {
            headers,
          }
        );
        return res.data;
      } else {
        const res = await this.client.get(path, {
          headers,
        });
        return res.data;
      }
    } catch (err: any) {
      if (err.response?.status >= 400 && err.response?.status < 500) {
        const errorMessage = this.getReadableError(err.response.data);
        Logger.warn(err.response.data, loggerCtx);
        throw errorMessage ? new MyParcelError(errorMessage) : err;
      } else {
        Logger.warn(err.response, loggerCtx);
        throw err;
      }
    }
  }
  private getReadableError(data: MyparcelErrorResponse): string | undefined {
    const error = Object.values(data.errors?.[0] || {}).find(
      (value) => value?.human?.[0]
    );
    return error?.human?.[0];
  }
}
export interface WebhookSubscription {
  url: string;
  hook: string;
}
export interface MyparcelResponse {
  data: any;
}
export interface MyparcelErrorResponse {
  errors: MyparcelError[];
  message: string;
}
export interface MyparcelError {
  [key: string]: {
    fields: string[];
    human: string[];
  };
}
export interface MyparcelStatusChangeEvent {
  data: {
    hooks: [
      {
        shipment_id: string;
        account_id: number;
        shop_id: number;
        status: number;
        barcode: string;
        shipment_reference_identifier: string;
      }
    ];
  };
}
export const myparcelStatusses: { [key: string]: FulfillmentState } = {
  1: 'Pending',
  2: 'Pending',
  3: 'Shipped',
  4: 'Shipped',
  5: 'Shipped',
  6: 'Shipped',
  7: 'Delivered',
  8: 'Delivered',
  9: 'Delivered',
  10: 'Delivered',
  11: 'Delivered',
  32: 'Shipped',
  33: 'Shipped',
  34: 'Shipped',
  35: 'Shipped',
  36: 'Delivered',
  37: 'Delivered',
  38: 'Delivered',
  99: 'Delivered',
};
```

## File: packages/vendure-plugin-myparcel/src/api/myparcel.shop.graphql.ts

```typescript
import { Args, Query, Resolver } from '@nestjs/graphql';
import { Ctx, RequestContext } from '@vendure/core';
import { MyparcelService } from './myparcel.service';
import {
  MyparcelDropOffPoint,
  MyparcelDropOffPointInput,
} from '../generated/graphql';
import gql from 'graphql-tag';
export const shopSchema = gql`
  type MyparcelDropOffPoint {
    location_code: String!
    location_name: String!
    city: String!
    postal_code: String!
    street: String!
    number: String!
    number_suffix: String
    phone: String
    reference: String
    longitude: String
    latitude: String
    available_days: [Int!]!
    cut_off_time: String
    carrier_id: Int
    distance: Int
  }
  input MyparcelDropOffPointInput {
    carrierId: String
    countryCode: String
    postalCode: String!
  }
  extend type Query {
    myparcelDropOffPoints(
      input: MyparcelDropOffPointInput!
    ): [MyparcelDropOffPoint!]!
  }
`;
@Resolver()
export class MyParcelShopResolver {
  constructor(private service: MyparcelService) {}
  @Query()
  async myparcelDropOffPoints(
    @Ctx() ctx: RequestContext,
    @Args('input') input: MyparcelDropOffPointInput
  ): Promise<MyparcelDropOffPoint[]> {
    return this.service.getDropOffPoints(ctx, input);
  }
}
```

## File: packages/vendure-plugin-myparcel/src/api/types.ts

```typescript
import { Order, OrderLine } from '@vendure/core';
import { OrderAddress } from '@vendure/common/lib/generated-types';
import { GraphQLError } from 'graphql';
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export interface MyparcelConfig {
  vendureHost: string;
  syncWebhookOnStartup?: boolean;
  getCustomsInformationFn?: (orderLine: OrderLine) => CustomsInformation;
  shipmentStrategy: MyParcelShipmentStrategy;
}
export interface CustomsInformation {
  weightInGrams: number;
  classification: string;
  countryCodeOfOrigin: string;
}
export interface MyparcelRecipient {
  cc: string;
  region?: string;
  city: string;
  street: string;
  number: string;
  number_suffix?: string;
  postal_code: string;
  person: string;
  phone?: string;
  email?: string;
}
export interface MyparcelShipmentOptions {
  package_type: number;
  label_description?: string;
}
export interface CustomsDeclaration {
  contents: string | number;
  invoice: string;
  weight: number;
  items: CustomsItem[];
}
export interface ItemValue {
  amount: number;
  currency: string;
}
export interface CustomsItem {
  description: string;
  amount: number;
  weight: number;
  item_value: ItemValue;
  classification: string;
  country: string;
}
export interface MyparcelShipment {
  carrier: number;
  reference_identifier?: string;
  recipient: MyparcelRecipient;
  options: MyparcelShipmentOptions;
  customs_declaration?: CustomsDeclaration;
  physical_properties?: {
    weight: number;
  };
}
export interface MyParcelShipmentStrategy {
  getShipment: (
    address: OrderAddress,
    order: Order,
    customsContent: string
  ) => MyparcelShipment;
}
export class MyParcelError extends GraphQLError {
  constructor(message: string) {
    super(message, { extensions: { code: 'MY_PARCEL_ERROR' } });
  }
}
```

## File: packages/vendure-plugin-myparcel/src/ui/myparcel-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
@NgModule({
  imports: [SharedModule],
  providers: [
    addNavMenuItem(
      {
        id: 'Myparcel',
        label: 'MyParcel',
        routerLink: ['/extensions/myparcel'],
        icon: 'bundle',
        requiresPermission: 'SetMyparcelConfig',
      },
      'settings'
    ),
  ],
})
export class MyparcelNavModule {}
```

## File: packages/vendure-plugin-myparcel/src/ui/myparcel.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { DataService, NotificationService } from '@vendure/admin-ui/core';
import { getMyparcelConfig, updateMyparcelConfig } from './queries';
@Component({
  selector: 'myparcel-component',
  template: `
    <div class="clr-row">
      <div class="clr-col">
        <form class="form" [formGroup]="form">
          <section class="form-block">
            <vdr-form-field label="MyParcel apikey" for="apiKey">
              <input id="apiKey" type="text" formControlName="apiKey" />
            </vdr-form-field>
            <button
              class="btn btn-primary"
              (click)="save()"
              [disabled]="form.invalid || form.pristine"
            >
              Save
            </button>
          </section>
        </form>
      </div>
    </div>
  `,
})
export class MyparcelComponent implements OnInit {
  form: FormGroup;
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService
  ) {
    this.form = this.formBuilder.group({
      apiKey: ['your-api-key'],
    });
  }
  async ngOnInit(): Promise<void> {
    await this.dataService
      .query(getMyparcelConfig)
      .mapStream((d: any) => d.myparcelConfig)
      .subscribe((config) =>
        this.form.controls['apiKey'].setValue(config.apiKey)
      );
  }
  async save(): Promise<void> {
    try {
      if (this.form.dirty) {
        const formValue = this.form.value;
        await this.dataService
          .mutate(updateMyparcelConfig, { input: { apiKey: formValue.apiKey } })
          .toPromise();
      }
      this.form.markAsPristine();
      this.changeDetector.markForCheck();
      this.notificationService.success('common.notify-update-success', {
        entity: 'MyparcelConfig',
      });
    } catch (e) {
      this.notificationService.error('common.notify-update-error', {
        entity: 'MyparcelConfig',
      });
    }
  }
}
```

## File: packages/vendure-plugin-myparcel/src/ui/myparcel.module.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
import { MyparcelComponent } from './myparcel.component';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: MyparcelComponent,
        data: { breadcrumb: 'MyParcel' },
      },
    ]),
  ],
  providers: [
    addNavMenuItem(
      {
        id: 'myparcel',
        label: 'MyParcel',
        routerLink: ['/extensions/myparcel'],
        icon: 'cursor-hand-open',
      },
      'settings'
    ),
  ],
  declarations: [MyparcelComponent],
})
export class MyparcelModule {}
```

## File: packages/vendure-plugin-myparcel/src/ui/queries.ts

```typescript
import gql from 'graphql-tag';
export const updateMyparcelConfig = gql`
  mutation updateMyparcelConfig($input: MyparcelConfigInput!) {
    updateMyparcelConfig(input: $input) {
      apiKey
    }
  }
`;
export const getMyparcelConfig = gql`
  query myparcelConfig {
    myparcelConfig {
      apiKey
    }
  }
`;
```

## File: packages/vendure-plugin-myparcel/src/constants.ts

```typescript
export const loggerCtx = 'MyParcelPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('MYPARCEL_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-myparcel/src/index.ts

```typescript
export * from './api/myparcel.handler';
export * from './myparcel.plugin';
export * from './api/types';
export * from './api/myparcel-default-shipment.strategy';
```

## File: packages/vendure-plugin-myparcel/src/myparcel.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { MyparcelConfigEntity } from './api/myparcel-config.entity';
import {
  MyparcelAdminResolver,
  adminSchema,
  myparcelPermission,
} from './api/myparcel.admin.graphql';
import { MyparcelController } from './api/myparcel.controller';
import { myparcelHandler } from './api/myparcel.handler';
import { MyparcelService } from './api/myparcel.service';
import { MyParcelShopResolver, shopSchema } from './api/myparcel.shop.graphql';
import { MyparcelConfig, PartialBy } from './api/types';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { MyParcalDefaultShipmentStrategy } from './api/myparcel-default-shipment.strategy';
@VendurePlugin({
  imports: [PluginCommonModule],
  entities: [MyparcelConfigEntity],
  providers: [
    MyparcelService,
    { provide: PLUGIN_INIT_OPTIONS, useFactory: () => MyparcelPlugin.config },
  ],
  controllers: [MyparcelController],
  adminApiExtensions: {
    schema: adminSchema,
    resolvers: [MyparcelAdminResolver],
  },
  shopApiExtensions: {
    schema: shopSchema,
    resolvers: [MyParcelShopResolver],
  },
  configuration: (config) => {
    config.shippingOptions.fulfillmentHandlers.push(myparcelHandler);
    config.authOptions.customPermissions.push(myparcelPermission);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class MyparcelPlugin {
  static config: MyparcelConfig;
  static init(
    config: PartialBy<MyparcelConfig, 'shipmentStrategy'>
  ): typeof MyparcelPlugin {
    this.config = {
      ...config,
      shipmentStrategy:
        config.shipmentStrategy ?? new MyParcalDefaultShipmentStrategy(),
    };
    return MyparcelPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'myparcel',
        ngModuleFileName: 'myparcel.module.ts',
        ngModuleName: 'MyparcelModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'myparcel-nav.module.ts',
        ngModuleName: 'MyparcelNavModule',
      },
    ],
  };
}
export interface MyParcelApiKeys {
  [key: string]: string;
}
```

## File: packages/vendure-plugin-myparcel/test/dev-server.ts

```typescript
import { initialData } from '../../test/src/initial-data';
import { MyparcelPlugin } from '../src/myparcel.plugin';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  ChannelService,
  DefaultLogger,
  DefaultSearchPlugin,
  LanguageCode,
  LogLevel,
  mergeConfig,
  PaymentMethodService,
  RequestContext,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  addItem,
  addPaymentToOrder,
  proceedToArrangingPayment,
} from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { addShippingMethod } from '../../test/src/admin-utils';
import localtunnel from 'localtunnel';
import { MyparcelService } from '../src/api/myparcel.service';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
require('dotenv').config();
(async () => {
  const tunnel = await localtunnel({ port: 3050 });
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: true,
      shopApiPlayground: true,
    },
    customFields: {
      Product: [
        {
          name: 'weight',
          label: [{ value: 'Weight', languageCode: LanguageCode.en }],
          type: 'int',
          ui: { component: 'text-form-input' },
        },
      ],
    },
    plugins: [
      MyparcelPlugin.init({
        vendureHost: tunnel.url,
        getCustomsInformationFn: (orderLine) => {
          return {
            weightInGrams:
              (orderLine.productVariant.product.customFields as any)?.weight ||
              0,
            classification:
              (orderLine.productVariant.product.customFields as any)?.hsCode ||
              '0181',
            countryCodeOfOrigin: 'NL',
          };
        },
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [MyparcelPlugin.ui],
          devMode: true,
        }),
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  const channel = await server.app.get(ChannelService).getDefaultChannel();
  const ctx = new RequestContext({
    apiType: 'admin',
    isAuthorized: true,
    authorizedAsOwnerOnly: false,
    channel,
  });
  await server.app
    .get(MyparcelService)
    .upsertConfig(ctx, process.env.MYPARCEL_APIKEY!);
  await server.app.get(PaymentMethodService).create(ctx, {
    code: 'test-payment-method',
    enabled: true,
    handler: {
      code: 'test-payment-method',
      arguments: [],
    },
    translations: [
      {
        name: 'test',
        description: '',
        languageCode: LanguageCode.en_US,
      },
    ],
  });
  // Add a test-order at every server start
  await addShippingMethod(adminClient, 'my-parcel');
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  await addItem(shopClient, 'T_1', 1);
  await addItem(shopClient, 'T_2', 2);
  await proceedToArrangingPayment(shopClient, 3, {
    input: {
      fullName: 'Martinho Pinelabio',
      streetLine1: 'Black Bear Rd',
      streetLine2: '14841',
      city: 'West Palm Beach, Florida',
      postalCode: '33419',
      countryCode: 'US',
    },
  });
  await addPaymentToOrder(shopClient, testPaymentMethod.code);
  console.log('Created test order');
})();
```

## File: packages/vendure-plugin-myparcel/test/e2e.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import {
  Channel,
  ChannelService,
  DefaultLogger,
  LogLevel,
  mergeConfig,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { initialData } from '../../test/src/initial-data';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import {
  addItem,
  addPaymentToOrder,
  proceedToArrangingPayment,
} from '../../test/src/shop-utils';
import {
  addShippingMethod,
  fulfill,
  getOrder,
} from '../../test/src/admin-utils';
import nock from 'nock';
import {
  MyparcelService,
  MyparcelShipment,
  MyparcelStatusChangeEvent,
  WebhookSubscription,
} from '../src/api/myparcel.service';
import { Fulfillment } from '@vendure/common/lib/generated-types';
import axios from 'axios';
import { MyparcelPlugin } from '../src';
import { getMyparcelConfig, updateMyparcelConfig } from '../src/ui/queries';
import fs from 'fs';
import path from 'path';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import gql from 'graphql-tag';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
type OutgoingMyparcelShipment = { data: { shipments: MyparcelShipment[] } };
type OutgoingWebhookSubscription = {
  data: { webhook_subscriptions: WebhookSubscription[] };
};
const apiKey = 'test-api-key';
describe('MyParcel', () => {
  let shopClient: SimpleGraphQLClient;
  let adminClient: SimpleGraphQLClient;
  let server: TestServer;
  let fulfillment: Fulfillment;
  let orderId: string;
  const address = {
    input: {
      fullName: 'Martinho Pinelabio',
      streetLine1: 'Verzetsstraat',
      streetLine2: '12a',
      city: 'Liwwa',
      postalCode: '8923CP',
      countryCode: 'NL',
    },
  };
  const myparcelRes = {
    data: {
      ids: [
        {
          id: 110913193,
          reference_identifier: 'FOO-222-BAR-42',
        },
      ],
    },
  };
  let contentType: string | undefined;
  let body: OutgoingWebhookSubscription | undefined;
  nock('https://api.myparcel.nl/')
    .persist()
    .post('/webhook_subscriptions', (reqBody) => {
      body = reqBody;
      return true;
    })
    .matchHeader('Content-Type', (val) => {
      contentType = val;
      return true;
    })
    .reply(200, myparcelRes);
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const devConfig = mergeConfig(testConfig, {
      apiOptions: {
        port: 3051,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        MyparcelPlugin.init({
          vendureHost: 'https://test-webhook.com',
          getCustomsInformationFn: (orderLine) => {
            return {
              weightInGrams: 30,
              classification: 'mock classification code',
              countryCodeOfOrigin: 'NL',
            };
          },
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    const env = createTestEnvironment(devConfig);
    shopClient = env.shopClient;
    adminClient = env.adminClient;
    server = env.server;
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
  }, 60000);
  it('Adds apiKey via Graphql mutation', async () => {
    await adminClient.asSuperAdmin();
    const config = await adminClient.query(updateMyparcelConfig, {
      input: { apiKey },
    });
    expect(config.updateMyparcelConfig.apiKey).toEqual(apiKey);
  });
  it('Retrieves apiKey via Graphql query', async () => {
    await adminClient.asSuperAdmin();
    const config = await adminClient.query(getMyparcelConfig);
    expect(config.myparcelConfig.apiKey).toEqual(apiKey);
  });
  it('Created webhook on startup', async () => {
    const ctx = await getSuperadminContext(server.app);
    await server.app.get(MyparcelService).setWebhooksForAllChannels(ctx);
    const webhook = body?.data?.webhook_subscriptions?.[0];
    expect(webhook?.url).toEqual(
      'https://test-webhook.com/myparcel/update-status'
    );
    expect(webhook?.hook).toEqual('shipment_status_change');
    expect(contentType).toEqual('application/json');
  });
  it('Returns drop off points', async () => {
    nock('https://api.myparcel.nl/')
      .get('/drop_off_points?postal_code=8923CP&limit=30&carried_id=1')
      .reply(200, {
        data: {
          drop_off_points: [
            {
              carrier_id: 1,
            },
          ],
        },
      });
    const { myparcelDropOffPoints: res } = await shopClient.query(gql`
      query {
        myparcelDropOffPoints(input: { carrierId: "1", postalCode: "8923CP" }) {
          carrier_id
        }
      }
    `);
    expect(res.length).toEqual(1);
    expect(res?.[0].carrier_id).toEqual(1);
  });
  it('Setup order untill payment', async () => {
    await addShippingMethod(adminClient, 'my-parcel');
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    await addItem(shopClient, 'T_1', 1);
    await addItem(shopClient, 'T_2', 2);
    await proceedToArrangingPayment(shopClient, 3, address);
    const order = await addPaymentToOrder(shopClient, testPaymentMethod.code);
    orderId = (order as any).id;
    expect(shopClient).toBeDefined();
  });
  it('Fulfill order with MyParcel', async () => {
    let body: OutgoingMyparcelShipment | undefined;
    let contentType = undefined;
    nock('https://api.myparcel.nl/')
      .post('/shipments', (reqBody) => {
        body = reqBody;
        return true;
      })
      .matchHeader('Content-Type', (val: any) => {
        contentType = val;
        return true;
      })
      .reply(200, myparcelRes);
    fulfillment = await fulfill(
      adminClient,
      'my-parcel',
      [
        ['T_1', 1],
        ['T_2', 2],
      ],
      [
        {
          name: 'customsContents',
          value: '1',
        },
      ]
    );
    const shipment = body?.data?.shipments?.[0];
    expect(fulfillment.state).toEqual('Pending');
    expect(shipment?.carrier).toEqual(1);
    expect(shipment?.recipient.city).toEqual('Liwwa');
    expect(shipment?.recipient.street).toEqual('Verzetsstraat');
    expect(shipment?.recipient.number).toEqual('12');
    expect(shipment?.recipient.number_suffix).toEqual('a');
    expect(shipment?.recipient.postal_code).toEqual('8923CP');
    expect(shipment?.recipient.email).toEqual('hayden.zieme12@hotmail.com');
    expect(shipment?.recipient.cc).toEqual('NL');
    expect(contentType).toEqual(
      'application/vnd.shipment+json;version=1.1;charset=utf-8'
    );
    // Customs information
    expect(shipment?.physical_properties?.weight).toEqual(30 * 3);
    expect(shipment?.customs_declaration?.weight).toEqual(30 * 3);
    expect(
      shipment?.customs_declaration?.items.every((i) => i.weight === 30)
    ).toBeTruthy();
    expect(
      shipment?.customs_declaration?.items.every(
        (i) => i.classification === 'mock classification code'
      )
    ).toBeTruthy();
    expect(
      shipment?.customs_declaration?.items.every((i) => i.country === 'NL')
    ).toBeTruthy();
    expect(shipment?.customs_declaration?.contents).toEqual(1);
  });
  it('Updates to Shipped after status change webhook', async () => {
    await postStatusChange(fulfillment.method, 3);
    const order = await getOrder(adminClient, orderId);
    expect(order?.fulfillments?.[0]?.state).toEqual('Shipped');
  });
  it('Updates to Delivered after status change webhook', async () => {
    await postStatusChange(fulfillment.method, 7);
    const order = await getOrder(adminClient, orderId);
    expect(order?.fulfillments?.[0]?.state).toEqual('Delivered');
  });
  it('Removes apiKey via Graphql mutation', async () => {
    await adminClient.asSuperAdmin();
    const config = await adminClient.query(updateMyparcelConfig, {
      input: { apiKey: undefined },
    });
    expect(config.updateMyparcelConfig).toEqual(null);
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(__dirname, MyparcelPlugin.ui);
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
export async function postStatusChange(
  fulfillmentReference: string,
  status: number
): Promise<void> {
  const shipmentId = fulfillmentReference.replace(`MyParcel `, '');
  let buff = Buffer.from(apiKey);
  let encodedKey = buff.toString('base64');
  await axios.post(
    'http://localhost:3051/myparcel/update-status',
    <MyparcelStatusChangeEvent>{
      data: {
        hooks: [
          {
            shipment_id: shipmentId,
            status,
          },
        ],
      },
    },
    {
      headers: { 'X-MyParcel-Authorization': encodedKey },
    }
  );
}
```

## File: packages/vendure-plugin-myparcel/vitest.config.ts

```typescript
import path from 'path';
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    include: ['./test/e2e.spec.ts'],
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-order-export/src/api/export-strategy.ts

```typescript
import {
  Injector,
  InternalServerError,
  Logger,
  OrderService,
  RequestContext,
} from '@vendure/core';
import os from 'os';
import path from 'path';
import { createObjectCsvWriter } from 'csv-writer';
import { loggerCtx } from '../constants';
export interface ExportInput {
  ctx: RequestContext;
  orderService: OrderService;
  startDate: Date;
  endDate: Date;
}
export interface ExportStrategy {
  readonly name: string;
  readonly contentType: string;
  readonly fileExtension: string;
  createExportFile(input: ExportInput): Promise<string>;
}
interface OrderRow {
  code: string;
  placedAt: string;
  total: string;
  totalWithTax: string;
  [key: number]: string | number;
}
export class DefaultExportStrategy implements ExportStrategy {
  readonly name = 'example-export';
  readonly contentType = 'text/csv';
  readonly fileExtension = 'csv';
  async createExportFile({
    ctx,
    startDate,
    endDate,
    orderService,
  }: ExportInput): Promise<string> {
    const orders = await orderService.findAll(ctx, {
      filter: {
        orderPlacedAt: {
          between: {
            start: startDate,
            end: endDate,
          },
        },
      },
    });
    if (orders.totalItems > orders.items.length) {
      throw new InternalServerError(
        'Too many orders, getting paginated orders is not implemented.'
      );
    }
    Logger.info(`Exporting ${orders.items.length} orders`, loggerCtx);
    const rows: OrderRow[] = orders.items.map((order) => ({
      code: order.code,
      placedAt: order.orderPlacedAt?.toDateString() || '',
      total: this.formatCurrency(order.total),
      totalWithTax: this.formatCurrency(order.totalWithTax),
    }));
    // Write to file
    const fileName = `${new Date().getTime()}-${startDate.getTime()}-${endDate.getTime()}.${
      this.fileExtension
    }`;
    const exportFile = path.join(os.tmpdir(), fileName);
    const csvWriter = createObjectCsvWriter({
      path: exportFile,
      header: [
        { id: 'code', title: 'order' },
        { id: 'placedAt', title: 'date' },
        { id: 'total', title: 'total' },
        { id: 'totalWithTax', title: 'totalWithTax' },
      ],
    });
    await csvWriter.writeRecords(rows);
    return exportFile;
  }
  private formatCurrency(value: number): string {
    return (value / 100).toFixed(2);
  }
}
```

## File: packages/vendure-plugin-order-export/src/api/order-export.controller.ts

```typescript
import {
  Allow,
  Ctx,
  Logger,
  OrderService,
  RequestContext,
  PermissionDefinition,
} from '@vendure/core';
import { ExportPluginConfig } from '..';
import {
  ArgumentMetadata,
  Controller,
  Get,
  Inject,
  Param,
  PipeTransform,
  Query,
  Res,
  UnprocessableEntityException,
} from '@nestjs/common';
import { Resolver, Query as GraphqlQuery } from '@nestjs/graphql';
import { Response } from 'express';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import * as fs from 'fs';
import { promises as promisedFs } from 'fs';
export class ParseDatePipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (!value) {
      throw new UnprocessableEntityException(`Date is required`);
    }
    return new Date(value);
  }
}
export const orderExportPermission = new PermissionDefinition({
  name: 'ExportOrders',
  description: 'Allows administrator to export orders',
});
@Controller('export-orders')
export class OrderExportController {
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS) private config: ExportPluginConfig,
    private orderService: OrderService
  ) {}
  @Allow(orderExportPermission.Permission)
  @Get('/export/:strategy')
  async downloadMultipleInvoices(
    @Ctx() ctx: RequestContext,
    @Param('strategy') strategyName: string,
    @Query('startDate', new ParseDatePipe()) startDate: Date,
    @Query('endDate', new ParseDatePipe()) endDate: Date,
    @Res() res: Response
  ) {
    if (!ctx.channelId) {
      throw Error(`Channel id is needed to export orders`);
    }
    const strategy = this.config.exportStrategies.find(
      (strategy) => strategy.name === strategyName
    );
    if (!strategy) {
      throw new UnprocessableEntityException(
        `No strategy named '${strategyName}' configured`
      );
    }
    Logger.info(
      `Exporting orders for user ${
        ctx.activeUserId
      } from ${startDate.toDateString()} to ${endDate.toDateString()} with strategy ${strategyName}`,
      loggerCtx
    );
    const filePath = await strategy.createExportFile({
      ctx,
      startDate,
      endDate,
      orderService: this.orderService,
    });
    const readStream = fs.createReadStream(filePath);
    res.set({
      'Content-Type': strategy.contentType,
      'Content-Disposition': `inline; filename=order-export.${strategy.fileExtension}`,
    });
    Logger.info(`Exported orders`, loggerCtx);
    readStream.on('end', async () => {
      Logger.info(`Export downloaded, deleting file ${filePath}`, loggerCtx);
      await promisedFs.unlink(filePath);
    });
    readStream.pipe(res);
  }
}
@Resolver()
export class OrderExportResolver {
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS) private config: ExportPluginConfig
  ) {}
  @Allow(orderExportPermission.Permission)
  @GraphqlQuery()
  availableOrderExportStrategies(): string[] {
    return this.config.exportStrategies.map((strategy) => strategy.name);
  }
}
```

## File: packages/vendure-plugin-order-export/src/ui/order-export-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
@NgModule({
  imports: [SharedModule],
  providers: [
    addNavMenuItem(
      {
        id: 'export-orders',
        label: 'Export orders',
        routerLink: ['/extensions/export-orders'],
        icon: 'download',
        requiresPermission: 'ExportOrders',
      },
      'sales'
    ),
  ],
})
export class OrderExportNavModule {}
```

## File: packages/vendure-plugin-order-export/src/ui/order-export.component.ts

```typescript
import { Component, OnInit, ViewEncapsulation } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import {
  DataService,
  getServerLocation,
  LocalStorageService,
  NotificationService,
} from '@vendure/admin-ui/core';
import gql from 'graphql-tag';
@Component({
  encapsulation: ViewEncapsulation.None,
  selector: 'order-export-component',
  styles: ['.time-picker { display: none !important; }'],
  template: `
    <div class="page-block">
      <h1 class="mb-2">Export orders</h1>
      <form class="form" [formGroup]="form" id="export-form">
        <section class="form-block">
          <div class="flex">
            <div>
              <label>{{ 'common.start-date' | translate }}</label>
              <vdr-datetime-picker
                required
                timeGranularityInterval="60"
                formControlName="startsAt"
              ></vdr-datetime-picker>
            </div>
            <div>
              <label>{{ 'common.end-date' | translate }}</label>
              <vdr-datetime-picker
                required
                timeGranularityInterval="60"
                formControlName="endsAt"
              ></vdr-datetime-picker>
            </div>
          </div>
          <br />
          <clr-select-container>
            <label>Export as</label>
            <select
              clrSelect
              name="options"
              formControlName="strategy"
              required
            >
              <option *ngFor="let strategy of strategies" [value]="strategy">
                {{ strategy }}
              </option>
            </select>
          </clr-select-container>
          <br />
          <button
            class="btn btn-primary"
            [disabled]="form.invalid || form.pristine"
            (click)="download()"
          >
            Export
          </button>
        </section>
      </form>
    </div>
  `,
})
export class OrderExportComponent implements OnInit {
  form: FormGroup;
  serverPath: string;
  strategies: string[] = [];
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private notificationService: NotificationService,
    private localStorageService: LocalStorageService
  ) {
    this.form = this.formBuilder.group({
      startsAt: null,
      endsAt: null,
      strategy: null,
    });
    this.serverPath = getServerLocation();
  }
  ngOnInit(): void {
    this.dataService
      .query(
        gql`
          query availableOrderExportStrategies {
            availableOrderExportStrategies
          }
        `
      )
      .single$.subscribe((result: any) => {
        this.strategies = result.availableOrderExportStrategies;
        this.form.controls['strategy'].setValue(this.strategies?.[0]);
      });
  }
  async download(): Promise<void> {
    try {
      const res = await fetch(
        `${this.serverPath}/export-orders/export/${this.form.value.strategy}?startDate=${this.form.value.startsAt}&endDate=${this.form.value.endsAt}`,
        {
          headers: this.getHeaders(),
        }
      );
      if (!res.ok) {
        const json = await res.json();
        throw Error(json?.message);
      }
      const header = res.headers.get('Content-Disposition');
      const parts = header!.split(';');
      const filename = parts[1].split('=')[1];
      const blob = await res.blob();
      await this.downloadBlob(blob, filename);
    } catch (err: any) {
      console.error(err);
      this.notificationService.error(err.message);
    }
  }
  private getHeaders(): Record<string, string> {
    const headers: Record<string, string> = {};
    const channelToken = this.localStorageService.get('activeChannelToken');
    if (channelToken) {
      headers['vendure-token'] = channelToken;
    }
    const authToken = this.localStorageService.get('authToken');
    if (authToken) {
      headers.authorization = `Bearer ${authToken}`;
    }
    return headers;
  }
  private async downloadBlob(blob: Blob, fileName: string): Promise<void> {
    const blobUrl = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    document.body.appendChild(a);
    a.setAttribute('hidden', 'true');
    a.href = blobUrl;
    a.download = fileName;
    a.setAttribute('target', '_blank');
    a.click();
  }
}
```

## File: packages/vendure-plugin-order-export/src/ui/order-export.module.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { SharedModule } from '@vendure/admin-ui/core';
import { OrderExportComponent } from './order-export.component';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: OrderExportComponent,
        data: { breadcrumb: 'Export orders' },
        title: 'Export orders',
      },
    ]),
  ],
  providers: [],
  declarations: [OrderExportComponent],
})
export class OrderExportModule {}
```

## File: packages/vendure-plugin-order-export/src/constants.ts

```typescript
export const loggerCtx = 'OrderExportPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('ORDEREXPORT_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-order-export/src/index.ts

```typescript
export * from './order-export.plugin';
export * from './api/export-strategy';
```

## File: packages/vendure-plugin-order-export/src/order-export.plugin.ts

```typescript
import { PluginCommonModule, Type, VendurePlugin } from '@vendure/core';
import path from 'path';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import {
  OrderExportController,
  OrderExportResolver,
  orderExportPermission,
} from './api/order-export.controller';
import { DefaultExportStrategy } from './index';
import { ExportStrategy } from './api/export-strategy';
import { PLUGIN_INIT_OPTIONS } from './constants';
import gql from 'graphql-tag';
export interface ExportPluginConfig {
  exportStrategies: ExportStrategy[];
}
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => OrderExportPlugin.config,
    },
  ],
  adminApiExtensions: {
    resolvers: [OrderExportResolver],
    schema: gql`
      extend type Query {
        availableOrderExportStrategies: [String!]!
      }
    `,
  },
  controllers: [OrderExportController],
  configuration: (config) => {
    config.authOptions.customPermissions.push(orderExportPermission);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class OrderExportPlugin {
  static config: ExportPluginConfig;
  static init(config: ExportPluginConfig): Type<OrderExportPlugin> {
    if (!config.exportStrategies?.length) {
      config.exportStrategies.push(new DefaultExportStrategy());
    }
    OrderExportPlugin.config = config;
    return this;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'export-orders',
        ngModuleFileName: 'order-export.module.ts',
        ngModuleName: 'OrderExportModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'order-export-nav.module.ts',
        ngModuleName: 'OrderExportNavModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-order-export/test/dev-server.ts

```typescript
import { createSettledOrder } from '../../test/src/shop-utils';
require('dotenv').config();
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import * as path from 'path';
import { DefaultExportStrategy, OrderExportPlugin } from '../src';
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    plugins: [
      DefaultSearchPlugin,
      OrderExportPlugin.init({
        exportStrategies: [new DefaultExportStrategy()],
      }),
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [OrderExportPlugin.ui],
          devMode: true,
        }),
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
})();
```

## File: packages/vendure-plugin-order-export/test/order-export.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import { TestServer } from '@vendure/testing/lib/test-server';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { createSettledOrder } from '../../test/src/shop-utils';
import gql from 'graphql-tag';
import { OrderExportPlugin } from '../src';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
describe('Order export plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3105,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        OrderExportPlugin.init({
          exportStrategies: [],
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
    });
    await createSettledOrder(shopClient, 1);
    await createSettledOrder(shopClient, 1);
    await createSettledOrder(shopClient, 1);
    serverStarted = true;
  }, 60000);
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Should fetch available strategies', async () => {
    await adminClient.asSuperAdmin();
    const result = await adminClient.query(
      gql`
        query availableOrderExportStrategies {
          availableOrderExportStrategies
        }
      `
    );
    await expect(result.availableOrderExportStrategies.length).toBe(1);
  });
  it('Should fetch export file', async () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    await adminClient.asSuperAdmin();
    const res = await adminClient.fetch(
      `http:
    );
    expect(res.status).toBe(200);
    expect(res.headers.get('Content-type')).toContain('text/csv');
    expect(res.body.pipe).toBeDefined();
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        OrderExportPlugin.ui
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(() => {
    return server.destroy();
  }, 50000);
});
```

## File: packages/vendure-plugin-order-pdfs/src/api/file.util.ts

```typescript
import * as tmp from 'tmp';
import AdmZip = require('adm-zip');
import fs from 'fs/promises';
import { Logger } from '@vendure/core';
import { loggerCtx } from '../constants';
export interface ZippableFile {
  name: string;
  path: string;
}
export async function createTempFile(postfix: string): Promise<string> {
  return await new Promise((resolve, reject) => {
    tmp.file({ postfix }, (err, path, fd, cleanupCallback) => {
      if (err) {
        reject(err);
      } else {
        resolve(path);
      }
    });
  });
}
export function safeRemoveFile(filePath: string): void {
  fs.unlink(filePath).catch((e) => {
    Logger.warn(`Failed to delete file ${filePath}`, loggerCtx);
  });
}
export async function zipFiles(files: ZippableFile[]): Promise<string> {
  const zip = new AdmZip();
  for (const file of files) {
    zip.addLocalFile(file.path, undefined, file.name);
  }
  const tmpFilePath = await createTempFile('.zip');
  await zip.writeZip(tmpFilePath);
  return tmpFilePath;
}
```

## File: packages/vendure-plugin-order-pdfs/src/api/order-pdfs.controller.ts

```typescript
import { OrderPDFsService } from './order-pdfs.service';
import {
  Controller,
  Post,
  Get,
  Res,
  Param,
  Query,
  Body,
  BadRequestException,
  Inject,
} from '@nestjs/common';
import { Response } from 'express';
import {
  Allow,
  Ctx,
  EntityHydrator,
  ForbiddenError,
  ID,
  OrderService,
  RequestContext,
  RequestContextService,
  UserInputError,
} from '@vendure/core';
import { pdfDownloadPermission } from './pdf-template-admin-resolver';
import { PLUGIN_INIT_OPTIONS } from '../constants';
import { PDFTemplatePluginOptions } from '../order-pdfs-plugin';
@Controller('order-pdf')
export class OrderPDFsController {
  constructor(
    private readonly pdfTemplateService: OrderPDFsService,
    private readonly orderService: OrderService,
    private readonly entityHydrator: EntityHydrator,
    private readonly requestContextService: RequestContextService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: PDFTemplatePluginOptions
  ) {}
  @Allow(pdfDownloadPermission.Permission)
  @Post('/preview/')
  async preview(
    @Ctx() ctx: RequestContext,
    @Res() res: Response,
    @Body() body: { template: string }
  ) {
    if (!ctx.channel?.token) {
      throw new BadRequestException('No channel set for request');
    }
    if (!body?.template || !body?.template.trim()) {
      throw new BadRequestException('No template given');
    }
    const stream = await this.pdfTemplateService.downloadPDF(
      ctx,
      undefined,
      body.template
    );
    res.set({
      'Content-Type': 'application/pdf',
      'Content-Disposition': `inline; filename="preview.pdf"`,
    });
    return stream.pipe(res);
  }
  @Allow(pdfDownloadPermission.Permission)
  @Get('/download/:templateId/')
  async download(
    @Ctx() ctx: RequestContext,
    @Res() res: Response,
    @Param('templateId') templateId: ID,
    @Query('orderCodes') orderCodesString: string
  ) {
    const orderCodes = orderCodesString.split(',');
    if (String(templateId).startsWith('T_')) {
      templateId = String(templateId).replace('T_', '');
    }
    if (!ctx.channel?.token) {
      throw new BadRequestException('No channel set for request');
    }
    if (orderCodes?.length == 1) {
      const orderCode = orderCodes[0];
      const order = await this.orderService.findOneByCode(ctx, orderCode);
      if (!order) {
        throw new UserInputError(`No order with code ${orderCode} found`);
      }
      const stream = await this.pdfTemplateService.downloadPDF(
        ctx,
        templateId,
        undefined,
        order
      );
      res.set({
        'Content-Type': 'application/pdf',
        'Content-Disposition': `inline; filename="download.pdf"`,
      });
      return stream.pipe(res);
    } else {
      const orders = (
        await this.orderService.findAll(
          ctx,
          { filter: { code: { in: orderCodes } } },
          []
        )
      ).items;
      if (!orders?.length) {
        throw new UserInputError(`No order with codes ${orderCodes} found`);
      }
      const stream = await this.pdfTemplateService.downloadMultiplePDFs(
        ctx,
        templateId,
        orders
      );
      res.set({
        'Content-Type': 'application/zip',
        'Content-Disposition': `inline; filename="pdf-${orders.length}.zip"`,
      });
      return stream.pipe(res);
    }
  }
  @Get('/download/:channelToken/:orderCode/:templateId/:emailAddress')
  async publicDownload(
    @Res() res: Response,
    @Param('channelToken') channelToken: string,
    @Param('orderCode') orderCode: string,
    @Param('templateId') templateId: ID,
    @Param('emailAddress') emailAddress: string
  ) {
    if (!this.config.allowPublicDownload) {
      throw new BadRequestException('PDF downloads not allowed');
    }
    if (!channelToken) {
      throw new BadRequestException('No channel token given');
    }
    if (String(templateId).startsWith('T_')) {
      templateId = String(templateId).replace('T_', '');
    }
    const ctx = await this.requestContextService.create({
      apiType: 'admin',
      channelOrToken: channelToken,
    });
    const template = await this.pdfTemplateService.findTemplate(
      ctx,
      templateId
    );
    if (!template?.enabled || !template?.public) {
      throw new ForbiddenError();
    }
    const order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      throw new ForbiddenError();
    }
    await this.entityHydrator.hydrate(ctx, order, { relations: ['customer'] });
    if (!order.customer || order.customer.emailAddress !== emailAddress) {
      throw new ForbiddenError();
    }
    const stream = await this.pdfTemplateService.downloadPDF(
      ctx,
      templateId,
      undefined,
      order
    );
    res.set({
      'Content-Type': 'application/pdf',
      'Content-Disposition': `inline; filename="download.pdf"`,
    });
    return stream.pipe(res);
  }
}
```

## File: packages/vendure-plugin-order-pdfs/src/api/order-pdfs.service.ts

```typescript
import { Inject, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { SortOrder } from '@vendure/common/lib/generated-shop-types';
import {
  ID,
  Injector,
  Logger,
  Order,
  OrderService,
  RequestContext,
  TransactionalConnection,
  UserInputError,
} from '@vendure/core';
import { createReadStream, ReadStream } from 'fs';
import Handlebars from 'handlebars';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { PDFTemplatePluginOptions } from '../order-pdfs-plugin';
import { PdfTemplateInput } from '../ui/generated/graphql';
import {
  createTempFile,
  safeRemoveFile,
  zipFiles,
  ZippableFile,
} from './file.util';
import { PDFTemplateEntity } from './pdf-template.entity';
import puppeteer, { Browser } from 'puppeteer';
@Injectable()
export class OrderPDFsService {
  constructor(
    private readonly connection: TransactionalConnection,
    private readonly orderService: OrderService,
    private moduleRef: ModuleRef,
    @Inject(PLUGIN_INIT_OPTIONS)
    private options: PDFTemplatePluginOptions
  ) {
    Handlebars.registerHelper('formatMoney', (amount?: number) => {
      if (amount == null) {
        return amount;
      }
      return (amount / 100).toFixed(2);
    });
  }
  async updateTemplate(
    ctx: RequestContext,
    id: ID,
    input: PdfTemplateInput
  ): Promise<PDFTemplateEntity> {
    const repository = this.connection.getRepository(ctx, PDFTemplateEntity);
    const existing = await repository.findOneOrFail({
      where: { channelId: ctx.channelId as string, id },
    });
    if (existing) {
      await repository.update(existing.id, {
        name: input.name,
        enabled: input.enabled,
        public: input.public,
        templateString: input.templateString,
      });
    }
    return await repository.findOneOrFail({
      where: { channelId: ctx.channelId as string, id },
    });
  }
  async createPDFTemplate(
    ctx: RequestContext,
    input: PdfTemplateInput
  ): Promise<PDFTemplateEntity> {
    const repository = this.connection.getRepository(ctx, PDFTemplateEntity);
    const existing = await repository.findOne({
      where: { channelId: ctx.channelId as string, name: input.name },
    });
    if (existing) {
      throw new UserInputError(
        `A PDF template with name '${input.name}' already exists`
      );
    }
    const result = await repository.save({
      name: input.name,
      enabled: input.enabled,
      public: input.public,
      templateString: input.templateString,
      channelId: ctx.channelId as string,
    });
    return await repository.findOneOrFail({
      where: { channelId: ctx.channelId as string, id: result.id },
    });
  }
  async deletePDFTemplate(
    ctx: RequestContext,
    id: ID
  ): Promise<PDFTemplateEntity[]> {
    const repository = this.connection.getRepository(ctx, PDFTemplateEntity);
    const existing = await repository.findOneOrFail({
      where: { channelId: ctx.channelId as string, id },
    });
    if (!existing) {
      throw new UserInputError(`No PDF template with id '${id}' exists`);
    }
    await repository.delete({ id });
    return await this.getTemplates(ctx);
  }
  async getTemplates(ctx: RequestContext): Promise<PDFTemplateEntity[]> {
    const repository = this.connection.getRepository(ctx, PDFTemplateEntity);
    return await repository.find({
      where: { channelId: ctx.channelId as string },
    });
  }
  async findTemplate(
    ctx: RequestContext,
    id: ID
  ): Promise<PDFTemplateEntity | undefined | null> {
    const repository = this.connection.getRepository(ctx, PDFTemplateEntity);
    return await repository.findOne({
      where: { channelId: ctx.channelId as string, id },
    });
  }
  async downloadPDF(
    ctx: RequestContext,
    templateId?: ID,
    templateString?: string,
    _order?: Order
  ): Promise<ReadStream> {
    let order = _order;
    if (!order) {
      order = await this.getLatestPlacedOrder(ctx);
    }
    if (!templateString && !templateId) {
      throw new UserInputError(
        `Need a template ID or template string to render PDF`
      );
    }
    if (!templateString) {
      const template = await this.findTemplate(ctx, templateId!);
      if (!template) {
        throw Error(`No template found with id '${templateId}'`);
      }
      templateString = template.templateString;
    }
    const { tempFilePath } = await this.generatePDF(ctx, templateString, order);
    const stream = createReadStream(tempFilePath);
    stream.on('finish', () => safeRemoveFile(tempFilePath));
    return stream;
  }
  async downloadMultiplePDFs(
    ctx: RequestContext,
    templateId: ID,
    orders: Order[]
  ) {
    if (orders.length > 10) {
      throw new UserInputError(`Max 10 orders allowed`);
    }
    const template = await this.findTemplate(ctx, templateId);
    if (!template) {
      throw Error(`No template found with name '${templateId}'`);
    }
    const pdfData = await Promise.all(
      orders.map(async (order) => {
        const hydratedOrder = await this.orderService.findOne(ctx, order.id);
        if (!hydratedOrder) {
          throw new UserInputError(`No Order with code ${order.code} found`);
        }
        return await this.generatePDF(
          ctx,
          template.templateString,
          hydratedOrder
        );
      })
    );
    const zippableFiles: ZippableFile[] = pdfData.map((pdf) => ({
      path: pdf.tempFilePath,
      name: pdf.orderCode + '.pdf',
    }));
    const zipFile = await zipFiles(zippableFiles);
    const stream = createReadStream(zipFile);
    stream.on('finish', () => safeRemoveFile(zipFile));
    return stream;
  }
  async generatePDF(
    ctx: RequestContext,
    templateString: string,
    order: Order
  ): Promise<{ tempFilePath: string; orderCode: string }> {
    const data = await this.options.loadDataFn!(
      ctx,
      new Injector(this.moduleRef),
      order
    );
    const tmpFilePath = await createTempFile('.pdf');
    let browser: Browser | undefined;
    try {
      const compiledHtml = Handlebars.compile(templateString)(data);
      browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox'],
      });
      const page = await browser.newPage();
      await page.setContent(compiledHtml);
      await page.pdf({
        path: tmpFilePath,
        format: 'A4',
        margin: { bottom: 100, top: 100, left: 50, right: 50 },
      });
    } catch (e) {
      Logger.warn(
        `Failed to generate invoice: ${JSON.stringify((e as Error)?.message)}`,
        loggerCtx
      );
      throw e;
    } finally {
      if (browser) {
        browser.close().catch((e: Error) => {
          Logger.error(
            `Failed to close puppeteer browser: ${e?.message}`,
            loggerCtx
          );
        });
      }
    }
    return { tempFilePath: tmpFilePath, orderCode: order.code };
  }
  private async getLatestPlacedOrder(ctx: RequestContext): Promise<Order> {
    const orderId = (
      await this.orderService.findAll(
        ctx,
        {
          take: 1,
          filter: {
            orderPlacedAt: { isNull: false },
          },
          sort: { createdAt: SortOrder.DESC },
        },
        []
      )
    )?.items?.[0]?.id;
    const order = await this.orderService.findOne(ctx, orderId);
    if (!order) {
      throw new UserInputError(`No latest placed order found`);
    }
    return order;
  }
}
```

## File: packages/vendure-plugin-order-pdfs/src/api/pdf-template-admin-resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  PermissionDefinition,
  RequestContext,
} from '@vendure/core';
import {
  CreatePdfTemplateMutationVariables,
  DeletePdfTemplateMutationVariables,
  PdfTemplate,
  PdfTemplateInput,
  PdfTemplateList,
  UpdatePdfTemplateMutationVariables,
} from '../ui/generated/graphql';
import { OrderPDFsService } from './order-pdfs.service';
export const pdfDownloadPermission = new PermissionDefinition({
  name: 'AllowPDFDownload',
  description: 'Allow this user to download PDF templates',
});
@Resolver()
export class PDFTemplateAdminResolver {
  constructor(private readonly service: OrderPDFsService) {}
  @Mutation()
  @Allow(pdfDownloadPermission.Permission)
  async createPDFTemplate(
    @Ctx() ctx: RequestContext,
    @Args() args: CreatePdfTemplateMutationVariables
  ): Promise<PdfTemplate> {
    return await this.service.createPDFTemplate(ctx, args.input);
  }
  @Mutation()
  @Allow(pdfDownloadPermission.Permission)
  async updatePDFTemplate(
    @Ctx() ctx: RequestContext,
    @Args() args: UpdatePdfTemplateMutationVariables
  ): Promise<PdfTemplate> {
    return await this.service.updateTemplate(ctx, args.id, args.input);
  }
  @Mutation()
  @Allow(pdfDownloadPermission.Permission)
  async deletePDFTemplate(
    @Ctx() ctx: RequestContext,
    @Args() args: DeletePdfTemplateMutationVariables
  ): Promise<PdfTemplate[]> {
    return await this.service.deletePDFTemplate(ctx, args.id);
  }
  @Query()
  @Allow(pdfDownloadPermission.Permission)
  async pdfTemplates(@Ctx() ctx: RequestContext): Promise<PdfTemplateList> {
    const result = await this.service.getTemplates(ctx);
    return {
      items: result,
      totalItems: result.length,
    };
  }
}
```

## File: packages/vendure-plugin-order-pdfs/src/api/pdf-template-shop-resolver.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  PermissionDefinition,
  RequestContext,
} from '@vendure/core';
import {
  CreatePdfTemplateMutationVariables,
  DeletePdfTemplateMutationVariables,
  PdfTemplate,
  PdfTemplateInput,
  PdfTemplateList,
  UpdatePdfTemplateMutationVariables,
} from '../ui/generated/graphql';
import { OrderPDFsService } from './order-pdfs.service';
@Resolver()
export class PDFTemplateShopResolver {
  constructor(private readonly service: OrderPDFsService) {}
  @Query()
  async availablePDFTemplates(
    @Ctx() ctx: RequestContext
  ): Promise<PdfTemplate[]> {
    return (await this.service.getTemplates(ctx)).filter(
      (t) => t.enabled && t.public
    );
  }
}
```

## File: packages/vendure-plugin-order-pdfs/src/api/pdf-template.entity.ts

```typescript
import { Column, Entity, ColumnType } from 'typeorm';
import { DeepPartial, Logger, VendureEntity } from '@vendure/core';
import { loggerCtx } from '../constants';
@Entity('pdf_template')
export class PDFTemplateEntity extends VendureEntity {
  constructor(input?: DeepPartial<PDFTemplateEntity>) {
    super(input);
  }
  @Column()
  channelId!: string;
  @Column()
  name!: string;
  @Column({ default: true })
  enabled: boolean = true;
  @Column({ default: false })
  public: boolean = false;
  @Column({ type: resolveTemplateColumnType(), nullable: false })
  templateString!: string;
}
function resolveTemplateColumnType(): ColumnType {
  const dbEngine = process.env.PDF_TEMPLATE_PLUGIN_DB_ENGINE;
  if (!dbEngine) {
    return 'text';
  } else if (dbEngine === 'mysql' || dbEngine === 'mariadb') {
    return 'longtext';
  } else if (dbEngine === 'postgres') {
    return 'text';
  } else if (dbEngine === 'cockroachdb') {
    return 'string';
  } else if (dbEngine === 'mssql') {
    return 'text';
  } else if (dbEngine === 'sqlite') {
    return 'text';
  } else if (dbEngine === 'oracle') {
    return 'clob';
  } else {
    Logger.warn(
      `No large-text column type available for DB engine "${dbEngine}", using "text". ( Contributions welcome )`,
      loggerCtx
    );
  }
  return 'text';
}
```

## File: packages/vendure-plugin-order-pdfs/src/api/schema.graphql.ts

```typescript
import gql from 'graphql-tag';
const scalars = gql`
  scalar DateTime
`;
export const shopSchema = gql`
  type PDFTemplate {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    name: String!
  }
  extend type Query {
    availablePDFTemplates: [PDFTemplate!]!
  }
`;
export const adminSchema = gql`
  type PDFTemplate {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    enabled: Boolean!
    public: Boolean!
    name: String!
    templateString: String
  }
  input PDFTemplateInput {
    name: String!
    enabled: Boolean!
    public: Boolean!
    templateString: String!
  }
  extend type Mutation {
    createPDFTemplate(input: PDFTemplateInput): PDFTemplate!
    updatePDFTemplate(id: ID!, input: PDFTemplateInput!): PDFTemplate!
    deletePDFTemplate(id: ID!): [PDFTemplate!]!
  }
  extend type Query {
    pdfTemplates: PDFTemplateList!
  }
  type PDFTemplateList {
    items: [PDFTemplate!]!
    totalItems: Int!
  }
`;
```

## File: packages/vendure-plugin-order-pdfs/src/ui/default-template.ts

```typescript
export const defaultTemplate = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Order: {{ order.code }}</title>
</head>
<body style="font-family: Arial, Helvetica, sans-serif; width: 100%;">
        <table style="width: 96%">
            <tr>
                <td>
                    <h5>Order: <h20>{{ order.code }}</h20></h5>
                    <h5>Date: <h20>{{ orderDate }}</h20></h5>
                </td>
            </tr>
        </table>
        <hr> <!-- LINE -->
        <!--CLIENT INFO + COMPANY INFO -->
        <table style="width: 96%">
            <tr>
                <td id="shipping-info">
                    <h4>Shipping Info</h4>
                    {{#with order.shippingAddress }}
                    {{ fullName }}<br />
                    {{#if company}} {{ company }}<br />
                    {{/if}} {{#if streetLine1}} {{ streetLine1 }} {{ streetLine2 }}<br />
                    {{/if}} {{#if postalCode}} {{ postalCode }}, {{ city }}<br />
                    {{/if}} {{#if country}} {{ country }}<br />
                    {{/if}} {{/with}}
                    {{ customerEmail }}<br />
                </td>
                <td id="billing-info">
                    {{#if order.billingAddress.streetLine1}}
                        <h4>Billing Info</h4>
                        {{#with order.billingAddress }}
                        <br />
                        {{#if company}} {{ company }}<br />
                        {{/if}} {{#if streetLine1}} {{ streetLine1 }} {{ streetLine2 }}<br />
                        {{/if}} {{#if postalCode}} {{ postalCode }}, {{ city }}<br />
                        {{/if}} {{#if country}} {{ country }}<br />
                        {{/if}}
                        {{/with}}
                        {{ customerEmail }} <br />
                    {{/if}}
                </td>
            </tr>
        </table>
        <!-- #, PRODUCTS, QUANTITY, AMOUNT IN $ -->
        <table style="width: 96%">
            <tr>
                <td>
                    <h4>Qty</h4>
                </td>
                <td>
                    <h4>Product</h4>
                </td>
            </tr>
            {{#each order.lines }}
            <tr>
                <td>
                    {{ quantity }}
                </td>
                <td>
                    {{ productVariant.name }}
                </td>
            </tr>
            {{/each}}
            <!-- DISCOUNT -->
            {{#each order.discounts }}
            <tr>
                <td></td>
                <td>{{ description }}</td>
            </tr>
            {{/each}}
        </table>
        <hr> <!-- LINE -->
  </body>
</html>
`;
```

## File: packages/vendure-plugin-order-pdfs/src/ui/helpers.ts

```typescript
import { LocalStorageService } from '@vendure/admin-ui/core';
export async function downloadBlob(
  blob: Blob,
  fileName: string,
  openInNewTab = false
): Promise<void> {
  const blobUrl = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  document.body.appendChild(a);
  a.setAttribute('hidden', 'true');
  a.href = blobUrl;
  if (!openInNewTab) {
    a.download = fileName;
  }
  a.setAttribute('target', '_blank');
  a.click();
}
export function getHeaders(
  localStorageService: LocalStorageService
): Record<string, string> {
  const headers: Record<string, string> = {};
  const channelToken = localStorageService.get('activeChannelToken');
  if (channelToken) {
    headers['vendure-token'] = channelToken;
  }
  const authToken = localStorageService.get('authToken');
  if (authToken) {
    headers.authorization = `Bearer ${authToken}`;
  }
  headers['Content-Type'] = 'application/json';
  return headers;
}
```

## File: packages/vendure-plugin-order-pdfs/src/ui/pdf-template-list.component.ts

```typescript
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
} from '@angular/core';
import {
  ConfigArgDefinition,
  getServerLocation,
  LocalStorageService,
  NotificationService,
  SharedModule,
  TypedBaseListComponent,
} from '@vendure/admin-ui/core';
import { TypedDocumentNode } from '@apollo/client';
import {
  createPDFTemplate,
  deletePDFTemplate,
  getPDFTemplates,
  updatePDFTemplate,
} from './queries.graphql';
import {
  CreatePdfTemplateMutation,
  CreatePdfTemplateMutationVariables,
  DeletePdfTemplateMutation,
  DeletePdfTemplateMutationVariables,
  PdfTemplate,
  PdfTemplateList,
  Scalars,
  UpdatePdfTemplateMutation,
  UpdatePdfTemplateMutationVariables,
} from './generated/graphql';
import { FormArray, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { defaultTemplate } from './default-template';
import { downloadBlob, getHeaders } from './helpers';
const GetPDFTemplatesDocument: TypedDocumentNode<{
  pdfTemplates: PdfTemplateList;
}> = getPDFTemplates;
@Component({
  selector: 'pl-pdf-template-list-component',
  templateUrl: './pdf-template-list.component.html',
  standalone: true,
  imports: [SharedModule],
  changeDetection: ChangeDetectionStrategy.OnPush,
  styles: [
    `
      .modal-footer.pdf-template {
        display: block;
      }
    `,
  ],
})
export class PDFTemplateListComponent extends TypedBaseListComponent<
  typeof GetPDFTemplatesDocument,
  'pdfTemplates'
> {
  showModal = false;
  modalAction: 'Edit' | 'Create' = 'Create';
  previewLoading = false;
  serverPath: string;
  htmlFormInputConfigArgsDef: ConfigArgDefinition = {
    name: 'templateString',
    type: 'text',
    list: false,
    required: false,
    ui: { component: 'html-editor-form-input' },
  };
  form: FormGroup;
  renderHtmlFormInput = false;
  constructor(
    private changeDetector: ChangeDetectorRef,
    private formBuilder: FormBuilder,
    private notificationService: NotificationService,
    private localStorageService: LocalStorageService
  ) {
    super();
    super.configure({
      document: GetPDFTemplatesDocument,
      getItems: (data) => data.pdfTemplates,
      refreshListOnChanges: [],
    });
    this.serverPath = getServerLocation();
    this.form = this.formBuilder.group({
      id: [''],
      name: ['', Validators.required],
      enabled: [true, Validators.required],
      public: [false, Validators.required],
      templateString: ['', Validators.required],
    });
  }
  create() {
    this.modalAction = 'Create';
    this.clear();
    this.form.patchValue({
      id: '',
      name: '',
      enabled: true,
      public: false,
      templateString: defaultTemplate,
    });
    this.forceRerender();
    this.showModal = true;
  }
  edit(template: PdfTemplate) {
    this.modalAction = 'Edit';
    this.form.patchValue({
      id: template.id,
      name: template.name,
      enabled: template.enabled,
      public: template.public,
      templateString: template.templateString,
    });
    this.forceRerender();
    this.showModal = true;
  }
  forceRerender(): void {
    this.renderHtmlFormInput = false;
    this.changeDetector.detectChanges();
    setTimeout(() => {
      this.renderHtmlFormInput = true;
      this.changeDetector.detectChanges();
    }, 1);
  }
  delete() {
    this.dataService
      .mutate<DeletePdfTemplateMutation, DeletePdfTemplateMutationVariables>(
        deletePDFTemplate,
        {
          id: this.form.get('id')!.value,
        }
      )
      .subscribe((s: any) => {
        this.showModal = false;
        this.clear();
        this.notificationService.success('Deleted');
        super.refresh();
      });
  }
  clear() {
    this.form.patchValue({
      id: '',
      name: '',
      enabled: true,
      public: true,
      templateString: '',
    });
  }
  createOrUpdate() {
    const formValues = this.form.value;
    console.log(formValues);
    if (formValues.id) {
      // Update
      this.dataService
        .mutate<UpdatePdfTemplateMutation, UpdatePdfTemplateMutationVariables>(
          updatePDFTemplate,
          {
            id: formValues.id,
            input: {
              enabled: formValues.enabled,
              public: formValues.public,
              name: formValues.name,
              templateString: formValues.templateString,
            },
          }
        )
        .subscribe((s: any) => {
          this.showModal = false;
          this.clear();
          this.notificationService.success('Saved');
          this.changeDetector.detectChanges();
        });
    } else {
      this.dataService
        .mutate<CreatePdfTemplateMutation, CreatePdfTemplateMutationVariables>(
          createPDFTemplate,
          {
            input: {
              name: formValues.name,
              enabled: formValues.enabled,
              public: formValues.public,
              templateString: formValues.templateString,
            },
          }
        )
        .subscribe((s: any) => {
          this.showModal = false;
          this.clear();
          this.notificationService.success('Created');
          this.changeDetector.detectChanges();
          super.refresh();
        });
    }
  }
  async preview() {
    const formValues = this.form.value;
    try {
      this.previewLoading = true;
      const res = await fetch(`${this.serverPath}/order-pdf/preview/`, {
        headers: getHeaders(this.localStorageService),
        method: 'POST',
        body: JSON.stringify({
          template: formValues.templateString,
        }),
      });
      if (!res.ok) {
        const json = await res.json();
        throw Error(json?.message);
      }
      const blob = await res.blob();
      await downloadBlob(blob, 'test.pdf', true);
    } catch (err: any) {
      console.error(err);
      this.notificationService.error(err?.message);
    } finally {
      this.previewLoading = false;
    }
  }
}
```

## File: packages/vendure-plugin-order-pdfs/src/ui/providers.ts

```typescript
import {
  addActionBarDropdownMenuItem,
  addNavMenuItem,
  DataService,
  getServerLocation,
  LocalStorageService,
  ModalService,
  NotificationService,
  registerBulkAction,
} from '@vendure/admin-ui/core';
import { firstValueFrom, lastValueFrom } from 'rxjs';
import { PdfTemplate, PdfTemplateNamesQuery } from './generated/graphql';
import { downloadBlob, getHeaders } from './helpers';
import { getTemplateNames } from './queries.graphql';
import { ID } from '@vendure/core';
async function getEnabledTemplates(dataService: DataService) {
  const templateNames = await firstValueFrom(
    dataService
      .query<PdfTemplateNamesQuery>(getTemplateNames)
      .mapStream((d) => d.pdfTemplates.items)
  );
  return templateNames.filter((t) => t.enabled);
}
async function promptTemplateSelection(
  modalService: ModalService,
  templates: Array<Pick<PdfTemplate, 'name' | 'id'>>,
  nrOfOrders: number
) {
  return await firstValueFrom(
    modalService.dialog({
      title: `Select a PDF template`,
      body: `You are about to download PDF files for ${nrOfOrders} order(s). Please select a template to use.`,
      size: 'xl',
      buttons: [
        { type: 'secondary', label: 'cancel', returnValue: null },
        ...templates.map((t) => ({
          type: 'primary' as const,
          label: t.name,
          returnValue: t.id,
        })),
      ],
    })
  );
}
async function startDownload(
  notificationService: NotificationService,
  localStorageService: LocalStorageService,
  templateId: ID,
  orderCodes: string[]
) {
  notificationService.info('Starting download...');
  const serverPath = getServerLocation();
  const res = await fetch(
    `${serverPath}/order-pdf/download/${templateId}?orderCodes=${orderCodes.join(
      ','
    )}`,
    {
      headers: getHeaders(localStorageService),
      method: 'GET',
    }
  );
  if (!res.ok) {
    const json = await res.json();
    throw Error(json?.message);
  }
  await new Promise((resolve) => setTimeout(resolve, 5000));
  const blob = await res.blob();
  const fileName = orderCodes.length > 1 ? `orders.zip` : 'order.pdf';
  await downloadBlob(blob, fileName, true);
}
export default [
  addNavMenuItem(
    {
      id: 'pdf-templates',
      label: 'PDF Templates',
      routerLink: ['/extensions/pdf-templates'],
      requiresPermission: 'AllowPDFDownload',
      icon: 'printer',
    },
    'settings'
  ),
  addActionBarDropdownMenuItem({
    id: 'print-invoice',
    locationId: 'order-detail',
    label: 'Download PDF',
    icon: 'printer',
    requiresPermission: 'AllowPDFDownload',
    hasDivider: true,
    onClick: async (event, context) => {
      const order = await firstValueFrom(context.entity$);
      const templateNames = await getEnabledTemplates(context.dataService);
      const modalService = context.injector.get(ModalService);
      const selectedTemplateId = await promptTemplateSelection(
        modalService,
        templateNames,
        1
      );
      if (!selectedTemplateId) {
        return;
      }
      const localStorageService = context.injector.get(LocalStorageService);
      const notificationService = context.injector.get(NotificationService);
      const orderCode = order?.code;
      console.log('asdfasdfasd', orderCode);
      await startDownload(
        notificationService,
        localStorageService,
        selectedTemplateId,
        [orderCode]
      ).catch((e) => {
        notificationService.error(e?.message);
      });
    },
  }),
  registerBulkAction({
    location: 'order-list',
    label: 'Download PDF',
    icon: 'printer',
    requiresPermission: 'AllowPDFDownload',
    onClick: async ({ injector, selection }) => {
      const dataService = injector.get(DataService);
      const templateNames = await getEnabledTemplates(dataService);
      const modalService = injector.get(ModalService);
      const selectedTemplateId = await promptTemplateSelection(
        modalService,
        templateNames,
        selection.length
      );
      if (!selectedTemplateId) {
        return;
      }
      const localStorageService = injector.get(LocalStorageService);
      const notificationService = injector.get(NotificationService);
      const orderCodes = selection.map((s) => s.code);
      await startDownload(
        notificationService,
        localStorageService,
        selectedTemplateId,
        orderCodes
      ).catch((e) => {
        notificationService.error(e?.message);
      });
    },
  }),
];
```

## File: packages/vendure-plugin-order-pdfs/src/ui/queries.graphql.ts

```typescript
import gql from 'graphql-tag';
const pdfTemplateFields = gql`
  fragment PDFTemplateFields on PDFTemplate {
    id
    createdAt
    updatedAt
    name
    enabled
    public
    templateString
  }
`;
export const updatePDFTemplate = gql`
  mutation updatePDFTemplate($id: ID!, $input: PDFTemplateInput!) {
    updatePDFTemplate(id: $id, input: $input) {
      ...PDFTemplateFields
    }
  }
  ${pdfTemplateFields}
`;
export const createPDFTemplate = gql`
  mutation createPDFTemplate($input: PDFTemplateInput!) {
    createPDFTemplate(input: $input) {
      ...PDFTemplateFields
    }
  }
  ${pdfTemplateFields}
`;
export const deletePDFTemplate = gql`
  mutation deletePDFTemplate($id: ID!) {
    deletePDFTemplate(id: $id) {
      ...PDFTemplateFields
    }
  }
  ${pdfTemplateFields}
`;
export const getPDFTemplates = gql`
  query pdfTemplates {
    pdfTemplates {
      items {
        ...PDFTemplateFields
      }
      totalItems
    }
  }
  ${pdfTemplateFields}
`;
export const getTemplateNames = gql`
  query pdfTemplateNames {
    pdfTemplates {
      items {
        id
        name
        enabled
        public
      }
      totalItems
    }
  }
`;
```

## File: packages/vendure-plugin-order-pdfs/src/ui/routes.ts

```typescript
import { registerRouteComponent } from '@vendure/admin-ui/core';
import { PDFTemplateListComponent } from './pdf-template-list.component';
export default [
  registerRouteComponent({
    path: '',
    title: 'PDF Templates',
    component: PDFTemplateListComponent,
    breadcrumb: 'PDF Templates',
  }),
];
```

## File: packages/vendure-plugin-order-pdfs/src/constants.ts

```typescript
export const loggerCtx = 'OrderPDFsPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('ORDER_PDFS_PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-order-pdfs/src/index.ts

```typescript
export * from './order-pdfs-plugin';
export * from './api/order-pdfs.service';
export * from './load-data-fn';
```

## File: packages/vendure-plugin-order-pdfs/src/load-data-fn.ts

```typescript
import {
  Injector,
  Order,
  RequestContext,
  translateEntity,
} from '@vendure/core';
export type LoadDataFn = (
  ctx: RequestContext,
  injector: Injector,
  order: Order
) => Promise<any>;
export const defaultLoadDataFn: LoadDataFn = async (
  ctx: RequestContext,
  injector: Injector,
  order: Order
): Promise<any> => {
  order.lines.forEach((line) => {
    line.productVariant = translateEntity(
      line.productVariant,
      ctx.languageCode
    );
  });
  return {
    orderDate: order.orderPlacedAt
      ? new Intl.DateTimeFormat('nl-NL').format(order.orderPlacedAt)
      : new Intl.DateTimeFormat('nl-NL').format(order.updatedAt),
    order,
  };
};
```

## File: packages/vendure-plugin-order-pdfs/src/order-pdfs-plugin.ts

```typescript
import {
  PluginCommonModule,
  RuntimeVendureConfig,
  Type,
  VendurePlugin,
} from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { OrderPDFsService } from './api/order-pdfs.service';
import {
  PDFTemplateAdminResolver,
  pdfDownloadPermission,
} from './api/pdf-template-admin-resolver';
import { adminSchema, shopSchema } from './api/schema.graphql';
import { OrderPDFsController } from './api/order-pdfs.controller';
import { LoadDataFn, defaultLoadDataFn } from './load-data-fn';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { PDFTemplateEntity } from './api/pdf-template.entity';
import { PDFTemplateShopResolver } from './api/pdf-template-shop-resolver';
export interface PDFTemplatePluginOptions {
  loadDataFn?: LoadDataFn;
  allowPublicDownload?: boolean;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  entities: [PDFTemplateEntity],
  providers: [
    OrderPDFsService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => OrderPDFsPlugin.options,
    },
  ],
  controllers: [OrderPDFsController],
  adminApiExtensions: {
    schema: adminSchema,
    resolvers: [PDFTemplateAdminResolver],
  },
  shopApiExtensions: {
    schema: shopSchema,
    resolvers: [PDFTemplateShopResolver],
  },
  configuration: (config: RuntimeVendureConfig) => {
    config.authOptions.customPermissions.push(pdfDownloadPermission);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class OrderPDFsPlugin {
  static options: PDFTemplatePluginOptions = {
    loadDataFn: defaultLoadDataFn,
  };
  static init(options: PDFTemplatePluginOptions): Type<OrderPDFsPlugin> {
    OrderPDFsPlugin.options = {
      ...this.options,
      ...options,
    };
    return OrderPDFsPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    providers: ['providers.ts'],
    routes: [{ route: 'pdf-templates', filePath: 'routes.ts' }],
  };
}
```

## File: packages/vendure-plugin-order-pdfs/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  RequestContextService,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { OrderPDFsPlugin } from '../src';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { OrderPDFsService } from '../src/api/order-pdfs.service';
import { addShippingMethod } from '../../test/src/admin-utils';
import { createSettledOrder } from '../../test/src/shop-utils';
import { defaultTemplate } from '../src/ui/default-template';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      OrderPDFsPlugin.init({
        allowPublicDownload: true,
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [OrderPDFsPlugin.ui],
          devMode: true,
        }),
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    apiOptions: {
      adminApiPlayground: true,
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  const ctx = await server.app.get(RequestContextService).create({
    apiType: 'admin',
  });
  await server.app.get(OrderPDFsService).createPDFTemplate(ctx, {
    enabled: true,
    public: true,
    name: 'Default',
    templateString: defaultTemplate,
  });
  await new Promise((resolve) => setTimeout(resolve, 3000));
  await addShippingMethod(adminClient as any, 'manual-fulfillment');
  const orders = 3;
  for (let i = 1; i <= orders; i++) {
    await createSettledOrder(shopClient as any, 3);
  }
  console.log(`Created ${orders} orders`);
})();
```

## File: packages/vendure-plugin-order-pdfs/test/e2e.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig, Order } from '@vendure/core';
import {
  createTestEnvironment,
  E2E_DEFAULT_CHANNEL_TOKEN,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import fetch from 'node-fetch';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { defaultTemplate } from '../src/ui/default-template';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { createSettledOrder, SettledOrder } from '../../test/src/shop-utils';
import { OrderPDFsPlugin } from '../src';
import {
  createPDFTemplate,
  getPDFTemplates,
  updatePDFTemplate,
} from '../src/ui/queries.graphql';
import {
  CreatePdfTemplateMutation,
  CreatePdfTemplateMutationVariables,
  PdfTemplatesQuery,
  UpdatePdfTemplateMutation,
  UpdatePdfTemplateMutationVariables,
} from '../src/ui/generated/graphql';
import gql from 'graphql-tag';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
let serverStarted = false;
let order: SettledOrder;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    apiOptions: {
      port: 3050,
    },
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      OrderPDFsPlugin.init({
        allowPublicDownload: true,
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  serverStarted = true;
  await adminClient.asSuperAdmin();
}, 60000);
it('Should start successfully', async () => {
  await expect(serverStarted).toBe(true);
});
it('Creates a settled order', async () => {
  order = await createSettledOrder(shopClient, 'T_1');
});
it('Creates a private PDF template', async () => {
  await adminClient.asSuperAdmin();
  const { createPDFTemplate: template } = await adminClient.query<
    CreatePdfTemplateMutation,
    CreatePdfTemplateMutationVariables
  >(createPDFTemplate, {
    input: {
      name: 'Example PDF Template',
      enabled: true,
      public: false,
      templateString: '<html><body><h1>Example PDF</h1></body></html>',
    },
  });
  expect(template.id).toBeDefined();
  expect(template.createdAt).toBeDefined();
  expect(template.updatedAt).toBeDefined();
  expect(template.name).toBe('Example PDF Template');
  expect(template.enabled).toBe(true);
  expect(template.public).toBe(false);
  expect(template.templateString).toBe(
    '<html><body><h1>Example PDF</h1></body></html>'
  );
});
it('Gets all PDF templates as admin', async () => {
  await adminClient.asSuperAdmin();
  const { pdfTemplates } = await adminClient.query<PdfTemplatesQuery>(
    getPDFTemplates
  );
  expect(pdfTemplates.totalItems).toBe(1);
  expect(pdfTemplates.items.length).toBe(1);
  expect(pdfTemplates.items[0].name).toBe('Example PDF Template');
});
it('Downloads private PDF as admin', async () => {
  const headers = {
    'vendure-token': E2E_DEFAULT_CHANNEL_TOKEN,
    authorization: `Bearer ${adminClient.getAuthToken()}`,
    'Content-Type': 'application/json',
  };
  const res = await fetch(
    `http://localhost:3050/order-pdf/download/T_1?orderCodes=${order.code}`,
    {
      headers,
      method: 'GET',
    }
  );
  expect(res.ok).toBe(true);
});
it('Does not show up as available PDF template to customers', async () => {
  await shopClient.asAnonymousUser();
  const { availablePDFTemplates } = await shopClient.query(
    availablePDFTemplatesQuery
  );
  expect(availablePDFTemplates).toEqual([]);
});
it('Does not allow downloading of private template as customer', async () => {
  const res = await fetch(
    `http://localhost:3050/order-pdf/download/${E2E_DEFAULT_CHANNEL_TOKEN}/${order.code}/T_1/hayden.zieme12@hotmail.com`
  );
  expect(res.status).toBe(403);
});
it('Updates the PDF template to public', async () => {
  await adminClient.asSuperAdmin();
  const { updatePDFTemplate: template } = await adminClient.query<
    UpdatePdfTemplateMutation,
    UpdatePdfTemplateMutationVariables
  >(updatePDFTemplate, {
    id: 'T_1',
    input: {
      enabled: true,
      templateString: '<html>New HTML</html>',
      public: true,
      name: 'Public PDF Template',
    },
  });
  expect(template.templateString).toBe('<html>New HTML</html>');
  expect(template.public).toBe(true);
  expect(template.name).toBe('Public PDF Template');
});
it('Shows up as available PDF template', async () => {
  await shopClient.asAnonymousUser();
  const { availablePDFTemplates } = await shopClient.query(
    availablePDFTemplatesQuery
  );
  expect(availablePDFTemplates.length).toBe(1);
  expect(availablePDFTemplates[0].name).toBe('Public PDF Template');
});
it('Allows public download', async () => {
  const order1 = await createSettledOrder(shopClient, 'T_1');
  const res = await fetch(
    `http://localhost:3050/order-pdf/download/${E2E_DEFAULT_CHANNEL_TOKEN}/${order1.code}/1/hayden.zieme12@hotmail.com`,
    {
      method: 'GET',
    }
  );
  expect(res.ok).toBe(true);
});
it('Fails to preview for unauthenticated calls', async () => {
  const res = await fetch('http://localhost:3050/order-pdf/preview/', {
    method: 'POST',
    body: JSON.stringify({ template: '<html>Preview</html>' }),
  });
  expect(res.status).toBe(403);
});
it('Previews a PDF template as admin', async () => {
  const headers = {
    'vendure-token': E2E_DEFAULT_CHANNEL_TOKEN,
    authorization: `Bearer ${adminClient.getAuthToken()}`,
    'Content-Type': 'application/json',
  };
  const res = await fetch('http://localhost:3050/order-pdf/preview/', {
    method: 'POST',
    headers,
    body: JSON.stringify({ template: '<html>Preview</html>' }),
  });
  expect(res.ok).toBe(true);
});
it('Downloads multiple PDFs as ZIP file', async () => {
  const order2 = await createSettledOrder(shopClient, 'T_1');
  const headers: Record<string, string> = {};
  headers['vendure-token'] = E2E_DEFAULT_CHANNEL_TOKEN;
  headers.authorization = `Bearer ${adminClient.getAuthToken()}`;
  headers['Content-Type'] = 'application/json';
  const res = await fetch(
    `http://localhost:3050/order-pdf/download/T_1?orderCodes=${order.code},${order2.code}`,
    {
      headers,
      method: 'GET',
    }
  );
  expect(res.ok).toBe(true);
});
if (process.env.TEST_ADMIN_UI) {
  it('Should compile admin', async () => {
    const files = await getFilesInAdminUiFolder(__dirname, OrderPDFsPlugin.ui);
    expect(files?.length).toBeGreaterThan(0);
  }, 200000);
}
afterAll(async () => {
  await server.destroy();
}, 100000);
export const availablePDFTemplatesQuery = gql`
  query availablePDFTemplates {
    availablePDFTemplates {
      id
      createdAt
      updatedAt
      name
    }
  }
`;
```

## File: packages/vendure-plugin-payment-extensions/src/index.ts

```typescript
export * from './payment-extensions-plugin';
export * from './is-customer-In-group-payment-checker';
export * from './settle-without-payment-handler';
```

## File: packages/vendure-plugin-payment-extensions/src/is-customer-In-group-payment-checker.ts

```typescript
import {
  CustomerService,
  ID,
  Injector,
  LanguageCode,
  PaymentMethodEligibilityChecker,
  TtlCache,
  idsAreEqual,
} from '@vendure/core';
const fiveMinutes = 5 * 60 * 1000;
const groupsPerCustomerCache = new TtlCache<ID, ID[]>({ ttl: fiveMinutes });
let injector: Injector | undefined;
export const isCustomerInGroupPaymentChecker =
  new PaymentMethodEligibilityChecker({
    code: 'is-customer-in-group-payment-checker',
    description: [
      {
        languageCode: LanguageCode.en,
        value:
          'Checks if the Customer connected to the Order is in the given group',
      },
    ],
    args: {
      customerGroupId: {
        type: 'ID',
        ui: { component: 'customer-group-form-input' },
        label: [{ languageCode: LanguageCode.en, value: 'Customer group' }],
      },
    },
    init(_injector) {
      injector = _injector;
    },
    check: async (ctx, order, args) => {
      if (!order.customer) {
        return 'Only orders with a customer can use this payment method';
      }
      const customerId = order.customer.id;
      let groupIds = groupsPerCustomerCache.get(customerId);
      if (!groupIds) {
        const groups =
          (await injector
            ?.get(CustomerService)
            .getCustomerGroups(ctx, customerId)) ?? [];
        groupIds = groups.map((g) => g.id);
        groupsPerCustomerCache.set(customerId, groupIds);
      }
      const isEligible = groupIds.some((id) =>
        idsAreEqual(id, args.customerGroupId)
      );
      if (!isEligible) {
        return 'You are not in the required customer group';
      }
      return isEligible;
    },
  });
```

## File: packages/vendure-plugin-payment-extensions/src/payment-extensions-plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { settleWithoutPaymentHandler } from './settle-without-payment-handler';
import { isCustomerInGroupPaymentChecker } from './is-customer-In-group-payment-checker';
@VendurePlugin({
  imports: [PluginCommonModule],
  configuration: (config) => {
    config.paymentOptions.paymentMethodHandlers.push(
      settleWithoutPaymentHandler
    );
    if (config.paymentOptions.paymentMethodEligibilityCheckers?.length) {
      config.paymentOptions.paymentMethodEligibilityCheckers.push(
        isCustomerInGroupPaymentChecker
      );
    } else {
      config.paymentOptions.paymentMethodEligibilityCheckers = [
        isCustomerInGroupPaymentChecker,
      ];
    }
    return config;
  },
  compatibility: '>=2.2.0',
})
export class PaymentExtensionsPlugin {}
```

## File: packages/vendure-plugin-payment-extensions/src/settle-without-payment-handler.ts

```typescript
import { LanguageCode, Logger, PaymentMethodHandler } from '@vendure/core';
export const settleWithoutPaymentHandler = new PaymentMethodHandler({
  code: 'settle-order-without-payment',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Settle order without payment',
    },
  ],
  args: {},
  createPayment: (_, order, amount, __, metadata) => {
    Logger.info(
      `'${order.code}' settled without payment for customer '${order.customer?.emailAddress}'`
    );
    return {
      amount,
      state: 'Settled',
      metadata: { ...metadata, note: 'Settled without payment' },
    };
  },
  settlePayment: () => ({
    success: true,
  }),
});
```

## File: packages/vendure-plugin-payment-extensions/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { AssetServerPlugin } from '@vendure/asset-server-plugin';
import path from 'path';
import { initialData } from '../../test/src/initial-data';
import { PaymentExtensionsPlugin } from '../src/payment-extensions-plugin';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AssetServerPlugin.init({
        assetUploadDir: path.join(__dirname, '__data__/assets'),
        route: 'assets',
      }),
      PaymentExtensionsPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
  });
  const { server } = createTestEnvironment(devConfig);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
})();
```

## File: packages/vendure-plugin-payment-extensions/test/payment-extensions.spec.ts

```typescript
import {
  CustomerGroupService,
  DefaultLogger,
  LanguageCode,
  LogLevel,
  PaymentMethod,
  PaymentMethodService,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { afterAll, beforeAll, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { PaymentExtensionsPlugin } from '../src/payment-extensions-plugin';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import { settleWithoutPaymentHandler } from '../src/settle-without-payment-handler';
import { createSettledOrder } from '../../test/src/shop-utils';
import { isCustomerInGroupPaymentChecker } from '../src/is-customer-In-group-payment-checker';
let server: TestServer;
let shopClient: SimpleGraphQLClient;
let settleWithoutPaymentMethod: PaymentMethod;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [PaymentExtensionsPlugin],
  });
  ({ server, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  const customerGroupService = server.app.get(CustomerGroupService);
  const paymentMethodService = server.app.get(PaymentMethodService);
  const ctx = await getSuperadminContext(server.app);
  const settleWithoutPaymentCustomerGroup = await customerGroupService.create(
    ctx,
    {
      name: 'Settle Without Payment Group',
      customerIds: ['1'],
    }
  );
  settleWithoutPaymentMethod = await paymentMethodService.create(ctx, {
    code: 'settle-without-payment',
    enabled: false,
    handler: {
      arguments: [],
      code: settleWithoutPaymentHandler.code,
    },
    checker: {
      arguments: [
        {
          name: 'customerGroupId',
          value: JSON.stringify(settleWithoutPaymentCustomerGroup.id),
        },
      ],
      code: isCustomerInGroupPaymentChecker.code,
    },
    translations: [
      {
        languageCode: LanguageCode.en,
        name: 'Settle Without Payment',
      },
    ],
  });
}, 60000);
it('Should start successfully', () => {
  expect(server.app.getHttpServer()).toBeDefined();
});
it('it should settle payment for Customer(1) with "settle-without-payment" PaymentMethod', async () => {
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  const order = await createSettledOrder(
    shopClient,
    1,
    false,
    [
      { id: 'T_1', quantity: 1 },
      { id: 'T_2', quantity: 2 },
    ],
    undefined,
    undefined,
    settleWithoutPaymentMethod.code
  );
  expect(order.id).toBeDefined();
});
it('it should not settle payment for Customer(2) with "settle-without-payment" PaymentMethod', async () => {
  await shopClient.asUserWithCredentials(
    'trevor_donnelly96@hotmail.com',
    'test'
  );
  try {
    const order = await createSettledOrder(
      shopClient,
      1,
      false,
      [
        { id: 'T_1', quantity: 1 },
        { id: 'T_2', quantity: 2 },
      ],
      undefined,
      undefined,
      settleWithoutPaymentMethod.code
    );
  } catch (e: any) {
    expect(e.message).toMatch(`Failed to create settled order:`);
  }
});
afterAll(() => {
  return server.destroy();
});
```

## File: packages/vendure-plugin-picqer/src/api/api-extensions.ts

```typescript
import { gql } from 'graphql-tag';
export const adminSchema = gql`
  input PicqerConfigInput {
    enabled: Boolean
    apiKey: String
    apiEndpoint: String
    storefrontUrl: String
    supportEmail: String
  }
  input TestPicqerInput {
    apiKey: String!
    apiEndpoint: String!
    storefrontUrl: String!
    supportEmail: String!
  }
  type PicqerConfig {
    enabled: Boolean
    apiKey: String
    apiEndpoint: String
    storefrontUrl: String
    supportEmail: String
  }
  extend type Query {
    picqerConfig: PicqerConfig
    """
    Test Picqer config against the Picqer API
    """
    isPicqerConfigValid(input: TestPicqerInput!): Boolean!
  }
  extend type Mutation {
    """
    Push all products to, and pull all stock levels from Picqer
    """
    triggerPicqerFullSync: Boolean!
    """
    Upsert Picqer config for the current channel
    """
    upsertPicqerConfig(input: PicqerConfigInput!): PicqerConfig!
  }
`;
```

## File: packages/vendure-plugin-picqer/src/api/picqer-config.entity.ts

```typescript
import { DeepPartial, VendureEntity } from '@vendure/core';
import { Column, Entity } from 'typeorm';
@Entity('picqer_config')
export class PicqerConfigEntity extends VendureEntity {
  constructor(input?: DeepPartial<PicqerConfigEntity>) {
    super(input);
  }
  @Column({ unique: true })
  channelId!: string;
  @Column({ default: true })
  enabled!: boolean;
  @Column({ nullable: true, length: 1500 })
  apiKey?: string;
  @Column({ nullable: true })
  apiEndpoint?: string;
  @Column({ nullable: true })
  storefrontUrl?: string;
  @Column({ nullable: true })
  supportEmail?: string;
}
```

## File: packages/vendure-plugin-picqer/src/api/picqer.client.ts

```typescript
import { Logger } from '@vendure/core';
import axios, { AxiosInstance } from 'axios';
import crypto from 'crypto';
import { loggerCtx } from '../constants';
import {
  CustomerData,
  CustomerInput,
  OrderData,
  OrderInput,
  ProductData,
  ProductInput,
  VatGroup,
  Warehouse,
  WebhookData,
  WebhookInput,
} from './types';
export interface PicqerClientInput {
  apiEndpoint: string;
  apiKey: string;
  storefrontUrl: string;
  supportEmail: string;
}
export class PicqerClient {
  readonly instance: AxiosInstance;
  readonly responseLimit = 100;
  readonly apiKey: string;
  constructor({
    apiEndpoint,
    apiKey,
    storefrontUrl,
    supportEmail,
  }: PicqerClientInput) {
    apiEndpoint = apiEndpoint.replace(/\/$/, ''); // Remove trailing slash
    this.instance = axios.create({
      baseURL: `${apiEndpoint}/api/v1/`,
      timeout: 5000,
      headers: {
        Authorization: `Basic ${Buffer.from(apiKey + ':').toString('base64')}`,
        'User-Agent': `VendurePicqerPlugin (${storefrontUrl} - ${supportEmail})`,
      },
    });
    this.apiKey = apiKey;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async getStats(): Promise<any> {
    return this.rawRequest('get', '/stats');
  }
  async getVatGroups(): Promise<VatGroup[]> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const result = await this.rawRequest('get', '/vatgroups');
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    this.logIfLimitExceeded(result, '/vatgroups');
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return result;
  }
  /**
   * Fetches active and inactive products
   */
  async getProductByCode(
    productCode: string
  ): Promise<ProductData | undefined> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const [activeProducts, inactiveProducts] = await Promise.all([
      this.rawRequest(
        'get',
        `/products?productcode=${encodeURIComponent(productCode)}`
      ),
      this.rawRequest(
        'get',
        `/products?productcode=${encodeURIComponent(productCode)}&inactive`
      ),
    ]);
    const result = [...activeProducts, ...inactiveProducts];
    if (result.length > 1) {
      Logger.warn(
        `Picqer returned multiple products for product code ${productCode}, using the first result (${result[0].idproduct})`
      );
    }
    return result?.[0];
  }
  async getAllActiveProducts(): Promise<ProductData[]> {
    const allProducts: ProductData[] = [];
    let hasMore = true;
    let offset = 0;
    while (hasMore) {
      const products = await this.rawRequest(
        'get',
        `/products?offset=${offset}`
      );
      Logger.info(`Fetched ${products.length} products`, loggerCtx);
      allProducts.push(...products);
      if (products.length < this.responseLimit) {
        hasMore = false;
      } else {
        Logger.info(`Fetching more...`, loggerCtx);
      }
      offset += this.responseLimit;
    }
    Logger.info(`Fetched a total of ${allProducts.length} products`, loggerCtx);
    return allProducts;
  }
  async createProduct(input: ProductInput): Promise<ProductData> {
    return await this.rawRequest('post', '/products', input);
  }
  async updateProduct(
    productId: string | number,
    input: ProductInput
  ): Promise<ProductData> {
    return await this.rawRequest('put', `/products/${productId}`, input);
  }
  async addImage(
    productId: string | number,
    base64EncodedImage: string
  ): Promise<ProductData> {
    return await this.rawRequest('post', `/products/${productId}/images`, {
      image: base64EncodedImage,
    });
  }
  async getWebhooks(): Promise<WebhookData[]> {
    const allHooks = [];
    let hasMore = true;
    let offset = 0;
    while (hasMore) {
      const webhooks = await this.rawRequest('get', `/hooks?offset=${offset}`);
      allHooks.push(...webhooks);
      if (webhooks.length < this.responseLimit) {
        hasMore = false;
      }
      offset += this.responseLimit;
    }
    return allHooks as WebhookData[];
  }
  async createWebhook(input: WebhookInput): Promise<WebhookData> {
    return await this.rawRequest('post', `/hooks`, input);
  }
  async deactivateHook(id: number): Promise<void> {
    await await this.rawRequest('delete', `/hooks/${id}`);
  }
  async createOrder(input: OrderInput): Promise<OrderData> {
    return await this.rawRequest('post', `/orders/`, input);
  }
  async processOrder(id: number): Promise<OrderData> {
    return await this.rawRequest('post', `/orders/${id}/process`);
  }
  async getCustomer(emailAddress: string): Promise<CustomerData | undefined> {
    const customers: CustomerData[] = await this.rawRequest(
      'get',
      `/customers?search=${encodeURIComponent(emailAddress)}`
    );
    if (!customers.length) {
      return undefined;
    }
    if (customers.length === 1) {
      return customers[0];
    }
    const customer = customers[0];
    Logger.warn(
      `Picqer returned multiple customers for email address ${emailAddress}, using the first result (${customer.idcustomer})`,
      loggerCtx
    );
    return customer;
  }
  async getAllWarehouses(): Promise<Warehouse[]> {
    const allWarehouses: Warehouse[] = [];
    let hasMore = true;
    let offset = 0;
    while (hasMore) {
      const warehouses: Warehouse[] = await this.rawRequest(
        'get',
        `/warehouses?offset=${offset}`
      );
      Logger.info(`Fetched ${warehouses.length} warehouses`, loggerCtx);
      allWarehouses.push(...warehouses);
      if (warehouses.length < this.responseLimit) {
        hasMore = false;
      } else {
        Logger.info(`Fetching more...`, loggerCtx);
      }
      offset += this.responseLimit;
    }
    Logger.info(
      `Fetched a total of ${allWarehouses.length} warehouses`,
      loggerCtx
    );
    return allWarehouses;
  }
  async createCustomer(input: CustomerInput): Promise<CustomerData> {
    return await this.rawRequest('post', `/customers/`, input);
  }
  async updateCustomer(
    id: number,
    input: CustomerInput
  ): Promise<CustomerData> {
    return await this.rawRequest('put', `/customers/${id}`, input);
  }
  async createOrUpdateCustomer(
    emailAddress: string,
    input: CustomerInput
  ): Promise<CustomerData> {
    const existingCustomer = await this.getCustomer(emailAddress);
    if (!existingCustomer) {
      Logger.info(
        `Customer '${emailAddress}' not found, creating new customer`,
        loggerCtx
      );
      return this.createCustomer(input);
    }
    Logger.info(
      `Existing customer '${emailAddress}' found, updating customer ${existingCustomer.idcustomer}`,
      loggerCtx
    );
    return this.updateCustomer(existingCustomer.idcustomer, input);
  }
  async getOrCreateMinimalCustomer(
    emailAddress: string,
    name: string
  ): Promise<CustomerData> {
    const existingCustomer = await this.getCustomer(emailAddress);
    if (existingCustomer) {
      return existingCustomer;
    }
    Logger.info(
      `Customer '${emailAddress}' not found, creating new customer`,
      loggerCtx
    );
    return this.createCustomer({ emailaddress: emailAddress, name });
  }
  async createOrUpdateProduct(
    sku: string,
    input: ProductInput
  ): Promise<ProductData> {
    const product = await this.getProductByCode(sku);
    if (!product) {
      Logger.debug(
        `Product '${sku}' not found, creating new product in Picqer`,
        loggerCtx
      );
      return this.createProduct(input);
    }
    const productId = product.idproduct;
    Logger.debug(
      `Existing product '${productId}' found for sku '${sku}', updating product in Picqer`,
      loggerCtx
    );
    return this.updateProduct(productId, input);
  }
  async rawRequest(
    method: 'post' | 'get' | 'put' | 'delete',
    url: string,
    data?: any
  ): Promise<any> {
    const result = await this.instance({ method, url, data }).catch((e: any) =>
      this.handleError(e, url)
    );
    return result?.data;
  }
  isSignatureValid(data: string, incomingSignature: string): boolean {
    const computedSignature = crypto
      .createHmac('sha256', this.webhookSecret)
      .update(data)
      .digest('base64');
    return computedSignature === incomingSignature;
  }
  get webhookSecret(): string {
    return crypto
      .createHash('shake256', { outputLength: 10 })
      .update(this.apiKey)
      .digest('hex');
  }
  private handleError(e: any, url: string): void {
    if (e.response?.data?.error_message) {
      throw new Error(`${url}: ${e.response.data.error_message}`);
    } else {
      throw e;
    }
  }
  private logIfLimitExceeded(results: unknown[], path: string): void {
    if (results.length > this.responseLimit) {
      Logger.error(
        `Picqer response limit exceeded for "${path}". Pagination is required, but this is not implemented yet.`,
        loggerCtx
      );
    }
  }
}
```

## File: packages/vendure-plugin-picqer/src/api/picqer.controller.ts

```typescript
import {
  Controller,
  ForbiddenException,
  Headers,
  Param,
  Post,
  Req,
  BadRequestException,
  Get,
} from '@nestjs/common';
import { ChannelService, Logger, RequestContext } from '@vendure/core';
import { Request } from 'express';
import util from 'util';
import { loggerCtx } from '../constants';
import { PicqerService } from './picqer.service';
import { IncomingWebhook } from './types';
@Controller('picqer')
export class PicqerController {
  constructor(
    private picqerService: PicqerService,
    private channelService: ChannelService
  ) {}
  @Post('hooks/:channelToken')
  async webhook(
    @Req() request: Request,
    @Headers('X-Picqer-Signature') signature: string,
    @Param('channelToken') channelToken: string
  ): Promise<void> {
    const body = JSON.parse(request.body.toString()) as IncomingWebhook;
    const rawBody = (request as any).rawBody as string;
    Logger.info(
      `Incoming hook ${body.event} for channel ${channelToken}`,
      loggerCtx
    );
    try {
      await this.picqerService.handleHook({
        body,
        channelToken,
        rawBody,
        signature,
      });
    } catch (e: any) {
      const orderCode = (body as any)?.data?.reference as string;
      Logger.error(
        `Error handling incoming hook '${body.event}' (order code: ${orderCode}): ${e.message}`,
        loggerCtx,
        util.inspect(e)
      );
      throw e;
    }
  }
  @Get('pull-stock-levels/:channelToken')
  async pullStockLevels(
    @Headers('Authorization') authHeader: string,
    @Param('channelToken') channelToken: string
  ): Promise<void> {
    if (!authHeader) {
      throw new ForbiddenException('No bearer token provided');
    }
    const channel = await this.channelService.getChannelFromToken(channelToken);
    if (!channel) {
      throw new BadRequestException(
        `No channel found for token ${channelToken}`
      );
    }
    const apiKey = authHeader.replace('Bearer ', '').replace('bearer ', '');
    const ctx = new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel,
    });
    const picqerConfig = await this.picqerService.getConfig(ctx);
    if (picqerConfig?.apiKey !== apiKey) {
      throw new ForbiddenException('Invalid bearer token');
    }
    await this.picqerService.createStockLevelJob(ctx);
  }
}
```

## File: packages/vendure-plugin-picqer/src/api/picqer.handler.ts

```typescript
import { FulfillmentHandler, LanguageCode } from '@vendure/core';
export const picqerHandler = new FulfillmentHandler({
  code: 'picqer',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Fulfillment with Picqer',
    },
  ],
  args: {},
  init: () => {},
  createFulfillment: () => {
    throw Error(
      `Don't use fulfillment with Picqer. Directly transition to Shipped or Delivered instead.`
    );
  },
});
```

## File: packages/vendure-plugin-picqer/src/api/picqer.resolvers.ts

```typescript
import { Inject } from '@nestjs/common';
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Logger,
  PermissionDefinition,
  RequestContext,
} from '@vendure/core';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { PicqerOptions } from '../picqer.plugin';
import {
  PicqerConfig,
  PicqerConfigInput,
  TestPicqerInput,
} from '../ui/generated/graphql';
import { PicqerService } from './picqer.service';
export const picqerPermission = new PermissionDefinition({
  name: 'Picqer',
  description: 'Allows setting Picqer config and triggering Picqer full sync',
});
@Resolver()
export class PicqerResolver {
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS) private options: PicqerOptions,
    private service: PicqerService
  ) {}
  @Mutation()
  @Allow(picqerPermission.Permission)
  async triggerPicqerFullSync(@Ctx() ctx: RequestContext): Promise<boolean> {
    let allSucceeded = true;
    await this.service
      .createStockLevelJob(ctx)
      .catch((e: Error | undefined) => {
        Logger.error(
          `Failed to create jobs to pull stock levels from Picqer: ${e?.message}`,
          loggerCtx,
          e?.stack
        );
        allSucceeded = false;
      });
    await this.service
      .createPushProductsJob(ctx)
      .catch((e: Error | undefined) => {
        Logger.error(
          `Failed to create jobs to push products to Picqer: ${e?.message}`,
          loggerCtx,
          e?.stack
        );
        allSucceeded = false;
      });
    return allSucceeded;
  }
  @Mutation()
  @Allow(picqerPermission.Permission)
  async upsertPicqerConfig(
    @Ctx() ctx: RequestContext,
    @Args('input') input: PicqerConfigInput
  ): Promise<PicqerConfig> {
    return this.service.upsertConfig(ctx, input);
  }
  @Query()
  @Allow(picqerPermission.Permission)
  async picqerConfig(@Ctx() ctx: RequestContext): Promise<PicqerConfig | null> {
    return this.service.getConfig(ctx);
  }
  @Query()
  @Allow(picqerPermission.Permission)
  async isPicqerConfigValid(
    @Ctx() ctx: RequestContext,
    @Args('input') input: TestPicqerInput
  ): Promise<boolean> {
    return this.service.testRequest(input);
  }
}
```

## File: packages/vendure-plugin-picqer/src/api/picqer.service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import {
  OrderAddress,
  UpdateProductVariantInput,
} from '@vendure/common/lib/generated-types';
import {
  Address,
  AssetService,
  ChannelService,
  ConfigService,
  Customer,
  EntityHydrator,
  ErrorResult,
  EventBus,
  ForbiddenError,
  ID,
  JobQueue,
  JobQueueService,
  Logger,
  Order,
  OrderPlacedEvent,
  OrderService,
  OrderStateTransitionError,
  ProductVariant,
  ProductVariantEvent,
  ProductVariantService,
  RequestContext,
  SerializedRequestContext,
  StockLevel,
  StockLevelService,
  StockLocation,
  StockLocationService,
  StockMovementEvent,
  TransactionalConnection,
} from '@vendure/core';
import { StockAdjustment } from '@vendure/core/dist/entity/stock-movement/stock-adjustment.entity';
import currency from 'currency.js';
import util from 'util';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { PicqerOptions } from '../picqer.plugin';
import {
  PicqerConfig,
  PicqerConfigInput,
  TestPicqerInput,
} from '../ui/generated/graphql';
import { PicqerConfigEntity } from './picqer-config.entity';
import { PicqerClient, PicqerClientInput } from './picqer.client';
import { picqerHandler } from './picqer.handler';
import {
  AddressInput,
  CustomerData,
  CustomerInput,
  IncomingWebhook,
  OrderData,
  OrderInput,
  OrderProductInput,
  ProductData,
  ProductInput,
  WebhookEvent,
} from './types';
interface PushVariantsJob {
  action: 'push-variants';
  ctx: SerializedRequestContext;
  variantIds: ID[];
}
interface PullStockLevelsJob {
  action: 'pull-stock-levels';
  ctx: SerializedRequestContext;
}
interface PushOrderJob {
  action: 'push-order';
  ctx: SerializedRequestContext;
  orderId: ID;
}
type JobData = PushVariantsJob | PullStockLevelsJob | PushOrderJob;
@Injectable()
export class PicqerService implements OnApplicationBootstrap {
  private jobQueue!: JobQueue<JobData>;
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS) private options: PicqerOptions,
    private eventBus: EventBus,
    private jobQueueService: JobQueueService,
    private connection: TransactionalConnection,
    private variantService: ProductVariantService,
    private assetService: AssetService,
    private configService: ConfigService,
    private entityHydrator: EntityHydrator,
    private channelService: ChannelService,
    private orderService: OrderService,
    private stockLocationService: StockLocationService,
    private stockLevelService: StockLevelService
  ) {}
  async onApplicationBootstrap() {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'picqer-sync',
      process: async ({ data }) => {
        const ctx = RequestContext.deserialize(data.ctx);
        if (data.action === 'push-variants') {
          await this.handlePushVariantsJob(ctx, data.variantIds).catch(
            (e: any) => {
              throw Error(
                `Failed to push variants to Picqer (variants: ${data.variantIds?.join(
                  ','
                  // eslint-disable-next-line  @typescript-eslint/no-unsafe-member-access
                )}): ${e?.message}`
              );
            }
          );
        } else if (data.action === 'pull-stock-levels') {
          await this.handlePullStockLevelsJob(ctx).catch((e: any) => {
            throw Error(
              `Failed to pull stock levels from  Picqer: ${e?.message}`
            );
          });
        } else if (data.action === 'push-order') {
          const order = await this.orderService.findOne(ctx, data.orderId);
          await this.handlePushOrderJob(ctx, data.orderId).catch((e: any) => {
            throw Error(
              `Failed to push order ${order?.code} (${data.orderId}) to Picqer: ${e?.message}`
            );
          });
        } else {
          Logger.error(
            `Invalid job action: ${(data as any).action}`,
            loggerCtx
          );
        }
        Logger.info(`Successfully handled job '${data.action}'`, loggerCtx);
      },
    });
    this.eventBus
      .ofType(ProductVariantEvent)
      .subscribe(async ({ ctx, entity: entities, type, input }) => {
        if (type !== 'created' && type !== 'updated') {
          return;
        }
        const shouldUpdate = (input as UpdateProductVariantInput[])?.some(
          (v) =>
            v.translations ??
            v.price ??
            v.taxCategoryId ??
            (this.options.shouldSyncOnProductVariantCustomFields ?? []).some(
              (customFieldName) =>
                v.customFields ? v.customFields[customFieldName] : false
            )
        );
        if (!shouldUpdate) {
          Logger.info(
            `No relevant changes to variants ${JSON.stringify(
              entities.map((v) => v.sku)
            )}, not pushing to Picqer`,
            loggerCtx
          );
          return;
        }
        await this.addPushVariantsJob(
          ctx,
          entities.map((v) => v.id)
        );
      });
    this.eventBus.ofType(OrderPlacedEvent).subscribe(async ({ ctx, order }) => {
      await this.addPushOrderJob(ctx, order);
    });
    for (const config of await this.getAllConfigs()) {
      const ctx = await this.getCtxForChannel(config.channelId);
      await this.registerWebhooks(ctx, config).catch((e) =>
        Logger.error(
          `Failed to register webhooks for channel ${ctx.channel.token}: ${e?.message}`,
          loggerCtx
        )
      );
    }
  }
  async registerWebhooks(
    ctx: RequestContext,
    config: PicqerConfig
  ): Promise<void> {
    const hookUrl = `${this.options.vendureHost}/picqer/hooks/${ctx.channel.token}`;
    const client = await this.getClient(ctx, config);
    if (!client) {
      return;
    }
    const eventsToRegister: WebhookEvent[] = [
      'orders.status_changed',
      'products.free_stock_changed',
      'products.assembled_stock_changed',
    ];
    const webhooks = await client.getWebhooks();
    for (const hookEvent of eventsToRegister) {
      const webhookName = `Vendure ${client.webhookSecret.slice(0, 4)}`;
      let hook = webhooks.find(
        (h) =>
          h.event === hookEvent && h.address === hookUrl && h.active === true
      );
      if (hook && hook.name !== webhookName) {
        Logger.info(`Deactivating outdated hook ${hook.name}`);
        await client.deactivateHook(hook.idhook);
        hook = undefined;
      }
      if (!hook) {
        const webhook = await client.createWebhook({
          name: webhookName,
          address: hookUrl,
          event: hookEvent,
          secret: client.webhookSecret,
        });
        Logger.info(
          `Registered hook (id: ${webhook.idhook}) for event ${hookEvent} and url ${hookUrl}`,
          loggerCtx
        );
      }
    }
    Logger.info(
      `Registered webhooks for channel ${ctx.channel.token}`,
      loggerCtx
    );
  }
  async handleHook(input: {
    channelToken: string;
    body: IncomingWebhook;
    rawBody: string;
    signature: string;
  }): Promise<void> {
    const ctx = await this.getCtxForChannel(input.channelToken);
    const client = await this.getClient(ctx);
    if (!client) {
      Logger.error(
        `No client found for channel ${input.channelToken}`,
        loggerCtx
      );
      return;
    }
    if (!client.isSignatureValid(input.rawBody, input.signature)) {
      Logger.error(
        `Invalid signature for incoming webhook ${input.body.event} channel ${input.channelToken}`,
        loggerCtx
      );
      throw new ForbiddenError();
    }
    if (
      input.body.event === 'products.free_stock_changed' ||
      input.body.event === 'products.assembled_stock_changed'
    ) {
      await this.updateStockBySkus(ctx, [input.body.data]);
    } else if (input.body.event === 'orders.status_changed') {
      await this.handleOrderStatusChanged(ctx, input.body.data);
    } else {
      Logger.warn(
        `Unknown event ${
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
          (input.body as any).event
        } for incoming webhook for channel ${
          input.channelToken
        }. Not handling this webhook...`,
        loggerCtx
      );
      return;
    }
    Logger.info(`Successfully handled hook ${input.body.event}`, loggerCtx);
  }
  async createPushProductsJob(ctx: RequestContext): Promise<void> {
    const variantIds: ID[] = [];
    let skip = 0;
    const take = 1000;
    let hasMore = true;
    while (hasMore) {
      const [variants, count] = await this.connection
        .getRepository(ctx, ProductVariant)
        .createQueryBuilder('variant')
        .select(['variant.id'])
        .leftJoin('variant.channels', 'channel')
        .leftJoin('variant.product', 'product')
        .where('channel.id = :channelId', { channelId: ctx.channelId })
        .andWhere('variant.deletedAt IS NULL')
        .andWhere('variant.enabled = true')
        .andWhere('product.deletedAt IS NULL')
        .andWhere('product.enabled is true')
        .skip(skip)
        .take(take)
        .getManyAndCount();
      variantIds.push(...variants.map((v) => v.id));
      if (variantIds.length >= count) {
        hasMore = false;
      }
      skip += take;
    }
    const batchSize = 10;
    while (variantIds.length) {
      await this.addPushVariantsJob(ctx, variantIds.splice(0, batchSize));
    }
  }
  async createStockLevelJob(ctx: RequestContext): Promise<void> {
    await this.jobQueue.add(
      {
        action: 'pull-stock-levels',
        ctx: ctx.serialize(),
      },
      { retries: 10 }
    );
    Logger.info(`Added 'pull-stock-levels' job to queue`, loggerCtx);
  }
  async handleOrderStatusChanged(ctx: RequestContext, data: OrderData) {
    const order = await this.orderService.findOneByCode(ctx, data.reference, [
      'lines',
      'lines.productVariant',
    ]);
    if (!order) {
      Logger.warn(
        `No order found for code ${data.reference}. Not processing this hook any further`,
        loggerCtx
      );
      return;
    }
    if (
      data.status === 'cancelled' &&
      order.state !== 'Cancelled' &&
      this.options.cancelOrdersOnPicqerCancellation
    ) {
      const result = await this.orderService.cancelOrder(ctx, {
        orderId: order.id,
        reason: 'Cancelled in Picqer',
        cancelShipping: true,
      });
      if ((result as ErrorResult).errorCode) {
        Logger.error(
          `Failed to cancel order ${order.code}: ${
            (result as ErrorResult).message
          }. Ensure the order process is configured with "checkFulfillmentStates: false"`,
          loggerCtx,
          util.inspect(result)
        );
        return;
      }
      Logger.info(`Cancelled order ${order.code}`, loggerCtx);
      return;
    }
    if (
      data.status === 'completed' &&
      order.state !== 'Delivered' &&
      order.state !== 'Cancelled'
    ) {
      try {
        await this.transitionToState(ctx, order, 'Shipped');
        await this.transitionToState(ctx, order, 'Delivered');
      } catch (e) {
        return;
      }
    }
    Logger.info(
      `Not handling incoming status '${data.status}' because order ${order.code} is already '${order.state}'`,
      loggerCtx
    );
  }
  async transitionToState(
    ctx: RequestContext,
    order: Order,
    state: 'Shipped' | 'Delivered'
  ) {
    const result = await this.orderService.transitionToState(
      ctx,
      order.id,
      state
    );
    const errorResult = result as OrderStateTransitionError;
    if (errorResult.errorCode) {
      Logger.error(
        `Failed to transition order ${order.code} to ${state}: ${errorResult.message}`,
        loggerCtx,
        util.inspect(errorResult)
      );
      throw errorResult;
    }
  }
  async addPushVariantsJob(
    ctx: RequestContext,
    variantIds: ID[]
  ): Promise<void> {
    await this.jobQueue.add(
      {
        action: 'push-variants',
        ctx: ctx.serialize(),
        variantIds,
      },
      { retries: 10 }
    );
    Logger.info(
      `Added job to the 'push-variants' queue for ${variantIds.length} variants for channel ${ctx.channel.token}`,
      loggerCtx
    );
  }
  async addPushOrderJob(ctx: RequestContext, order: Order): Promise<void> {
    await this.jobQueue
      .add(
        {
          action: 'push-order',
          ctx: ctx.serialize(),
          orderId: order.id,
        },
        { retries: 10 }
      )
      .catch((e) => {
        Logger.error(
          `Failed to add job to 'push-order' queue for order ${order.code}: ${e?.message}`,
          loggerCtx
        );
        throw e;
      });
    Logger.info(
      `Added job to the 'push-order' queue for order ${order.code}`,
      loggerCtx
    );
  }
  async handlePullStockLevelsJob(userCtx: RequestContext): Promise<void> {
    const ctx = this.createDefaultLanguageContext(userCtx);
    const client = await this.getClient(ctx);
    if (!client) {
      return;
    }
    await this.syncWarehouses(ctx).catch((e: any) => {
      Logger.error(
        `Failed to sync warehouses with Picqer: ${e?.message}`,
        loggerCtx,
        util.inspect(e)
      );
    });
    const picqerProducts = await client.getAllActiveProducts();
    await this.updateStockBySkus(ctx, picqerProducts);
    Logger.info(`Successfully pulled stock levels from Picqer`, loggerCtx);
  }
  async syncWarehouses(ctx: RequestContext): Promise<void> {
    const client = await this.getClient(ctx);
    if (!client) {
      return;
    }
    const syncedFromPicqer: ID[] = [];
    const warehouses = await client.getAllWarehouses();
    for (const warehouse of warehouses) {
      const existing = await this.getStockLocation(ctx, warehouse.idwarehouse);
      if (!warehouse.active) {
        continue;
      }
      const stockLocationName = `Picqer ${warehouse.idwarehouse}: ${warehouse.name}`;
      const stocklocationDescription = `Mirrored warehouse from Picqer '${warehouse.name}' (${warehouse.idwarehouse})`;
      if (existing) {
        await this.stockLocationService.update(ctx, {
          id: existing.id,
          name: stockLocationName,
          description: stocklocationDescription,
        });
        syncedFromPicqer.push(existing.id);
        Logger.info(`Updated stock location '${stockLocationName}'`, loggerCtx);
      } else {
        const created = await this.stockLocationService.create(ctx, {
          name: stockLocationName,
          description: stocklocationDescription,
        });
        syncedFromPicqer.push(created.id);
        Logger.info(
          `Created new stock location '${stockLocationName}'`,
          loggerCtx
        );
      }
    }
    const locations = await this.stockLocationService.findAll(ctx);
    const locationsToDelete = locations.items.filter(
      (l) => !syncedFromPicqer.includes(l.id)
    );
    for (const location of locationsToDelete) {
      const res = await this.stockLocationService.delete(ctx, {
        id: location.id,
      });
      if (res.result === 'DELETED') {
        Logger.info(`Deleted stock location ${location.name}`, loggerCtx);
      } else {
        Logger.error(
          `Failed to delete stock location ${location.name}: ${res.message}`,
          loggerCtx
        );
      }
    }
    Logger.info(`Successfully synced warehouses from Picqer`, loggerCtx);
  }
  async getStockLocation(
    ctx: RequestContext,
    picqerLocationId: number
  ): Promise<StockLocation | undefined> {
    const { items } = await this.stockLocationService.findAll(ctx, {
      filter: {
        name: { contains: `Picqer ${picqerLocationId}` },
      },
    });
    const location = items[0];
    if (items.length > 1) {
      Logger.error(
        `Found multiple locations with name "Picqer ${picqerLocationId}", there should be only one! Using location with ID ${location.id}`,
        loggerCtx
      );
    }
    return location;
  }
  async updateStockBySkus(
    ctx: RequestContext,
    picqerProducts: ProductData[]
  ): Promise<void> {
    const vendureVariants = await this.findAllVariantsBySku(
      ctx,
      picqerProducts.map((p) => p.productcode)
    );
    const stockAdjustments: StockAdjustment[] = [];
    await Promise.all(
      vendureVariants.map(async (variant) => {
        const picqerProduct = picqerProducts.find(
          (p) => p.productcode === variant.sku
        );
        if (!picqerProduct) {
          Logger.error(
            `No Picqer product found for variant ${variant.sku}`,
            loggerCtx
          );
          return;
        }
        if (picqerProduct.unlimitedstock) {
          Logger.info(
            `Not updating stock of variant '${variant.sku}', because it has unlimited stock in Picqer`,
            loggerCtx
          );
          return;
        }
        let additionalVariantFields = {};
        try {
          additionalVariantFields =
            this.options.pullPicqerProductFields?.(picqerProduct) || {};
        } catch (e: any) {
          Logger.error(
            `Failed to get additional fields from the configured pullFieldsFromPicqer function: ${e?.message}`,
            loggerCtx
          );
        }
        await this.connection
          .getRepository(ctx, ProductVariant)
          .update({ id: variant.id }, additionalVariantFields);
        for (const picqerStock of picqerProduct.stock) {
          if (!picqerStock.idwarehouse) {
            Logger.error(
              `Can not update stock for picqer warehouse without id`,
              loggerCtx
            );
            continue;
          }
          const location = await this.getStockLocation(
            ctx,
            picqerStock.idwarehouse
          );
          if (!location) {
            Logger.info(
              `Not updating stock of warehouse ${picqerStock.idwarehouse}, because it doesn't exist in Vendure. You might need to re-sync stock levels and locations if this is an active warehouse.`
            );
            continue;
          }
          const { id: stockLevelId, stockOnHand } =
            await this.stockLevelService.getStockLevel(
              ctx,
              variant.id,
              location.id
            );
          const allocated = picqerStock.reservedallocations ?? 0;
          const newStockOnHand = allocated + picqerStock.freestock;
          const delta = newStockOnHand - stockOnHand;
          await this.connection.getRepository(ctx, StockLevel).save({
            id: stockLevelId,
            stockOnHand: picqerStock.freestock,
            stockAllocated: 0,
          });
          stockAdjustments.push(
            new StockAdjustment({
              quantity: delta,
              productVariant: { id: variant.id },
            })
          );
        }
      })
    );
    if (!stockAdjustments.length) {
      Logger.warn(
        `No stock levels updated. This means none of the products in Picqer exist in Vendure yet.`,
        loggerCtx
      );
      return;
    }
    await this.eventBus.publish(new StockMovementEvent(ctx, stockAdjustments));
    Logger.info(
      `Updated stock levels of ${stockAdjustments.length} variants`,
      loggerCtx
    );
  }
  async handlePushOrderJob(ctx: RequestContext, orderId: ID): Promise<void> {
    const client = await this.getClient(ctx);
    if (!client) {
      return;
    }
    const order = await this.orderService.findOne(ctx, orderId, [
      'lines',
      'lines.productVariant',
      'lines.productVariant.translations',
      'lines.productVariant.taxCategory',
      'customer',
      'customer.addresses',
      'shippingLines',
      'shippingLines.shippingMethod',
    ]);
    if (!order) {
      Logger.error(
        `Order with id ${orderId} not found, ignoring this order...`,
        loggerCtx
      );
      return;
    }
    const hasPicqerHandler = order.shippingLines.some(
      (s) => s.shippingMethod?.fulfillmentHandlerCode === picqerHandler.code
    );
    if (!hasPicqerHandler) {
      Logger.info(
        `Order ${order.code} doesn't have the Picqer handler set in shipping lines, ignoring this order...`,
        loggerCtx
      );
      return;
    }
    await this.pushOrderToPicqer(ctx, order, client);
  }
  async pushOrderToPicqer(
    ctx: RequestContext,
    order: Order,
    picqerClient: PicqerClient
  ): Promise<void> {
    if (!order.customer) {
      throw Error(
        `Cannot push order '${order.code}' to picqer without an order.customer`
      );
    }
    let picqerCustomer: CustomerData | undefined = undefined;
    if (order.customer.user) {
      const name =
        order.shippingAddress.company ??
        order.shippingAddress.fullName ??
        `${order.customer.firstName} ${order.customer.lastName}`;
      picqerCustomer = await picqerClient.getOrCreateMinimalCustomer(
        order.customer.emailAddress,
        name
      );
    }
    const vatGroups = await picqerClient.getVatGroups();
    const productInputs: OrderProductInput[] = [];
    for (const line of order.lines) {
      const vatGroup = vatGroups.find(
        (vg) => vg.percentage === line.productVariant.taxRateApplied.value
      );
      if (!vatGroup) {
        throw Error(
          `Can not find vat group ${line.productVariant.taxRateApplied.value}% for variant ${line.productVariant.sku}. Can not create order in Picqer`
        );
      }
      const picqerProduct = await picqerClient.createOrUpdateProduct(
        line.productVariant.sku,
        this.mapToProductInput(ctx, line.productVariant, vatGroup.idvatgroup)
      );
      const additionalOrderLineFields =
        this.options.pushPicqerOrderLineFields?.(ctx, line, order) || {};
      productInputs.push({
        idproduct: picqerProduct.idproduct,
        amount: line.quantity,
        ...additionalOrderLineFields,
      });
    }
    let orderInput = this.mapToOrderInput(
      order,
      productInputs,
      picqerCustomer?.idcustomer
    );
    if (this.options.pushPicqerOrderFields) {
      const additionalFields = this.options.pushPicqerOrderFields(order);
      orderInput = {
        ...orderInput,
        ...additionalFields,
      };
      Logger.info(
        `Added custom order fields to order '${order.code}'`,
        loggerCtx
      );
    }
    const createdOrder = await picqerClient.createOrder(orderInput);
    await picqerClient.processOrder(createdOrder.idorder);
    Logger.info(
      `Created order "${order.code}" in status "processing" in Picqer with id ${createdOrder.idorder}`,
      loggerCtx
    );
  }
  async findAllVariantsBySku(
    ctx: RequestContext,
    skus: string[]
  ): Promise<Pick<ProductVariant, 'id' | 'sku'>[]> {
    let skip = 0;
    const take = 1000;
    let hasMore = true;
    const allVariants: ProductVariant[] = [];
    while (hasMore) {
      const [variants, count] = await this.connection
        .getRepository(ctx, ProductVariant)
        .createQueryBuilder('variant')
        .select(['variant.id', 'variant.sku'])
        .leftJoin('variant.channels', 'channel')
        .where('channel.id = :channelId', { channelId: ctx.channelId })
        .andWhere('variant.sku IN(:...skus)', { skus })
        .andWhere('variant.deletedAt IS NULL')
        .skip(skip)
        .take(take)
        .getManyAndCount();
      allVariants.push(...variants);
      if (allVariants.length >= count) {
        hasMore = false;
      }
      skip += take;
    }
    return allVariants;
  }
  async handlePushVariantsJob(
    userCtx: RequestContext,
    variantIds: ID[]
  ): Promise<void> {
    const ctx = this.createDefaultLanguageContext(userCtx);
    const client = await this.getClient(ctx);
    if (!client) {
      return;
    }
    const variants = await this.variantService.findByIds(ctx, variantIds);
    const vatGroups = await client.getVatGroups();
    await Promise.all(
      variants.map(async (variant) => {
        const vatGroup = vatGroups.find(
          (vg) => vg.percentage === variant.taxRateApplied.value
        );
        if (!vatGroup) {
          Logger.error(
            `Could not find vatGroup for taxRate ${variant.taxRateApplied.value} for variant ${variant.sku}. Not pushing this variant to Picqer`,
            loggerCtx
          );
          return;
        }
        try {
          const productInput = this.mapToProductInput(
            ctx,
            variant,
            vatGroup.idvatgroup
          );
          const picqerProduct = await client.createOrUpdateProduct(
            variant.sku,
            productInput
          );
          const shouldUpdateImages = !picqerProduct.images?.length;
          if (!shouldUpdateImages) {
            return;
          }
          const featuredImage = await this.getFeaturedImageAsBase64(
            ctx,
            variant
          );
          if (featuredImage) {
            await client.addImage(picqerProduct.idproduct, featuredImage);
            Logger.info(
              `Added image for variant ${variant.sku} in Picqer for channel ${ctx.channel.token}`,
              loggerCtx
            );
          }
        } catch (e: any) {
          throw new Error(
            `Error pushing variant ${variant.sku} to Picqer: ${e?.message}`
          );
        }
      })
    );
  }
  async upsertConfig(
    ctx: RequestContext,
    input: PicqerConfigInput
  ): Promise<PicqerConfig> {
    const repository = this.connection.getRepository(ctx, PicqerConfigEntity);
    const existing = await repository.findOne({
      where: {
        channelId: String(ctx.channelId),
      },
    });
    if (existing) {
      (input as Partial<PicqerConfigEntity>).id = existing.id;
    }
    await repository.save({
      ...input,
      channelId: ctx.channelId,
    } as PicqerConfigEntity);
    Logger.info(
      `Picqer config updated for channel ${ctx.channel.token} by user ${ctx.activeUserId}`,
      loggerCtx
    );
    const config = await repository.findOneOrFail({
      where: {
        channelId: String(ctx.channelId),
      },
    });
    await this.registerWebhooks(ctx, config).catch((e) =>
      Logger.error(
        `Failed to register webhooks for channel ${ctx.channel.token}: ${e?.message}`,
        loggerCtx
      )
    );
    return config;
  }
  createDefaultLanguageContext(ctx: RequestContext): RequestContext {
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      languageCode: ctx.channel.defaultLanguageCode,
      channel: ctx.channel,
    });
  }
  async getClient(
    ctx: RequestContext,
    config?: PicqerConfig
  ): Promise<PicqerClient | undefined> {
    if (!config) {
      config = (await this.getConfig(ctx)) ?? undefined;
    }
    if (!config || !config.enabled) {
      Logger.info(
        `Picqer is not enabled for channel ${ctx.channel.token}`,
        loggerCtx
      );
      return;
    }
    if (
      !config.apiKey ||
      !config.apiEndpoint ||
      !config.storefrontUrl ||
      !config.supportEmail
    ) {
      Logger.warn(
        `Picqer config is incomplete for channel ${ctx.channel.token}`,
        loggerCtx
      );
      return;
    }
    return new PicqerClient(config as PicqerClientInput);
  }
  async getFeaturedImageAsBase64(
    ctx: RequestContext,
    variant: ProductVariant
  ): Promise<string | undefined> {
    let asset = await this.assetService.getFeaturedAsset(ctx, variant);
    if (!asset?.preview && this.options.fallBackToProductFeaturedAsset) {
      await this.entityHydrator.hydrate(ctx, variant, {
        relations: ['product'],
      });
      asset = await this.assetService.getFeaturedAsset(ctx, variant.product);
    }
    if (!asset?.preview) {
      return;
    }
    const image = asset.preview;
    const hasAllowedExtension = ['png', 'jpg', 'jpeg'].some((extension) =>
      image.endsWith(extension)
    );
    if (!hasAllowedExtension) {
      Logger.info(
        `featured asset for variant ${variant.sku} is not a png or jpeg, skipping`,
        loggerCtx
      );
      return;
    }
    const buffer =
      await this.configService.assetOptions.assetStorageStrategy.readFileToBuffer(
        image
      );
    return buffer.toString('base64');
  }
  async getConfig(ctx: RequestContext): Promise<PicqerConfig | null> {
    const repository = this.connection.getRepository(ctx, PicqerConfigEntity);
    return repository.findOne({ where: { channelId: String(ctx.channelId) } });
  }
  async getAllConfigs(): Promise<PicqerConfigEntity[]> {
    const repository =
      this.connection.rawConnection.getRepository(PicqerConfigEntity);
    return repository.find();
  }
  async testRequest(input: TestPicqerInput): Promise<boolean> {
    const client = new PicqerClient(input);
    try {
      await client.getStats();
      return true;
    } catch (e) {
      return false;
    }
  }
  async getCtxForChannel(channelToken: string): Promise<RequestContext> {
    const channel = await this.channelService.getChannelFromToken(channelToken);
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel,
    });
  }
  mapToCustomerInput(customer: Customer, companyName?: string): CustomerInput {
    const customerName = `${customer.firstName} ${customer.lastName}`;
    return {
      name: companyName || customerName,
      contactname: customerName,
      emailaddress: customer.emailAddress,
      telephone: customer.phoneNumber,
      addresses: customer.addresses.map(this.mapToAddressInput),
    };
  }
  mapToAddressInput(address: Address): AddressInput {
    return {
      name: address.fullName,
      address: `${address.streetLine1} ${address.streetLine2 ?? ''}`.trim(),
      zipcode: address.postalCode,
      city: address.city,
      country: address.country?.code.toUpperCase(),
      defaultdelivery: address.defaultShippingAddress,
      defaultinvoice: address.defaultBillingAddress,
    };
  }
  mapToProductInput(
    ctx: RequestContext,
    variant: ProductVariant,
    vatGroupId: number
  ): ProductInput {
    const additionalFields =
      this.options.pushProductVariantFields?.(variant) || {};
    if (!variant.sku) {
      throw Error(`Variant with ID ${variant.id} has no SKU`);
    }
    let name: string =
      variant.translations?.find(
        (t) => t.languageCode === ctx.channel.defaultLanguageCode
      )?.name ??
      variant.name ??
      variant.translations?.[0]?.name;
    if (!name) {
      Logger.info(
        `Variant ${variant.sku} has no name, using SKU as name for Picqer product`,
        loggerCtx
      );
      name = variant.sku;
    }
    return {
      ...additionalFields,
      idvatgroup: vatGroupId,
      name,
      price: currency(variant.price / 100).value,
      productcode: variant.sku,
      active: true,
    };
  }
  mapToOrderInput(
    order: Order,
    products: OrderProductInput[],
    customerId?: number
  ): OrderInput {
    if (!order.customer) {
      throw Error(
        `Cannot map order '${order.code}' to Picqer order without order.customer`
      );
    }
    const shippingAddress = order.shippingAddress;
    const billingAddress = order.billingAddress;
    const customerFullname = [order.customer.firstName, order.customer.lastName]
      .join(' ')
      .trim();
    const [deliveryname, deliverycontactname] =
      this.getAddressName(shippingAddress);
    const [invoicename, invoicecontactname] =
      this.getAddressName(billingAddress);
    return {
      idcustomer: customerId,
      reference: order.code,
      emailaddress: order.customer.emailAddress,
      telephone: order.customer.phoneNumber,
      deliveryname: deliveryname ?? customerFullname,
      deliverycontactname,
      deliveryaddress: this.getFullAddress(shippingAddress),
      deliveryzipcode: shippingAddress.postalCode,
      deliverycity: shippingAddress.city,
      deliverycountry: shippingAddress.countryCode?.toUpperCase(),
      invoicename:
        invoicename?.trim() ||
        deliveryname?.trim() ||
        customerFullname ||
        order.customer.emailAddress,
      invoicecontactname,
      invoiceaddress: this.getFullAddress(billingAddress),
      invoicezipcode: billingAddress?.postalCode,
      invoicecity: billingAddress?.city,
      invoicecountry: order.billingAddress?.countryCode?.toUpperCase(),
      products,
    };
  }
  private getFullAddress(address?: OrderAddress): string | undefined {
    if (!address?.streetLine1 && !address?.streetLine2) {
      return undefined;
    }
    return [address.streetLine1 ?? '', address.streetLine2 ?? '']
      .join(' ')
      .trim();
  }
  /**
   * Get name and contactname for given address
   * returns [name, contactname]
   *
   * If a company is given, use the company as name and the full name as contact name
   * Otherwise, use the full name as name and no explicit contact name
   */
  private getAddressName(
    address?: Pick<OrderAddress, 'company' | 'fullName'>
  ): [string | undefined, string | undefined] {
    let name;
    let contactname;
    if (address?.company?.trim()) {
      name = address.company;
      contactname = address.fullName;
    } else {
      name = address?.fullName;
      contactname = undefined;
    }
    return [name, contactname];
  }
}
```

## File: packages/vendure-plugin-picqer/src/api/types.ts

```typescript
export interface ProductInput {
  name: string;
  idvatgroup: number;
  productcode: string;
  price: number;
  description?: string;
  barcode?: string;
  active?: boolean;
}
export interface VatGroup {
  idvatgroup: number;
  name: string;
  percentage: number;
}
export interface ProductData {
  idproduct: number;
  idvatgroup: number;
  idsupplier: any;
  productcode: string;
  name: string;
  price: number;
  fixedstockprice: number;
  productcode_supplier: string;
  deliverytime: any;
  description: string;
  barcode: string;
  type: string;
  unlimitedstock: boolean;
  weight: number;
  minimum_purchase_quantity: number;
  purchase_in_quantities_of: number;
  hs_code: any;
  country_of_origin: any;
  active: boolean;
  productfields: Productfield[];
  images: string[];
  stock: Stock[];
}
export interface Productfield {
  idproductfield: number;
  title: string;
  value: string;
}
export interface Stock {
  idwarehouse: number;
  stock: number;
  reserved: number;
  reservedbackorders: number;
  reservedpicklists: number;
  reservedallocations: number;
  freestock: number;
  freepickablestock: number;
}
export interface Warehouse {
  idwarehouse: number;
  name: string;
  accept_orders: boolean;
  counts_for_general_stock: boolean;
  priority: number;
  active: boolean;
}
export interface CustomerData {
  idcustomer: number;
  idtemplate: any;
  customerid: string;
  name: string;
  contactname: string;
  telephone: string;
  emailaddress: string;
  discount: number;
  vatnumber: string;
  calculatevat: boolean;
  default_order_remarks: string;
  auto_split: boolean;
  language: string;
  addresses: AddressData[];
}
export interface AddressData {
  idcustomer_address: number;
  name: string;
  contactname: any;
  address: string;
  address2: any;
  zipcode: string;
  city: string;
  region: any;
  country: string;
  defaultinvoice: boolean;
  defaultdelivery: boolean;
}
export interface CustomerInput {
  name: string;
  contactname?: string;
  telephone?: string;
  emailaddress?: string;
  addresses?: AddressInput[];
}
export interface AddressInput {
  name: string;
  address?: string;
  zipcode?: string;
  city?: string;
  region?: any;
  country?: string;
  defaultinvoice?: boolean;
  defaultdelivery?: boolean;
}
export interface OrderData {
  idorder: number;
  idcustomer: number;
  idtemplate: number;
  idshippingprovider_profile: any;
  orderid: string;
  deliveryname: string;
  deliverycontactname: string;
  deliveryaddress: string;
  deliveryaddress2: any;
  deliveryzipcode: string;
  deliverycity: string;
  deliveryregion: any;
  deliverycountry: string;
  full_delivery_address: string;
  invoicename: string;
  invoicecontactname: string;
  invoiceaddress: string;
  invoiceaddress2: any;
  invoicezipcode: string;
  invoicecity: string;
  invoiceregion: any;
  invoicecountry: string;
  full_invoice_address: string;
  telephone: any;
  emailaddress: any;
  reference: string;
  customer_remarks: any;
  pickup_point_data: any;
  partialdelivery: boolean;
  auto_split: boolean;
  invoiced: boolean;
  preferred_delivery_date: any;
  discount: number;
  calculatevat: boolean;
  status: 'cancelled' | 'completed' | 'processing' | 'concept' | 'expecteds';
  public_status_page: string;
  created: string;
  updated: string;
  warehouses: number[];
  products: OrderProduct[];
  pricelists: number[];
}
export interface OrderProduct {
  idorder_product: number;
  idproduct: number;
  idvatgroup: number;
  productcode: string;
  name: string;
  remarks: string;
  price: number;
  amount: number;
  amount_cancelled: number;
  weight: number;
  partof_idorder_product: any;
  has_parts: boolean;
}
export interface OrderInput {
  idcustomer?: number;
  reference: string;
  emailaddress: string;
  telephone: string;
  deliveryname: string;
  deliverycontactname?: string;
  deliveryaddress?: string;
  deliveryaddress2?: string;
  deliveryzipcode?: string;
  deliverycity?: string;
  deliveryregion?: string;
  deliverycountry?: string;
  invoicename: string;
  invoicecontactname?: string;
  invoiceaddress?: string;
  invoiceaddress2?: any;
  invoicezipcode?: string;
  invoicecity?: string;
  invoiceregion?: string;
  invoicecountry?: string;
  products: OrderProductInput[];
}
export interface OrderProductInput {
  idproduct: number;
  amount: number;
}
export interface PickListWebhookData {
  idpicklist: number;
  picklistid: string;
  idcustomer: number;
  idorder: number;
  idreturn: any;
  idwarehouse: number;
  idtemplate: number;
  idshippingprovider_profile: any;
  deliveryname: string;
  deliverycontact: string;
  deliveryaddress: string;
  deliveryaddress2: any;
  deliveryzipcode: string;
  deliverycity: any;
  deliveryregion: any;
  deliverycountry: string;
  telephone: string;
  emailaddress: string;
  reference: string;
  assigned_to_iduser: any;
  invoiced: boolean;
  urgent: boolean;
  preferred_delivery_date: any;
  status: string;
  totalproducts: number;
  totalpicked: number;
  snoozed_until: any;
  closed_by_iduser: number;
  closed_at: string;
  created: string;
  updated: string;
  products: PickListProductData[];
  comment_count: number;
}
export interface PickListProductData {
  idpicklist_product: number;
  idproduct: number;
  idorder_product: number;
  idreturn_product_replacement: any;
  idvatgroup: number;
  productcode: string;
  name: string;
  remarks: any;
  amount: number;
  amountpicked: number;
  amount_picked: number;
  price: number;
  weight: number;
  stocklocation: string;
  stock_location: string;
  partof_idpicklist_product: any;
  has_parts: boolean;
  pick_locations: PickLocation[];
}
export interface PickLocation {
  idlocation: number;
  name: string;
  amount: number;
}
export interface WebhookInput {
  name: string;
  event: WebhookEvent;
  address: string;
  secret: string;
}
export type IncomingWebhook =
  | IncomingProductWebhook
  | IncomingOrderStatusWebhook;
export type WebhookEvent =
  | 'products.free_stock_changed'
  | 'products.assembled_stock_changed'
  | 'orders.status_changed';
export interface WebhookData {
  idhook: number;
  name: string;
  event: WebhookEvent;
  address: string;
  active: boolean;
  secret: boolean | string;
}
export interface IncomingOrderStatusWebhook {
  idhook: number;
  name: string;
  event: 'orders.status_changed';
  event_triggered_at: string;
  data: OrderData;
}
export interface IncomingProductWebhook {
  idhook: number;
  name: string;
  event: 'products.free_stock_changed' | 'products.assembled_stock_changed';
  event_triggered_at: string;
  data: ProductData;
}
```

## File: packages/vendure-plugin-picqer/src/ui/picqer-config.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder } from '@angular/forms';
import { DataService, NotificationService } from '@vendure/admin-ui/core';
import { FULL_SYNC, GET_CONFIG, TEST, UPSERT_CONFIG } from './queries';
import {
  IsPicqerConfigValidQuery,
  IsPicqerConfigValidQueryVariables,
  PicqerConfigQuery,
  PicqerConfigQueryVariables,
  UpsertPicqerConfigMutation,
  UpsertPicqerConfigMutationVariables,
} from './generated/graphql';
@Component({
  selector: 'picqer-component',
  template: `
    <h1>Picqer configuration</h1>
    <button
      class="btn btn-warning-outline"
      [disabled]="isSaving"
      (click)="fullSync()"
    >
      Run full sync
    </button>
    <br />
    <br />
    <section class="form-block">
      <vdr-form-field label="Enabled">
        <input type="checkbox" clrCheckbox [(ngModel)]="enabled" />
      </vdr-form-field>
      <vdr-form-field label="Api key">
        <input type="password" [(ngModel)]="apiKey" />
      </vdr-form-field>
      <vdr-form-field
        label="API endpoint"
        tooltip="Your Picqer domain, without the '/api/v1/' path "
      >
        <input type="text" [(ngModel)]="apiEndpoint" />
      </vdr-form-field>
      <vdr-form-field
        label="Storefront URL"
        tooltip="Picqer requires you to register your storefront URL and support email address for API usage."
      >
        <input type="text" [(ngModel)]="storefrontUrl" />
      </vdr-form-field>
      <vdr-form-field
        label="Support email address"
        tooltip="Picqer requires you to register your storefront URL and support email address for API usage."
      >
        <input type="text" [(ngModel)]="supportEmail" />
      </vdr-form-field>
      <!-- Form buttons -->
      <button class="btn btn-primary" [disabled]="isSaving" (click)="save()">
        Save
      </button>
      <button class="btn btn-secondary" (click)="test()">Test</button>
      <vdr-chip *ngIf="isValid === false" title="Failed" colorType="error">
        <clr-icon shape="error-standard"></clr-icon>
        Something is not right
      </vdr-chip>
      <vdr-chip *ngIf="isValid" title="Success!" colorType="success">
        <clr-icon shape="check-circle"></clr-icon>
        All good!
      </vdr-chip>
    </section>
  `,
})
export class PicqerConfigComponent implements OnInit {
  enabled: boolean = true;
  apiKey: string = '';
  apiEndpoint: string = '';
  storefrontUrl: string = '';
  supportEmail: string = '';
  isValid?: boolean = undefined;
  isSaving = false;
  constructor(
    protected dataService: DataService,
    private notificationService: NotificationService
  ) {}
  ngOnInit(): void {
    this.dataService
      .query<PicqerConfigQuery, PicqerConfigQueryVariables>(GET_CONFIG)
      .mapStream((r) => r.picqerConfig)
      .subscribe((config) => {
        if (config) {
          this.enabled = config.enabled as boolean;
          this.apiKey = config.apiKey as string;
          this.apiEndpoint = config.apiEndpoint as string;
          this.storefrontUrl = config.storefrontUrl as string;
          this.supportEmail = config.supportEmail as string;
        }
      });
  }
  async save(): Promise<void> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const { upsertPicqerConfig: result } = (await this.tryAndNotify(
      this.dataService
        .mutate<
          UpsertPicqerConfigMutation,
          UpsertPicqerConfigMutationVariables
        >(UPSERT_CONFIG, {
          input: {
            enabled: this.enabled,
            apiKey: this.apiKey,
            apiEndpoint: this.apiEndpoint,
            storefrontUrl: this.storefrontUrl,
            supportEmail: this.supportEmail,
          },
        })
        .toPromise(),
      'Saved',
      'Failed to save'
    )) as UpsertPicqerConfigMutation;
    if (result) {
      this.enabled = result.enabled as boolean;
      this.apiKey = result.apiKey as string;
      this.apiEndpoint = result.apiEndpoint as string;
      this.storefrontUrl = result.storefrontUrl as string;
      this.supportEmail = result.supportEmail as string;
    }
  }
  async fullSync(): Promise<void> {
    await this.tryAndNotify(
      this.dataService.mutate(FULL_SYNC).toPromise(),
      'Full sync started, this might take a while',
      'Failed to start sync'
    );
  }
  test(): void {
    this.isValid = undefined;
    this.dataService
      .query<IsPicqerConfigValidQuery, IsPicqerConfigValidQueryVariables>(
        TEST,
        {
          input: {
            apiKey: this.apiKey,
            apiEndpoint: this.apiEndpoint,
            storefrontUrl: this.storefrontUrl,
            supportEmail: this.supportEmail,
          },
        }
      )
      .mapSingle((r) => r.isPicqerConfigValid)
      .subscribe((isValid: boolean) => (this.isValid = isValid));
  }
  private async tryAndNotify(
    promise: Promise<any>,
    successmessage: string,
    failedMessage: string
  ): Promise<any> {
    try {
      const res = await promise;
      this.notificationService.success(successmessage);
      return res;
    } catch (e) {
      this.notificationService.error(failedMessage);
      console.error(e);
    }
  }
}
```

## File: packages/vendure-plugin-picqer/src/ui/picqer-modules.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
import { PicqerConfigComponent } from './picqer-config.component';
@NgModule({
  imports: [SharedModule],
  declarations: [],
  providers: [
    addNavMenuItem(
      {
        id: 'picqer',
        label: 'Picqer',
        routerLink: ['/extensions/picqer'],
        icon: 'cloud-network',
        requiresPermission: 'Picqer',
      },
      'settings'
    ),
  ],
})
export class PicqerSharedModule {}
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: PicqerConfigComponent,
        data: { breadcrumb: 'Picqer' },
      },
    ]),
  ],
  declarations: [PicqerConfigComponent],
})
export class PicqerLazyModule {}
```

## File: packages/vendure-plugin-picqer/src/ui/queries.ts

```typescript
import { gql } from 'graphql-tag';
export const CONFIG_FRAGMENT = gql`
  fragment ConfigFragment on PicqerConfig {
    enabled
    apiKey
    apiEndpoint
    storefrontUrl
    supportEmail
  }
`;
export const UPSERT_CONFIG = gql`
  ${CONFIG_FRAGMENT}
  mutation upsertPicqerConfig($input: PicqerConfigInput!) {
    upsertPicqerConfig(input: $input) {
      ...ConfigFragment
    }
  }
`;
export const FULL_SYNC = gql`
  mutation triggerPicqerFullSync {
    triggerPicqerFullSync
  }
`;
export const TEST = gql`
  query isPicqerConfigValid($input: TestPicqerInput!) {
    isPicqerConfigValid(input: $input)
  }
`;
export const GET_CONFIG = gql`
  ${CONFIG_FRAGMENT}
  query picqerConfig {
    picqerConfig {
      ...ConfigFragment
    }
  }
`;
```

## File: packages/vendure-plugin-picqer/src/constants.ts

```typescript
export const loggerCtx = 'PicqerPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-picqer/src/index.ts

```typescript
export * from './picqer.plugin';
export * from './api/types';
export * from './api/picqer.client';
export * from './api/picqer.resolvers';
export * from './api/picqer.service';
```

## File: packages/vendure-plugin-picqer/src/picqer.plugin.ts

```typescript
import {
  Order,
  OrderLine,
  PluginCommonModule,
  ProductVariant,
  RequestContext,
  VendurePlugin,
} from '@vendure/core';
import { ProductData } from './api/types';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { ProductInput } from './api/types';
import { adminSchema } from './api/api-extensions';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { picqerPermission } from '.';
import { PicqerConfigEntity } from './api/picqer-config.entity';
import { PicqerService } from './api/picqer.service';
import { PicqerResolver } from './api/picqer.resolvers';
import { PicqerController } from './api/picqer.controller';
import { UpdateProductVariantInput } from '@vendure/common/lib/generated-types';
import { picqerHandler } from './api/picqer.handler';
import { rawBodyMiddleware } from '../../util/src/raw-body.middleware';
export interface PicqerOptions {
  enabled: boolean;
  vendureHost: string;
  pullPicqerProductFields?: (
    product: ProductInput & ProductData
  ) => Partial<UpdateProductVariantInput>;
  pushProductVariantFields?: (
    variant: ProductVariant
  ) => Partial<ProductInput & ProductData>;
  pushPicqerOrderFields?: (order: Order) => any;
  pushPicqerOrderLineFields?: (
    ctx: RequestContext,
    orderLine: OrderLine,
    order: Order
  ) => any;
  shouldSyncOnProductVariantCustomFields?: string[];
  fallBackToProductFeaturedAsset?: boolean;
  cancelOrdersOnPicqerCancellation?: boolean;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [PicqerController],
  providers: [
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => PicqerPlugin.options,
    },
    PicqerService,
  ],
  adminApiExtensions: {
    resolvers: [PicqerResolver],
    schema: adminSchema,
  },
  entities: [PicqerConfigEntity],
  configuration: (config) => {
    config.apiOptions.middleware.push({
      route: '/picqer*',
      handler: rawBodyMiddleware,
      beforeListen: true,
    });
    config.authOptions.customPermissions.push(picqerPermission);
    config.shippingOptions.fulfillmentHandlers.push(picqerHandler);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class PicqerPlugin {
  static options: PicqerOptions;
  static init(options: PicqerOptions) {
    this.options = {
      fallBackToProductFeaturedAsset: true,
      cancelOrdersOnPicqerCancellation: true,
      ...options,
    };
    return PicqerPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'picqer',
        ngModuleFileName: 'picqer-modules.ts',
        ngModuleName: 'PicqerLazyModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'picqer-modules.ts',
        ngModuleName: 'PicqerSharedModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-picqer/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  configureDefaultOrderProcess,
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  OrderProcess,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import { addShippingMethod } from '../../test/src/admin-utils';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { picqerHandler } from '../dist/vendure-plugin-picqer/src/api/picqer.handler';
import { PicqerPlugin } from '../src';
import { UPSERT_CONFIG } from '../src/ui/queries';
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    orderOptions: {
      process: [
        configureDefaultOrderProcess({
          checkFulfillmentStates: false,
        }) as OrderProcess<any>,
      ],
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    customFields: {
      ProductVariant: [
        {
          name: 'noLongerAvailable',
          type: 'string',
        },
      ],
    },
    plugins: [
      PicqerPlugin.init({
        enabled: true,
        vendureHost: process.env.HOST!,
        pushProductVariantFields: (variant) => ({ barcode: variant.sku }),
        pullPicqerProductFields: (picqerProd) => ({ outOfStockThreshold: 123 }),
        pushPicqerOrderFields: (order) => ({
          customer_remarks: 'test note',
          pickup_point_data: {
            carrier: 'dhl',
            id: '901892834',
          },
        }),
        pushPicqerOrderLineFields: (ctx, orderLine, order) => ({
          remarks: `Test note on line '${orderLine.id}' for order '${order.code}`,
        }),
        shouldSyncOnProductVariantCustomFields: ['noLongerAvailable'],
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
  await addShippingMethod(adminClient, picqerHandler.code);
  await adminClient.query(UPSERT_CONFIG, {
    input: {
      enabled: true,
      apiKey: process.env.APIKEY,
      apiEndpoint: process.env.ENDPOINT,
      storefrontUrl: 'mystore.io',
      supportEmail: 'support@mystore.io',
    },
  });
  const order = await createSettledOrder(shopClient, 3, true, [
    { id: 'T_1', quantity: 3 },
  ]);
})();
```

## File: packages/vendure-plugin-picqer/test/picqer.spec.ts

```typescript
import {
  configureDefaultOrderProcess,
  DefaultLogger,
  EventBus,
  LogLevel,
  mergeConfig,
  Order,
  OrderProcess,
  OrderStateTransitionEvent,
} from '@vendure/core';
import {
  createTestEnvironment,
  E2E_DEFAULT_CHANNEL_TOKEN,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import nock from 'nock';
import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
} from 'vitest';
import {
  addShippingMethod,
  getAllVariants,
  getOrder,
  updateVariants,
} from '../../test/src/admin-utils';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import {
  GetVariantsQuery,
  GlobalFlag,
} from '../../test/src/generated/admin-graphql';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { IncomingOrderStatusWebhook, PicqerPlugin, VatGroup } from '../src';
import { picqerHandler } from '../src/api/picqer.handler';
import { FULL_SYNC, GET_CONFIG, UPSERT_CONFIG } from '../src/ui/queries';
import { createSignature } from './test-helpers';
import { filter } from 'rxjs';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
const nockBaseUrl = 'https://test-picqer.io/api/v1/';
afterEach(() => nock.cleanAll());
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      PicqerPlugin.init({
        enabled: true,
        vendureHost: 'https://example-vendure.io',
        pushProductVariantFields: (variant) => ({
          barcode: variant.sku,
          height: (variant.customFields as any).height,
        }),
        pullPicqerProductFields: (picqerProd) => ({
          outOfStockThreshold: 123,
        }),
        pushPicqerOrderFields: (order) => ({
          customer_remarks: 'test note',
          pickup_point_data: {
            carrier: 'dhl',
            id: '901892834',
          },
        }),
        pushPicqerOrderLineFields: (ctx, orderLine, order) => ({
          remarks: `Test note on line ${orderLine.id} for order '${order.code}`,
        }),
        shouldSyncOnProductVariantCustomFields: ['height'],
      }),
    ],
    orderOptions: {
      process: [
        configureDefaultOrderProcess({
          checkFulfillmentStates: false,
        }) as OrderProcess<any>,
      ],
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    customFields: {
      ProductVariant: [
        {
          name: 'height',
          type: 'int',
          public: true,
        },
      ],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
}, 60000);
it('Should start successfully', async () => {
  expect(server.app.getHttpServer).toBeDefined();
});
describe('Plugin setup', function () {
  it('Should track inventory of all variants', async () => {
    await adminClient.asSuperAdmin();
    const variants = await updateVariants(adminClient, [
      { id: 'T_1', trackInventory: GlobalFlag.True },
      { id: 'T_2', trackInventory: GlobalFlag.True },
      { id: 'T_3', trackInventory: GlobalFlag.True },
      { id: 'T_4', trackInventory: GlobalFlag.True },
    ]);
    const everyVariantHasStockTracking = variants.every(
      (v) => v!.trackInventory === GlobalFlag.True
    );
    expect(everyVariantHasStockTracking).toBe(true);
  });
  const createdHooks: any[] = [];
  it('Should update Picqer config via admin api', async () => {
    nock(nockBaseUrl).get('/hooks?offset=0').reply(200, []).persist();
    nock(nockBaseUrl)
      .post('/hooks', (reqBody) => {
        createdHooks.push(reqBody);
        return true;
      })
      .reply(200, { idhook: 'mockHookId' })
      .persist();
    await adminClient.asSuperAdmin();
    const { upsertPicqerConfig: config } = await adminClient.query(
      UPSERT_CONFIG,
      {
        input: {
          enabled: true,
          apiKey: 'test-api-key',
          apiEndpoint: 'https://test-picqer.io/',
          storefrontUrl: 'mystore.io',
          supportEmail: 'support@mystore.io',
        },
      }
    );
    await expect(config.enabled).toBe(true);
    await expect(config.apiKey).toBe('test-api-key');
    await expect(config.apiEndpoint).toBe('https://test-picqer.io/');
    await expect(config.storefrontUrl).toBe('mystore.io');
    await expect(config.supportEmail).toBe('support@mystore.io');
  });
  it('Should have created hooks when config was updated', async () => {
    await expect(createdHooks.length).toBe(3);
    await expect(createdHooks[0].event).toBe('orders.status_changed');
    await expect(createdHooks[0].address).toBe(
      `https://example-vendure.io/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`
    );
    await expect(createdHooks[0].secret).toBeDefined();
    await expect(createdHooks[0].name).toBeDefined();
    await expect(createdHooks[1].event).toBe('products.free_stock_changed');
    await expect(createdHooks[2].event).toBe(
      'products.assembled_stock_changed'
    );
  });
  it('Should get Picqer config after upsert', async () => {
    await adminClient.asSuperAdmin();
    const { picqerConfig: config } = await adminClient.query(GET_CONFIG);
    await expect(config.enabled).toBe(true);
    await expect(config.apiKey).toBe('test-api-key');
    await expect(config.apiEndpoint).toBe('https://test-picqer.io/');
    await expect(config.storefrontUrl).toBe('mystore.io');
    await expect(config.supportEmail).toBe('support@mystore.io');
  });
  it('Should create a shipping method with Picqer handler', async () => {
    await addShippingMethod(adminClient, picqerHandler.code, '500');
  });
});
describe('Order placement', function () {
  let createdOrder: Order | undefined;
  it('Should push order to Picqer on order placement', async () => {
    let isOrderInProcessing = false;
    let picqerOrderRequest: any;
    nock(nockBaseUrl)
      .get('/vatgroups')
      .reply(200, [{ idvatgroup: 12, percentage: 20 }] as VatGroup[]);
    nock(nockBaseUrl)
      .get(/.products*/)
      .reply(200, [{ idproduct: 'mockProductId' }])
      .persist();
    nock(nockBaseUrl)
      .get(/.customers*/)
      .reply(200, [{ idcustomer: 'mockCustomerId' }]);
    nock(nockBaseUrl)
      .put('/products/mockProductId')
      .reply(200, { idproduct: 'mockId' })
      .persist();
    nock(nockBaseUrl)
      .post('/orders/', (reqBody) => {
        picqerOrderRequest = reqBody;
        return true;
      })
      .reply(200, { idorder: 'mockOrderId' });
    nock(nockBaseUrl)
      .post('/orders/mockOrderId/process', (reqBody) => {
        isOrderInProcessing = true;
        return true;
      })
      .reply(200, { idordder: 'mockOrderId' });
    createdOrder = (await createSettledOrder(
      shopClient,
      3,
      true,
      [{ id: 'T_1', quantity: 3 }],
      {
        input: {
          fullName: 'Martinho Pinelab',
          company: ' ',
          streetLine1: 'Remote location',
          streetLine2: '123',
          city: 'Faraway',
          postalCode: '1111AB',
          countryCode: 'NL',
        },
      }
    )) as any;
    await new Promise((r) => setTimeout(r, 500));
    const variant = (await getAllVariants(adminClient)).find(
      (v) => v.id === 'T_1'
    );
    expect(variant!.stockOnHand).toBe(100);
    expect(variant!.stockAllocated).toBe(3);
    expect(picqerOrderRequest.reference).toBe(createdOrder?.code);
    expect(picqerOrderRequest.deliveryname).toBeDefined();
    expect(picqerOrderRequest.deliverycontactname).toBeUndefined();
    expect(picqerOrderRequest.deliveryaddress).toBeDefined();
    expect(picqerOrderRequest.deliveryzipcode).toBeDefined();
    expect(picqerOrderRequest.deliverycity).toBeDefined();
    expect(picqerOrderRequest.deliverycountry).toBe('NL');
    expect(picqerOrderRequest.invoicename).toBe('Martinho Pinelab');
    expect(picqerOrderRequest.invoicecontactname).toBeUndefined();
    expect(picqerOrderRequest.invoicecountry).toBe('NL');
    expect(picqerOrderRequest.invoiceaddress).toBe('Remote location 123');
    expect(picqerOrderRequest.invoicezipcode).toBe('1111AB');
    expect(picqerOrderRequest.invoicecity).toBe('Faraway');
    expect(picqerOrderRequest.products.length).toBe(1);
    expect(picqerOrderRequest.products[0].amount).toBe(3);
    expect(isOrderInProcessing).toBe(true);
    expect(picqerOrderRequest.customer_remarks).toBe('test note');
    expect(picqerOrderRequest.pickup_point_data).toEqual({
      carrier: 'dhl',
      id: '901892834',
    });
    expect(picqerOrderRequest.products[0].remarks).toContain(
      'Test note on line'
    );
    expect(picqerOrderRequest.products[0].remarks).not.toContain('undefined');
  });
  it('Should update to "Delivered" on incoming order status "completed"', async () => {
    const mockIncomingWebhook = {
      event: 'orders.status_changed',
      data: {
        reference: createdOrder?.code,
        status: 'completed',
        products: [
          {
            productcode: 'L2201308',
            amount: 3,
          },
        ],
      },
    } as Partial<IncomingOrderStatusWebhook>;
    const eventBus = server.app.get(EventBus);
    let eventFired = false;
    eventBus
      .ofType(OrderStateTransitionEvent)
      .pipe(
        filter(
          (event) =>
            event.order.code === createdOrder?.code &&
            event.toState === 'Shipped'
        )
      )
      .subscribe((event) => {
        eventFired = true;
      });
    await adminClient.fetch(
      `http://localhost:3050/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(mockIncomingWebhook),
        headers: {
          'X-Picqer-Signature': createSignature(
            mockIncomingWebhook,
            'test-api-key'
          ),
        },
      }
    );
    await Promise.resolve((r) => setTimeout(r, 1000));
    expect(eventFired).toBe(true);
    const order = await getOrder(adminClient, createdOrder?.id as string);
    expect(order!.state).toBe('Delivered');
  });
  it('Should not update to "Canceled" when "cancelOrdersOnPicqerCancellation = false"', async () => {
    PicqerPlugin.options.cancelOrdersOnPicqerCancellation = false;
    const mockIncomingWebhook = {
      event: 'orders.status_changed',
      data: {
        reference: createdOrder?.code,
        status: 'cancelled',
      },
    } as Partial<IncomingOrderStatusWebhook>;
    await adminClient.fetch(
      `http://localhost:3050/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(mockIncomingWebhook),
        headers: {
          'X-Picqer-Signature': createSignature(
            mockIncomingWebhook,
            'test-api-key'
          ),
        },
      }
    );
    const order = await getOrder(adminClient, createdOrder?.id as string);
    expect(order!.state).toBe('Delivered');
  });
  it('Should update to "Canceled" on incoming order status "cancelled" and "cancelOrdersOnPicqerCancellation = true"', async () => {
    PicqerPlugin.options.cancelOrdersOnPicqerCancellation = true;
    const mockIncomingWebhook = {
      event: 'orders.status_changed',
      data: {
        reference: createdOrder?.code,
        status: 'cancelled',
      },
    } as Partial<IncomingOrderStatusWebhook>;
    await adminClient.fetch(
      `http://localhost:3050/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(mockIncomingWebhook),
        headers: {
          'X-Picqer-Signature': createSignature(
            mockIncomingWebhook,
            'test-api-key'
          ),
        },
      }
    );
    const order = await getOrder(adminClient, createdOrder?.id as string);
    expect(order!.state).toBe('Cancelled');
  });
});
describe('Product synchronization', function () {
  let pushProductPayloads: any[] = [];
  it('Should push all products to Picqer on full sync', async () => {
    nock(nockBaseUrl)
      .get('/vatgroups')
      .reply(200, [{ idvatgroup: 12, percentage: 20 }] as VatGroup[]);
    nock(nockBaseUrl)
      .get(/.products*/)
      .reply(200, [
        {
          idproduct: 'mockId',
          productcode: 'L2201308',
          stock: [{ freestock: 8, idwarehouse: 2 }],
        },
      ])
      .persist();
    nock(nockBaseUrl)
      .put('/products/mockId', (reqBody) => {
        pushProductPayloads.push(reqBody);
        return true;
      })
      .reply(200, { idproduct: 'mockId' })
      .persist();
    nock(nockBaseUrl)
      .get('/warehouses?offset=0')
      .reply(200, [{ idwarehouse: 2, name: 'Main warehouse', active: true }]);
    const { triggerPicqerFullSync } = await adminClient.query(FULL_SYNC);
    await new Promise((r) => setTimeout(r, 500));
    expect(pushProductPayloads.length).toBe(4);
    expect(triggerPicqerFullSync).toBe(true);
  });
  let updatedVariant:
    | GetVariantsQuery['productVariants']['items'][0]
    | undefined;
  it('Should have pulled stock levels from Picqer after full sync', async () => {
    const variants = await getAllVariants(adminClient);
    updatedVariant = variants.find((v) => v.sku === 'L2201308');
    expect(updatedVariant?.stockOnHand).toBe(8);
  });
  it('Should have pulled custom fields from Picqer based on configured "pullFieldsFromPicqer()"', async () => {
    expect(updatedVariant?.outOfStockThreshold).toBe(123);
  });
  it('Should push custom fields to Picqer based on configured "pushFieldsToPicqer()"', async () => {
    const pushedProduct = pushProductPayloads.find(
      (p) => p.productcode === 'L2201516'
    );
    expect(pushedProduct?.barcode).toBe('L2201516');
  });
  it('Should push product to Picqer when updated in Vendure', async () => {
    let updatedProduct: any;
    nock(nockBaseUrl)
      .get('/vatgroups')
      .reply(200, [{ idvatgroup: 12, percentage: 20 }] as VatGroup[]);
    nock(nockBaseUrl)
      .get(/.products*/)
      .reply(200, [])
      .persist();
    nock(nockBaseUrl)
      .post(/.products*/, (reqBody) => {
        updatedProduct = reqBody;
        return true;
      })
      .reply(200, { idproduct: 'mockId' });
    const [variant] = await updateVariants(adminClient, [
      { id: 'T_1', price: 12345 },
    ]);
    await new Promise((r) => setTimeout(r, 500));
    expect(variant?.price).toBe(12345);
    expect(updatedProduct!.price).toBe(123.45);
  });
  it('Should push product to Picqer when custom field updated in Vendure', async () => {
    let updatedProduct: any;
    nock(nockBaseUrl)
      .get('/vatgroups')
      .reply(200, [{ idvatgroup: 12, percentage: 20 }] as VatGroup[]);
    nock(nockBaseUrl)
      .get(/.products*/)
      .reply(200, [])
      .persist();
    nock(nockBaseUrl)
      .post(/.products*/, (reqBody) => {
        updatedProduct = reqBody;
        return true;
      })
      .reply(200, { idproduct: 'mockId' });
    const [variant] = await updateVariants(adminClient, [
      { id: 'T_1', customFields: { height: 100 } },
    ]);
    await new Promise((r) => setTimeout(r, 500));
    expect(updatedProduct!.height).toBe(100);
  });
  it('Should update stock level on incoming "free_stock" webhook', async () => {
    const body = {
      event: 'products.free_stock_changed',
      data: {
        productcode: 'L2201308',
        stock: [{ freestock: 543, idwarehouse: 2 }],
      },
    };
    const res = await adminClient.fetch(
      `http://localhost:3050/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
          'X-Picqer-Signature': createSignature(body, 'test-api-key'),
        },
      }
    );
    const variants = await getAllVariants(adminClient);
    const variant = variants.find((v) => v.sku === 'L2201308');
    expect(res.ok).toBe(true);
    expect(variant?.stockOnHand).toBe(543);
  });
  it('Should update stock level on incoming "assembled_stock" webhook', async () => {
    const body = {
      event: 'products.assembled_stock_changed',
      data: {
        productcode: 'L2201308',
        stock: [{ freestock: 2, idwarehouse: 2 }],
      },
    };
    const res = await adminClient.fetch(
      `http://localhost:3050/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
          'X-Picqer-Signature': createSignature(body, 'test-api-key'),
        },
      }
    );
    const variants = await getAllVariants(adminClient);
    const variant = variants.find((v) => v.sku === 'L2201308');
    expect(res.ok).toBe(true);
    expect(variant?.stockOnHand).toBe(2);
  });
  it('Should fail with invalid signature', async () => {
    const res = await adminClient.fetch(
      `http://localhost:3050/picqer/hooks/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'POST',
        body: JSON.stringify({}),
        headers: {
          'X-Picqer-Signature': 'invalid signature',
        },
      }
    );
    expect(res.status).toBe(403);
  });
});
describe('Periodical stock updates', function () {
  it('Throws forbidden for invalid api key', async () => {
    const res = await adminClient.fetch(
      `http://localhost:3050/picqer/pull-stock-levels/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'GET',
        headers: {
          Authorization: 'Bearer this is not right',
        },
      }
    );
    expect(res.status).toBe(403);
  });
  it('Creates full sync jobs on calling of endpoint', async () => {
    const res = await adminClient.fetch(
      `http://localhost:3050/picqer/pull-stock-levels/${E2E_DEFAULT_CHANNEL_TOKEN}`,
      {
        method: 'GET',
        headers: {
          Authorization: 'Bearer test-api-key',
        },
      }
    );
    expect(res.status).toBe(200);
  });
});
if (process.env.TEST_ADMIN_UI) {
  it('Should compile admin', async () => {
    const files = await getFilesInAdminUiFolder(__dirname, PicqerPlugin.ui);
    expect(files?.length).toBeGreaterThan(0);
  }, 200000);
}
afterAll(async () => {
  await server.destroy();
}, 100000);
```

## File: packages/vendure-plugin-picqer/test/test-helpers.ts

```typescript
import crypto from 'crypto';
export function createSignature(body: any, apiKey: string): string {
  const webhookSecret = crypto
    .createHash('shake256', { outputLength: 10 })
    .update(apiKey)
    .digest('hex');
  return crypto
    .createHmac('sha256', webhookSecret)
    .update(JSON.stringify(body))
    .digest('base64');
}
```

## File: packages/vendure-plugin-popularity-scores/src/constants.ts

```typescript
export const loggerCtx = 'PopularityScoresPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-popularity-scores/src/index.ts

```typescript
export * from './popularity-scores.plugin';
export * from './popularity-scores.service';
```

## File: packages/vendure-plugin-popularity-scores/src/popularity-scores.plugin.ts

```typescript
import {
  LanguageCode,
  PluginCommonModule,
  Type,
  VendurePlugin,
} from '@vendure/core';
import { gql } from 'graphql-tag';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { OrderByPopularityController } from './popularity.controller';
import { PopularityScoresService } from './popularity-scores.service';
export interface PopularityScoresPluginConfig {
  endpointSecret: string;
  chunkSize?: number;
  productFieldUiTab?: string;
  collectionFieldUiTab?: string;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    PopularityScoresService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => PopularityScoresPlugin.config,
    },
  ],
  controllers: [OrderByPopularityController],
  shopApiExtensions: {
    schema: gql`
      type ExampleType {
        name: String
      }
    `,
  },
  configuration: (config) => {
    config.customFields.Product.push({
      name: 'popularityScore',
      type: 'int',
      defaultValue: 0,
      ui: {
        tab: PopularityScoresPlugin?.config?.productFieldUiTab,
      },
      label: [{ languageCode: LanguageCode.en, value: 'Popularity Score' }],
    });
    config.customFields.Collection.push({
      name: 'popularityScore',
      type: 'int',
      defaultValue: 0,
      ui: {
        tab: PopularityScoresPlugin?.config?.collectionFieldUiTab,
      },
      label: [{ languageCode: LanguageCode.en, value: 'Popularity Score' }],
    });
    return config;
  },
  compatibility: '>=2.2.0',
})
export class PopularityScoresPlugin {
  static config: PopularityScoresPluginConfig;
  static init(
    config: PopularityScoresPluginConfig
  ): Type<PopularityScoresPlugin> {
    this.config = config;
    if (!this.config?.chunkSize) {
      this.config.chunkSize = 100;
    }
    return this;
  }
}
```

## File: packages/vendure-plugin-popularity-scores/src/popularity-scores.service.ts

```typescript
import { Injectable, OnModuleInit, Inject } from '@nestjs/common';
import {
  ChannelService,
  Collection,
  CollectionService,
  ID,
  JobQueue,
  JobQueueService,
  Logger,
  OrderLine,
  Product,
  RequestContext,
  SerializedRequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { PLUGIN_INIT_OPTIONS, loggerCtx } from './constants';
import { PopularityScoresPluginConfig } from './popularity-scores.plugin';
import { sliceArray } from './utils';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomCollectionFields {
    popularityScore: number;
  }
}
@Injectable()
export class PopularityScoresService implements OnModuleInit {
  private jobQueue!: JobQueue<{
    channelToken: string;
    ctx: SerializedRequestContext;
  }>;
  constructor(
    private connection: TransactionalConnection,
    private jobQueueService: JobQueueService,
    private channelService: ChannelService,
    private collectionService: CollectionService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: PopularityScoresPluginConfig
  ) {}
  async onModuleInit() {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'calculate-popularity-scores',
      process: async (job) => {
        await this.setProductPopularity(
          RequestContext.deserialize(job.data.ctx),
          job.data.channelToken
        ).catch((e) => {
          Logger.warn(
            `Failed to handle popularity calculation job: ${e?.message}`,
            loggerCtx
          );
          throw e;
        });
      },
    });
  }
  async setProductPopularity(
    ctx: RequestContext,
    channelToken: string
  ): Promise<void> {
    Logger.info(`Started calculating popularity scores`, loggerCtx);
    const channel = await this.channelService.getChannelFromToken(channelToken);
    const orderLineRepo = this.connection.getRepository(ctx, OrderLine);
    const ordersAfter = new Date();
    ordersAfter.setMonth(ordersAfter.getMonth() - 12);
    const groupedOrderLines = await orderLineRepo
      .createQueryBuilder('orderLine')
      .select(['SUM(orderLine.quantity) as count'])
      .innerJoin('orderLine.productVariant', 'productVariant')
      .innerJoin('orderLine.order', 'order')
      .innerJoin('productVariant.product', 'product')
      .addSelect(['product.id'])
      .innerJoin('order.channels', 'order_channel')
      .andWhere('order.orderPlacedAt > :ordersAfter', {
        ordersAfter: ordersAfter.toISOString(),
      })
      .andWhere('product.deletedAt IS NULL')
      .andWhere('productVariant.deletedAt IS NULL')
      .andWhere('product.enabled')
      .andWhere('productVariant.enabled')
      .andWhere('order_channel.id = :id', { id: channel.id })
      .addGroupBy('product.id')
      .addOrderBy('count', 'DESC')
      .getRawMany();
    const maxCount = groupedOrderLines?.[0]?.count;
    if (!maxCount) {
      Logger.warn(
        `No orders found for channel ${channel.code},
        not calculating popularity scores`,
        loggerCtx
      );
      return;
    }
    const maxValue = 1000;
    const productRepository = this.connection.getRepository(ctx, Product);
    await productRepository.save(
      groupedOrderLines.map((gols) => {
        return {
          id: gols.product_id,
          customFields: {
            popularityScore: Math.round((gols.count / maxCount) * maxValue),
          },
        };
      })
    );
    await this.assignScoreValuesToCollections(ctx);
    Logger.info(`Finished calculating popularity scores`, loggerCtx);
  }
  async assignScoreValuesToCollections(ctx: RequestContext) {
    const collectionsRepo = this.connection.getRepository(ctx, Collection);
    const collectionTreeRepo =
      this.connection.rawConnection.manager.getTreeRepository(Collection);
    const channelRootCollection = await collectionsRepo
      .createQueryBuilder('collection')
      .leftJoin('collection.channels', 'channel')
      .where('collection.isRoot = :isRoot', { isRoot: true })
      .andWhere('channel.id = :channelId', { channelId: ctx.channelId })
      .getOne();
    if (!channelRootCollection) {
      Logger.warn('No root collection found for the channel', loggerCtx);
      return;
    }
    const channelCollectionsTree = await collectionTreeRepo.findDescendantsTree(
      channelRootCollection
    );
    const allCollections: Collection[] = [];
    const traverseDepthFirstAndUpdateScore = async (
      node: Collection
    ): Promise<number> => {
      node.customFields.popularityScore = 0;
      if (node?.children?.length) {
        for (const child of node.children) {
          node.customFields.popularityScore +=
            await traverseDepthFirstAndUpdateScore(child);
        }
      } else {
        node.customFields.popularityScore =
          await this.getSummedProductScoreCalculation(ctx, node);
      }
      allCollections.push(node);
      return node.customFields.popularityScore;
    };
    await traverseDepthFirstAndUpdateScore(channelCollectionsTree);
    for (const updateCollection of allCollections) {
      await collectionsRepo.update(
        { id: updateCollection.id },
        {
          customFields: {
            popularityScore: updateCollection.customFields.popularityScore,
          },
        }
      );
    }
  }
  private async getSummedProductScoreCalculation(
    ctx: RequestContext,
    collection: Collection
  ): Promise<number> {
    const collectionsRepo = this.connection.getRepository(ctx, Collection);
    const productsRepo = this.connection.getRepository(ctx, Product);
    const variantsPartialInfoResults = await collectionsRepo
      .createQueryBuilder('collection')
      .leftJoin('collection.productVariants', 'productVariant')
      .innerJoin('productVariant.product', 'product')
      .addSelect(['product.customFields.popularityScore', 'product.id'])
      .where('collection.id= :id', { id: collection.id.toString() })
      .getRawMany();
    const productIds = variantsPartialInfoResults
      .filter((i) => i.product_id != null)
      .map((i) => i.product_id as ID);
    const uniqueProductIds: ID[] = [...new Set(productIds)];
    if (uniqueProductIds.length) {
      let score = 0;
      const chunkedProductIds = sliceArray(
        uniqueProductIds,
        this.config.chunkSize ?? 100
      );
      for (const uniqueProductIdsSlice of chunkedProductIds) {
        const summedProductsValue = await productsRepo
          .createQueryBuilder('product')
          .select(
            'SUM(product.customFields.popularityScore) AS productScoreSum'
          )
          .andWhere('product.id IN (:...ids)', { ids: uniqueProductIdsSlice })
          .getRawOne();
        score += Number(summedProductsValue.productScoreSum) ?? 0;
      }
      return score;
    }
    return 0;
  }
  addScoreCalculatingJobToQueue(channelToken: string, ctx: RequestContext) {
    return this.jobQueue.add(
      { channelToken, ctx: ctx.serialize() },
      { retries: 5 }
    );
  }
}
```

## File: packages/vendure-plugin-popularity-scores/src/popularity.controller.ts

```typescript
import { Controller, Get, Param, Inject } from '@nestjs/common';
import { Ctx, RequestContext, UnauthorizedError } from '@vendure/core';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { PopularityScoresPluginConfig } from './popularity-scores.plugin';
import { PopularityScoresService } from './popularity-scores.service';
@Controller('/popularity-scores')
export class OrderByPopularityController {
  constructor(
    private popularityScoreService: PopularityScoresService,
    @Inject(PLUGIN_INIT_OPTIONS) private config: PopularityScoresPluginConfig
  ) {}
  @Get('calculate-scores/:mychanneltoken/:secret')
  async calculateScores(
    @Ctx() ctx: RequestContext,
    @Param('mychanneltoken') token: string,
    @Param('secret') secret: string
  ) {
    if (secret !== this.config.endpointSecret) {
      throw new UnauthorizedError();
    }
    await this.popularityScoreService.addScoreCalculatingJobToQueue(token, ctx);
  }
}
```

## File: packages/vendure-plugin-popularity-scores/src/types.ts

```typescript
import {
  CustomProductFields,
  CustomCollectionFields,
} from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomProductFields {
    popularityScore: number;
  }
  interface CustomCollectionFields {
    popularityScore: number;
  }
}
```

## File: packages/vendure-plugin-popularity-scores/src/utils.ts

```typescript
import { ID } from '@vendure/core';
export const sliceArray = (arr: ID[], chunkSize: number): ID[][] => {
  const result = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    if (i + chunkSize < arr.length) {
      result.push(arr.slice(i, i + chunkSize));
    } else {
      result.push(arr.slice(i));
    }
  }
  return result;
};
```

## File: packages/vendure-plugin-popularity-scores/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { PopularityScoresPlugin } from '../src';
import { initialTestData } from './initial-test-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { createSettledOrder } from '../../test/src/shop-utils';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      PopularityScoresPlugin.init({
        endpointSecret: 'test',
        productFieldUiTab: 'Scores',
        collectionFieldUiTab: 'Scores',
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialTestData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: './test/products.csv',
  });
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
  await createSettledOrder(shopClient, 1);
})();
```

## File: packages/vendure-plugin-popularity-scores/test/e2e.spec.ts

```typescript
import {
  DefaultLogger,
  EventBus,
  ID,
  LogLevel,
  ProductVariantEvent,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { createCollection, getAllOrders } from '../../test/src/admin-utils';
import {
  CreateCollectionMutation,
  LanguageCode,
} from '../../test/src/generated/admin-graphql';
import { initialTestData } from './initial-test-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { PopularityScoresPlugin } from '../src';
import {
  GET_COLLECTIONS_WITH_POPULARITY_SCORE,
  GET_PRODUCTS_WITH_POPULARITY_SCORES,
} from './queries';
import { expect, describe, beforeAll, afterAll, it } from 'vitest';
import { getRootCollection, updateCollectionParent } from './helpers';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
describe('Sort by Popularity Plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  let collection: CreateCollectionMutation['createCollection'];
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3106,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        PopularityScoresPlugin.init({
          endpointSecret: 'test-secret',
          chunkSize: 1,
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialTestData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: './test/products.csv',
      customerCount: 2,
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
  }, 60000);
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  it('Creates an empty collection', async () => {
    collection = await createCollection(adminClient, {
      translations: [
        {
          languageCode: LanguageCode.En,
          name: 'test',
          slug: 'test',
          description: '',
        },
      ],
      filters: [
        {
          code: 'variant-id-filter',
          arguments: [
            { name: 'variantIds', value: '["T_8","T_2"]' },
            { name: 'combineWithAnd', value: 'false' },
          ],
        },
      ],
      parentId: '1',
      customFields: {},
    });
    const eventBus = server.app.get(EventBus);
    const ctx = await getSuperadminContext(server.app);
    eventBus.publish(new ProductVariantEvent(ctx, [], 'updated'));
    await new Promise((r) => setTimeout(r, 2000));
    expect(collection.name).toBe('test');
  });
  it('Make the new collection parent of "Computers" and "Electronics"', async () => {
    const updatedComputerCollection = await updateCollectionParent(
      adminClient,
      2,
      collection.id
    );
    expect(updatedComputerCollection.parent.id).toBe(collection.id);
    const updatedElectronicsCollection = await updateCollectionParent(
      adminClient,
      3,
      collection.id
    );
    expect(updatedElectronicsCollection.parent.id).toBe(collection.id);
  });
  it('Should place a test orders', async () => {
    await createSettledOrder(shopClient, 1, true, [
      { id: 'T_2', quantity: 4 },
      { id: 'T_5', quantity: 20 },
      { id: 'T_8', quantity: 1 },
      { id: 'T_9', quantity: 10 },
    ]);
    await createSettledOrder(shopClient, 1, true, [
      { id: 'T_7', quantity: 4 },
      { id: 'T_5', quantity: 2 },
      { id: 'T_8', quantity: 30 },
    ]);
    const orders = await getAllOrders(adminClient);
    expect(orders.length).toBe(2);
    expect(
      orders[1].lines.every((line) => line.productVariant.product.id === 'T_2')
    ).toBe(true);
  });
  it('Fails for unauthenticated calls to calculate popularity endpoint', async () => {
    const res = await adminClient.fetch(
      `http://localhost:3106/popularity-scores/calculate-scores/e2e-default-channel/invalid-secreet`
    );
    expect(res.status).toBe(401);
  });
  it('Calls endpoint to calculate popularity', async () => {
    const res = await adminClient.fetch(
      `http://localhost:3106/popularity-scores/calculate-scores/e2e-default-channel/test-secret`
    );
    expect(res.status).toBe(200);
  });
  it('Calculated popularity per product', async () => {
    await new Promise((r) => setTimeout(r, 1000));
    const {
      products: { items: products },
    } = await adminClient.query(GET_PRODUCTS_WITH_POPULARITY_SCORES);
    const carProduct = products.find((p) => p.name === 'Cars');
    const laptopProduct = products.find((p) => p.name === 'Laptop');
    const motorsProduct = products.find((p) => p.name === 'Motors');
    expect(carProduct.customFields.popularityScore).toBe(1000);
    expect(laptopProduct.customFields.popularityScore).toBe(70);
    expect(motorsProduct.customFields.popularityScore).toBe(175);
  });
  it('Calculated popularity per collection', async () => {
    const {
      collections: { items: collections },
    } = await adminClient.query(GET_COLLECTIONS_WITH_POPULARITY_SCORE);
    const electronics = collections.find(
      (col: any) => col.name === 'Electronics'
    );
    const rootCollection = await getRootCollection(adminClient);
    const computers = collections.find((col: any) => col.name === 'Computers');
    const testCol = collections.find((col: any) => col.name === 'test');
    const others = collections.find((col: any) => col.name === 'Others');
    expect(electronics.customFields.popularityScore).toBe(1245);
    expect(computers.customFields.popularityScore).toBe(1070);
    expect(others.customFields.popularityScore).toBe(175);
    expect(testCol.customFields.popularityScore).toBe(1245 + 1070);
    expect(rootCollection.customFields.popularityScore).toBe(1245 + 1070 + 175);
  });
  afterAll(async () => {
    return server.destroy();
  });
});
```

## File: packages/vendure-plugin-popularity-scores/test/helpers.ts

```typescript
import { ID } from '@vendure/core';
import { SimpleGraphQLClient } from '@vendure/testing';
import gql from 'graphql-tag';
export async function updateCollectionParent(
  adminClient: SimpleGraphQLClient,
  id: ID,
  parentId: ID
): Promise<{ id: string; parent: { id: string } }> {
  const { updateCollection } = await adminClient.query(
    gql`
      mutation UpdateCollection($id: ID!, $parentId: ID) {
        updateCollection(input: { id: $id, parentId: $parentId }) {
          id
          parent {
            id
          }
        }
      }
    `,
    {
      id,
      parentId,
    }
  );
  return updateCollection;
}
export async function getRootCollection(
  adminClient: SimpleGraphQLClient
): Promise<{ id: string; customFields: { popularityScore: number } }> {
  const { collection: rootCollection } = await adminClient.query(
    gql`
      query GetRootCollection {
        collection(id: 1) {
          id
          customFields {
            popularityScore
          }
        }
      }
    `
  );
  return rootCollection;
}
```

## File: packages/vendure-plugin-popularity-scores/test/initial-test-data.ts

```typescript
import { LanguageCode } from '@vendure/common/lib/generated-types';
import { InitialData } from '@vendure/core';
export const initialTestData: InitialData = {
  defaultLanguage: LanguageCode.en,
  defaultZone: 'Europe',
  taxRates: [
    { name: 'Standard Tax', percentage: 20 },
    { name: 'Reduced Tax', percentage: 10 },
    { name: 'Zero Tax', percentage: 0 },
  ],
  shippingMethods: [
    { name: 'Standard Shipping', price: 500 },
    { name: 'Express Shipping', price: 1000 },
  ],
  countries: [
    { name: 'Australia', code: 'AU', zone: 'Oceania' },
    { name: 'Austria', code: 'AT', zone: 'Europe' },
    { name: 'Canada', code: 'CA', zone: 'Americas' },
    { name: 'China', code: 'CN', zone: 'Asia' },
    { name: 'South Africa', code: 'ZA', zone: 'Africa' },
    { name: 'United Kingdom', code: 'GB', zone: 'Europe' },
    { name: 'United States of America', code: 'US', zone: 'Americas' },
    { name: 'Nederland', code: 'NL', zone: 'Europe' },
  ],
  collections: [
    {
      name: 'Computers',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['computers'], containsAny: false },
        },
      ],
    },
    {
      name: 'Electronics',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['electronics'], containsAny: false },
        },
      ],
    },
    {
      name: 'Others',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['others'], containsAny: false },
        },
      ],
    },
  ],
  paymentMethods: [],
};
```

## File: packages/vendure-plugin-popularity-scores/test/queries.ts

```typescript
import { gql } from 'graphql-tag';
export const GET_COLLECTIONS_WITH_POPULARITY_SCORE = gql`
  query collections {
    collections {
      items {
        id
        name
        slug
        customFields {
          popularityScore
        }
        productVariants {
          items {
            name
            id
            product {
              id
            }
          }
          totalItems
        }
      }
      totalItems
    }
  }
`;
export const GET_PRODUCTS_WITH_POPULARITY_SCORES = gql`
  query products {
    products {
      items {
        id
        name
        slug
        customFields {
          popularityScore
        }
      }
      totalItems
    }
  }
`;
```

## File: packages/vendure-plugin-primary-collection/src/api/api-extensions.ts

```typescript
import { gql } from 'graphql-tag';
export const apiExtensions = gql`
  extend type Product {
    primaryCollection: Collection
    breadcrumbs: [ProductBreadcrumb!]!
  }
  type ProductBreadcrumb {
    id: ID!
    name: String!
    slug: String!
  }
  extend type Collection {
    channels: [Channel!]!
  }
`;
```

## File: packages/vendure-plugin-primary-collection/src/api/primary-collection.resolver.ts

```typescript
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import {
  Collection,
  Ctx,
  RequestContext,
  Product,
  CollectionService,
  Translated,
  Channel,
  EntityHydrator,
  ID,
} from '@vendure/core';
import { CollectionBreadcrumb } from '@vendure/common/lib/generated-types';
import { getProductPrimaryCollectionIDInChannel } from '../util/helpers';
interface ProductBreadcrumb {
  name: string;
  id: ID;
  slug: string;
}
@Resolver()
export class PrimaryCollectionPluginResolver {
  constructor(
    private collectionService: CollectionService,
    private entityHydrator: EntityHydrator
  ) {}
  @ResolveField('primaryCollection')
  @Resolver('Product')
  async primaryCollection(
    @Ctx() ctx: RequestContext,
    @Parent() product: Product
  ): Promise<Translated<Collection> | undefined> {
    const collectionId = getProductPrimaryCollectionIDInChannel(
      ctx,
      (product.customFields as any).primaryCollection as string
    );
    if (collectionId) {
      return this.collectionService.findOne(ctx, collectionId);
    }
  }
  @ResolveField('breadcrumbs')
  @Resolver('Product')
  async productBreadcrumb(
    @Ctx() ctx: RequestContext,
    @Parent() product: Product
  ): Promise<ProductBreadcrumb[]> {
    const primaryCollection = await this.primaryCollection(ctx, product);
    const productBreadcrumb = {
      id: product.id,
      name: product.name,
      slug: product.slug,
    };
    if (!primaryCollection) {
      return [productBreadcrumb];
    } else {
      const parentCollectionbreadcrumb =
        (await this.collectionService.getBreadcrumbs(
          ctx,
          primaryCollection
        )) as CollectionBreadcrumb[];
      return [...parentCollectionbreadcrumb, productBreadcrumb];
    }
  }
  @ResolveField('channels')
  @Resolver('Collection')
  async channels(
    @Ctx() ctx: RequestContext,
    @Parent() collection: Collection
  ): Promise<Channel[] | undefined> {
    await this.entityHydrator.hydrate(ctx, collection, {
      relations: ['channels'],
    });
    return collection.channels;
  }
}
```

## File: packages/vendure-plugin-primary-collection/src/api/primary-collections-helper.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import {
  Channel,
  Product,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import {
  ProductPrimaryCollection,
  parseProductPrimaryCollectionCustomField,
} from '../util/helpers';
@Injectable()
export class PrimaryCollectionHelperService {
  constructor(private conn: TransactionalConnection) {}
  async setPrimaryCollectionForAllProducts(ctx: RequestContext) {
    const productsRepository = this.conn.getRepository(ctx, Product);
    const allProducts = await productsRepository
      .createQueryBuilder('product')
      .leftJoin('product.variants', 'variant')
      .leftJoin('variant.collections', 'collection')
      .leftJoin('collection.channels', 'collectionChannel')
      .leftJoin('product.channels', 'productChannel')
      .select([
        'product.id',
        'productChannel.id',
        'collection.id',
        'variant.id',
        'collectionChannel.id',
      ])
      .where('not collection.isPrivate')
      .getMany();
    const updatedProducts: Partial<Product>[] = [];
    for (const product of allProducts) {
      const primaryCollections = parseProductPrimaryCollectionCustomField(
        (product.customFields as any)?.primaryCollection
      );
      const updatedPrimaryCollectionList: ProductPrimaryCollection[] = [];
      for (const channel of product.channels) {
        const primaryCollection = this.getVariantCollectionInChannel(
          product,
          channel
        );
        if (!primaryCollection) {
          continue;
        }
        const primaryCollectionDetailInChannel = primaryCollections.find(
          (primaryCollection) => primaryCollection.channelId === channel.id
        );
        if (primaryCollectionDetailInChannel) {
          updatedPrimaryCollectionList.push(primaryCollectionDetailInChannel);
          continue;
        }
        updatedPrimaryCollectionList.push({
          channelId: channel.id,
          collectionId: primaryCollection?.id,
        });
      }
      updatedProducts.push({
        id: product.id,
        customFields: {
          primaryCollection: JSON.stringify(updatedPrimaryCollectionList),
        },
      });
    }
    await productsRepository.save(updatedProducts);
  }
  getVariantCollectionInChannel(product: Product, channel: Channel) {
    for (const variant of product.variants) {
      for (const collection of variant.collections) {
        if (
          !!collection.channels.find(
            (collectionChannel) => collectionChannel.id === channel.id
          ) &&
          !collection.isPrivate
        ) {
          return collection;
        }
      }
    }
  }
}
```

## File: packages/vendure-plugin-primary-collection/src/ui/select-primary-collection.component.ts

```typescript
import { Component, ChangeDetectorRef, OnDestroy } from '@angular/core';
import { FormControl } from '@angular/forms';
import { OnInit } from '@angular/core';
import {
  StringCustomFieldConfig,
  FormInputComponent,
  Collection,
  Product,
  Channel,
} from '@vendure/admin-ui/core';
import { DataService } from '@vendure/admin-ui/core';
import { ActivatedRoute } from '@angular/router';
import { Subscription, combineLatest, Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { ID } from '@vendure/common/lib/shared-types';
import { GET_PRODUCT_DETAIL } from './select-primary-collection.graphql';
export type ProductPrimaryCollection = {
  channelId: ID;
  collectionId: ID;
};
type CollectionWithChannel = Collection & {
  channels: Channel[];
};
type ProductWithPrimaryCollection = Omit<Product, 'collections'> & {
  primaryCollection: CollectionWithChannel;
  collections: CollectionWithChannel[];
};
type CollectionFragment = Partial<Collection> & {
  id: ID;
  name: string;
};
function idsAreEqual(id1?: ID, id2?: ID): boolean {
  if (id1 === undefined || id2 === undefined) {
    return false;
  }
  return id1.toString() === id2.toString();
}
@Component({
  template: `
    <select
      *ngIf="!productsCollectionsAreLoading"
      [formControl]="primaryCollectionFormControl"
      [vdrDisabled]="readonly"
      [compareWith]="compareFn"
    >
      <option *ngFor="let option of productsCollections" [ngValue]="option">
        {{ option.name }}
      </option>
    </select>
  `,
})
export class SelectPrimaryCollectionComponent
  implements FormInputComponent<StringCustomFieldConfig>, OnInit, OnDestroy
{
  readonly!: boolean;
  config!: StringCustomFieldConfig;
  formControl!: FormControl<string>;
  primaryCollectionFormControl: FormControl;
  productsCollections!: Collection[];
  productsCollectionsAreLoading = true;
  productCollectionSubscription: Subscription;
  productDetailInActiveChannel$: Observable<void>;
  id!: string | null;
  constructor(
    private dataService: DataService,
    private cdr: ChangeDetectorRef,
    private activatedRoute: ActivatedRoute
  ) {}
  ngOnDestroy(): void {
    if (this.productCollectionSubscription) {
      this.productCollectionSubscription.unsubscribe();
    }
  }
  ngOnInit(): void {
    this.formControl.parent?.parent?.statusChanges.subscribe(() => {
      if (
        this.formControl.pristine &&
        !this.formControl.value &&
        (this.productsCollections?.length ||
          this.productsCollectionsAreLoading) &&
        this.id !== 'create'
      ) {
        this.formControl.parent?.parent?.markAsPristine();
      }
    });
    this.id = this.activatedRoute.snapshot.paramMap.get('id');
    if (this.id && this.id !== 'create') {
      const activeChannel$ = this.dataService.settings
        .getActiveChannel()
        .refetchOnChannelChange()
        .mapStream((data) => data.activeChannel);
      const productDetail$ = this.dataService
        .query<{ product: ProductWithPrimaryCollection }, { id: string }>(
          GET_PRODUCT_DETAIL,
          { id: this.id }
        )
        .refetchOnChannelChange()
        .mapSingle(
          (data: { product: ProductWithPrimaryCollection }) => data.product
        );
      this.productDetailInActiveChannel$ = combineLatest(
        activeChannel$,
        productDetail$
      ).pipe(
        map(([activeChannel, product]) => {
          this.productsCollections = this.getEligiblePrimaryCollections(
            product,
            activeChannel.id
          );
          this.productsCollectionsAreLoading = false;
          this.primaryCollectionFormControl =
            new FormControl<CollectionFragment>(product?.primaryCollection);
          this.primaryCollectionFormControl.valueChanges.subscribe(
            (selectedPrimaryCollection: CollectionFragment) => {
              this.updateComponentFormControl(
                activeChannel.id,
                selectedPrimaryCollection.id
              );
            }
          );
          this.cdr.markForCheck();
        })
      );
      this.productCollectionSubscription =
        this.productDetailInActiveChannel$.subscribe();
    }
  }
  compareFn(a: Partial<Collection>, b: Partial<Collection>): boolean {
    return a?.id === b?.id;
  }
  updateComponentFormControl = (
    activeChannelId: ID,
    selectedPrimaryCollectionId: ID
  ): void => {
    const allPrimaryCollectionsList = JSON.parse(
      this.formControl.value ?? '[]'
    ) as ProductPrimaryCollection[];
    let valueUpdated = false;
    for (const primaryCollectionDetail of allPrimaryCollectionsList) {
      if (idsAreEqual(primaryCollectionDetail.channelId, activeChannelId)) {
        primaryCollectionDetail.collectionId = selectedPrimaryCollectionId;
        valueUpdated = true;
      }
    }
    if (!valueUpdated) {
      allPrimaryCollectionsList.push({
        channelId: activeChannelId,
        collectionId: selectedPrimaryCollectionId,
      });
    }
    this.formControl.setValue(JSON.stringify(allPrimaryCollectionsList));
    this.formControl.markAsDirty();
  };
  getEligiblePrimaryCollections(
    product: ProductWithPrimaryCollection,
    activeChannelId: ID
  ): Collection[] {
    return product?.collections.filter((collection) => {
      return (
        !collection.isPrivate &&
        !!collection.channels.find((collectionChannel) =>
          idsAreEqual(collectionChannel.id, activeChannelId)
        )
      );
    });
  }
}
```

## File: packages/vendure-plugin-primary-collection/src/ui/select-primary-collection.graphql.ts

```typescript
import { gql } from 'graphql-tag';
export const GET_PRODUCT_DETAIL = gql`
  query ProductsCollection($id: ID) {
    product(id: $id) {
      primaryCollection {
        id
        name
        channels {
          id
        }
      }
      collections {
        id
        name
        channels {
          id
        }
      }
    }
  }
`;
```

## File: packages/vendure-plugin-primary-collection/src/ui/shared.module.ts

```typescript
import { NgModule } from '@angular/core';
import {
  SharedModule,
  registerFormInputComponent,
} from '@vendure/admin-ui/core';
import { SelectPrimaryCollectionComponent } from './select-primary-collection.component';
@NgModule({
  imports: [SharedModule],
  declarations: [SelectPrimaryCollectionComponent],
  providers: [
    registerFormInputComponent(
      'select-primary-collection',
      SelectPrimaryCollectionComponent
    ),
  ],
})
export class PrimaryCollectionSharedExtensionModule {}
```

## File: packages/vendure-plugin-primary-collection/src/util/export-primary-collections.ts

```typescript
import { Product, ID, Collection, Logger } from '@vendure/core';
import { QueryRunner } from 'typeorm';
import { promises as fs } from 'fs';
import { loggerCtx } from '../constants';
export const EXPORTED_PRIMARY_COLLECTIONS_FILE = 'data.json';
export type ExportedPrimaryCollectionData = {
  productId: ID;
  primaryCollectionId: ID;
};
export async function exportPrimaryCollections(queryRunner: QueryRunner) {
  try {
    const productRepo = queryRunner.manager.getRepository(Product);
    const allProducts = await productRepo
      .createQueryBuilder('product')
      .innerJoin(
        Collection,
        'primaryCollection',
        'primaryCollection.id = product.customFieldsPrimarycollectionId'
      )
      .select(['product.id', 'primaryCollection.id'])
      .getRawMany();
    const data: ExportedPrimaryCollectionData[] = [];
    for (const product of allProducts) {
      data.push({
        productId: product.product_id,
        primaryCollectionId: product.primaryCollection_id,
      });
    }
    const jsonString: string = JSON.stringify(data, null, 2);
    await fs.writeFile(EXPORTED_PRIMARY_COLLECTIONS_FILE, jsonString);
    Logger.info(
      `Primary Collection data has been exported to ${EXPORTED_PRIMARY_COLLECTIONS_FILE}.`,
      loggerCtx
    );
  } catch (err) {
    Logger.error(`Error writing file: ${JSON.stringify(err)}`, loggerCtx);
    process.exit(1);
  }
}
```

## File: packages/vendure-plugin-primary-collection/src/util/helpers.ts

```typescript
import { idsAreEqual, ID, RequestContext } from '@vendure/core';
export type ProductPrimaryCollection = {
  channelId: ID;
  collectionId: ID;
};
export function parseProductPrimaryCollectionCustomField(
  primaryCollection: string | undefined
): ProductPrimaryCollection[] {
  return JSON.parse(primaryCollection ?? '[]');
}
export function getProductPrimaryCollectionIDInChannel(
  ctx: RequestContext,
  primaryCollection: string | undefined
): ID | undefined {
  const productPrimaryCollections =
    parseProductPrimaryCollectionCustomField(primaryCollection);
  return productPrimaryCollections.find((primaryCollection) =>
    idsAreEqual(primaryCollection.channelId, ctx.channelId)
  )?.collectionId;
}
```

## File: packages/vendure-plugin-primary-collection/src/util/update-primary-collections.ts

```typescript
import { QueryRunner } from 'typeorm';
import { promises as fs } from 'fs';
import {
  EXPORTED_PRIMARY_COLLECTIONS_FILE,
  ExportedPrimaryCollectionData,
} from './export-primary-collections';
import { Channel, Logger, Product } from '@vendure/core';
import { DEFAULT_CHANNEL_CODE } from '@vendure/common/lib/shared-constants';
import { loggerCtx } from '../constants';
import { ProductPrimaryCollection } from './helpers';
export async function updatePrimaryCollections(queryRunner: QueryRunner) {
  try {
    const productRepo = queryRunner.manager.getRepository(Product);
    const channelRepo = queryRunner.manager.getRepository(Channel);
    const defaultChannel = await channelRepo.findOne({
      where: { code: DEFAULT_CHANNEL_CODE },
    });
    if (!defaultChannel) {
      Logger.error(`Couldn't find the Default channel`, loggerCtx);
      process.exit(1);
    }
    const jsonData = await fs.readFile(
      EXPORTED_PRIMARY_COLLECTIONS_FILE,
      'utf8'
    );
    const primaryCollections: ExportedPrimaryCollectionData[] = JSON.parse(
      jsonData
    ) as ExportedPrimaryCollectionData[];
    const data: Partial<Product>[] = [];
    for (const primaryCollectionData of primaryCollections) {
      data.push({
        id: primaryCollectionData.productId,
        customFields: {
          primaryCollection: JSON.stringify([
            {
              channelId: defaultChannel.id,
              collectionId: primaryCollectionData.primaryCollectionId,
            } as ProductPrimaryCollection,
          ]),
        },
      });
    }
    await productRepo.save(data);
  } catch (e) {
    Logger.error(
      `Error saving Product primary Collections: ${JSON.stringify(e)}`,
      loggerCtx
    );
    process.exit(1);
  }
}
```

## File: packages/vendure-plugin-primary-collection/src/constants.ts

```typescript
export const loggerCtx = 'PrimaryCollectionPlugin';
```

## File: packages/vendure-plugin-primary-collection/src/index.ts

```typescript
export * from './primary-collection-plugin';
export * from './util/export-primary-collections';
export * from './util/update-primary-collections';
export * from './util/helpers';
export * from './api/primary-collections-helper.service';
```

## File: packages/vendure-plugin-primary-collection/src/primary-collection-plugin.ts

```typescript
import {
  LanguageCode,
  PluginCommonModule,
  RuntimeVendureConfig,
  Type,
  VendurePlugin,
} from '@vendure/core';
import { PrimaryCollectionPluginResolver } from './api/primary-collection.resolver';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { PrimaryCollectionHelperService } from './api/primary-collections-helper.service';
import { apiExtensions } from './api/api-extensions';
export interface PrimaryCollectionPluginConfig {
  customFieldUITabName?: string;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [PrimaryCollectionHelperService],
  shopApiExtensions: {
    schema: apiExtensions,
    resolvers: [PrimaryCollectionPluginResolver],
  },
  adminApiExtensions: {
    schema: apiExtensions,
    resolvers: [PrimaryCollectionPluginResolver],
  },
  exports: [PrimaryCollectionHelperService],
  compatibility: '>=2.2.0',
  configuration: (config: RuntimeVendureConfig) => {
    config.customFields.Product.push({
      name: 'primaryCollection',
      type: 'string',
      ui: {
        component: 'select-primary-collection',
        tab: PrimaryCollectionPlugin?.config?.customFieldUITabName,
      },
      label: [{ languageCode: LanguageCode.en, value: 'Primary Collection' }],
    });
    return config;
  },
})
export class PrimaryCollectionPlugin {
  static config: PrimaryCollectionPluginConfig;
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'shared',
        ngModuleFileName: 'shared.module.ts',
        ngModuleName: 'PrimaryCollectionSharedExtensionModule',
      },
    ],
  };
  static init(
    config: PrimaryCollectionPluginConfig
  ): Type<PrimaryCollectionPlugin> {
    this.config = config;
    return this;
  }
}
```

## File: packages/vendure-plugin-primary-collection/src/types.ts

```typescript
import { CustomProductFields } from '@vendure/core/dist/entity/custom-entity-fields';
import { Collection } from '@vendure/core';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomProductFields {
    primaryCollection: string;
  }
}
```

## File: packages/vendure-plugin-primary-collection/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  AutoIncrementIdStrategy,
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialTestData } from './initial-test-data';
import { PrimaryCollectionPlugin } from '../src/primary-collection-plugin';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      PrimaryCollectionPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [PrimaryCollectionPlugin.ui],
          devMode: true,
        }),
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    entityOptions: {
      entityIdStrategy: new AutoIncrementIdStrategy(),
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: initialTestData,
    productsCsvPath: './test/products.csv',
  });
})();
```

## File: packages/vendure-plugin-primary-collection/test/initial-test-data.ts

```typescript
import { LanguageCode } from '@vendure/common/lib/generated-types';
import { InitialData } from '@vendure/core';
export const initialTestData: InitialData = {
  defaultLanguage: LanguageCode.en,
  defaultZone: 'Europe',
  taxRates: [
    { name: 'Standard Tax', percentage: 20 },
    { name: 'Reduced Tax', percentage: 10 },
    { name: 'Zero Tax', percentage: 0 },
  ],
  shippingMethods: [
    { name: 'Standard Shipping', price: 500 },
    { name: 'Express Shipping', price: 1000 },
  ],
  countries: [
    { name: 'Australia', code: 'AU', zone: 'Oceania' },
    { name: 'Austria', code: 'AT', zone: 'Europe' },
    { name: 'Canada', code: 'CA', zone: 'Americas' },
    { name: 'China', code: 'CN', zone: 'Asia' },
    { name: 'South Africa', code: 'ZA', zone: 'Africa' },
    { name: 'United Kingdom', code: 'GB', zone: 'Europe' },
    { name: 'United States of America', code: 'US', zone: 'Americas' },
    { name: 'Nederland', code: 'NL', zone: 'Europe' },
  ],
  collections: [
    {
      name: 'Computers',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['computers'], containsAny: false },
        },
      ],
    },
    {
      name: 'Electronics',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['electronics'], containsAny: false },
        },
      ],
      private: true,
    },
    {
      name: 'Others',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['others'], containsAny: false },
        },
      ],
    },
    {
      name: 'Hardware',
      filters: [
        {
          code: 'facet-value-filter',
          args: { facetValueNames: ['hardware'], containsAny: false },
        },
      ],
    },
  ],
  paymentMethods: [],
};
```

## File: packages/vendure-plugin-primary-collection/test/primary-collection.spec.ts

```typescript
import {
  AutoIncrementIdStrategy,
  ChannelService,
  Collection,
  CurrencyCode,
  DefaultLogger,
  LanguageCode,
  LogLevel,
  Product,
  Role,
  RoleService,
  isGraphQlErrorResult,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { initialTestData } from './initial-test-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { PrimaryCollectionPlugin } from '../src/primary-collection-plugin';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import { expect, describe, beforeAll, afterAll, it } from 'vitest';
import { gql } from 'graphql-tag';
import { PrimaryCollectionHelperService } from '../src/api/primary-collections-helper.service';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
import { ProductPrimaryCollection } from '../src/util/helpers';
describe('Product Primary Collection', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  const secondChannelToken = 'second-channel-token';
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3106,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [PrimaryCollectionPlugin],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
      entityOptions: {
        entityIdStrategy: new AutoIncrementIdStrategy(),
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialTestData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: './test/products.csv',
      customerCount: 2,
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
    const channelService = server.app.get(ChannelService);
    const ctx = await getSuperadminContext(server.app);
    const createChannelResult = await channelService.create(ctx, {
      code: 'second-channel',
      defaultLanguageCode: LanguageCode.en,
      defaultCurrencyCode: CurrencyCode.USD,
      defaultShippingZoneId: 1,
      defaultTaxZoneId: 1,
      pricesIncludeTax: false,
      token: secondChannelToken,
    });
    if (isGraphQlErrorResult(createChannelResult)) {
      throw createChannelResult;
    }
    const roleService = server.app.get(RoleService);
    const superadminRole = await roleService.getSuperAdminRole(ctx);
    await channelService.assignToChannels(ctx, Role, superadminRole.id, [
      createChannelResult.id,
    ]);
    await channelService.assignToChannels(ctx, Product, 1, [
      createChannelResult.id,
    ]);
    await channelService.assignToChannels(ctx, Collection, 5, [
      createChannelResult.id,
    ]);
  }, 60000);
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  const primaryCollectionQuery = gql`
    query PrimaryCollectionQuery($productId: ID) {
      product(id: $productId) {
        id
        name
        primaryCollection {
          id
          name
        }
        breadcrumbs {
          id
          name
          slug
        }
      }
    }
  `;
  const updatePrimaryCollectionMutation = gql`
    mutation UpdateProductPrimaryCollection(
      $productId: ID!
      $primaryCollection: String
    ) {
      updateProduct(
        input: {
          id: $productId
          customFields: { primaryCollection: $primaryCollection }
        }
      ) {
        name
        id
        primaryCollection {
          name
          id
        }
      }
    }
  `;
  it("Should successfully update 'Laptop's primaryCollection as 'Electronics' in the default channel", async () => {
    const { updateProduct: product } = await adminClient.query(
      updatePrimaryCollectionMutation,
      {
        productId: 1,
        primaryCollection: JSON.stringify([
          {
            channelId: 1,
            collectionId: 3,
          } as ProductPrimaryCollection,
        ]),
      }
    );
    expect(product.name).toBe('Laptop');
    expect(product.id).toBe('1');
    expect(product.primaryCollection.name).toBe('Electronics');
  });
  it('Should not have a PrimaryCollection set for `Laptop` in the second channel', async () => {
    adminClient.setChannelToken(secondChannelToken);
    const { product } = await adminClient.query(primaryCollectionQuery, {
      productId: 1,
    });
    expect(product.name).toBe('Laptop');
    expect(product.id).toBe('1');
    expect(product.primaryCollection?.name).toBeUndefined();
  });
  it("Should return 'Electronics' as a primary collection for 'Laptop' in Shop API in the default channel", async () => {
    const { product } = await shopClient.query(primaryCollectionQuery, {
      productId: 1,
    });
    expect(product.name).toBe('Laptop');
    expect(product.primaryCollection.name).toBe('Electronics');
  });
  it("Shouldn't have primaryCollections set on products with id 2 and 3", async () => {
    const { product } = await shopClient.query(primaryCollectionQuery, {
      productId: 2,
    });
    const { product: anotherProduct } = await shopClient.query(
      primaryCollectionQuery,
      {
        productId: 3,
      }
    );
    expect(product.primaryCollection).toBeNull();
    expect(anotherProduct.primaryCollection).toBeNull();
  });
  it('Has breadcrumbs set on a product', async () => {
    const { product } = await shopClient.query(primaryCollectionQuery, {
      productId: 1,
    });
    expect(product.breadcrumbs).toEqual([
      { id: '1', name: '__root_collection__', slug: '__root_collection__' },
      { id: '3', name: 'Electronics', slug: 'electronics' },
      { id: '1', name: 'Laptop', slug: 'laptop' },
    ]);
  });
  it(`Should assign primaryCollection to all products after running the "setPrimaryCollectionForAllProducts" function,
  while preserving the values for those products who already had `, async () => {
    const ctx = await getSuperadminContext(server.app);
    await server.app
      .get(PrimaryCollectionHelperService)
      .setPrimaryCollectionForAllProducts(ctx);
    const { product: t1Product } = await shopClient.query(
      primaryCollectionQuery,
      {
        productId: 1,
      }
    );
    const { product: t2Product } = await shopClient.query(
      primaryCollectionQuery,
      {
        productId: 2,
      }
    );
    const { product: t3Product } = await shopClient.query(
      primaryCollectionQuery,
      {
        productId: 3,
      }
    );
    expect(t1Product.primaryCollection.name).not.toBe('Electronics');
    expect(t1Product.primaryCollection.name).toBe('Computers');
    expect(t2Product.primaryCollection).toBeNull();
    expect(t3Product.primaryCollection).not.toBeNull();
    shopClient.setChannelToken(secondChannelToken);
    const { product: t1ProductDetailInSecondChannel } = await shopClient.query(
      primaryCollectionQuery,
      {
        productId: 1,
      }
    );
    expect(t1ProductDetailInSecondChannel.primaryCollection.name).toBe(
      'Hardware'
    );
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        PrimaryCollectionPlugin.ui
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-public-customer-groups/src/customer-group.d.ts

```typescript
import { CustomCustomerGroupFields } from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomCustomerGroupFields {
    isPublic: boolean;
  }
}
```

## File: packages/vendure-plugin-public-customer-groups/src/index.ts

```typescript
export * from './public-customer-groups.plugin';
```

## File: packages/vendure-plugin-public-customer-groups/src/public-customer-groups.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { PublicCustomerGroupsResolver } from './public-customer-groups.resolver';
import { shopApiExtensions } from './schema';
@VendurePlugin({
  imports: [PluginCommonModule],
  configuration: (config) => {
    config.customFields.CustomerGroup.push({
      name: 'isPublic',
      type: 'boolean',
      public: false,
    });
    return config;
  },
  shopApiExtensions: {
    resolvers: [PublicCustomerGroupsResolver],
    schema: shopApiExtensions,
  },
  compatibility: '>=2.2.0',
})
export class PublicCustomerGroupsPlugin {}
```

## File: packages/vendure-plugin-public-customer-groups/src/public-customer-groups.resolver.ts

```typescript
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import {
  Ctx,
  RequestContext,
  Customer,
  CustomerService,
  CustomerGroup,
  PaginatedList,
} from '@vendure/core';
@Resolver()
export class PublicCustomerGroupsResolver {
  constructor(private readonly customerService: CustomerService) {}
  @ResolveField('customerGroups')
  @Resolver('Customer')
  async customerGroups(
    @Ctx() ctx: RequestContext,
    @Parent() customer: Customer
  ): Promise<CustomerGroup[]> {
    const customerGroups = await this.customerService.getCustomerGroups(
      ctx,
      customer.id
    );
    return customerGroups.filter((group) => !!group.customFields.isPublic);
  }
  @ResolveField('customers')
  @Resolver('CustomerGroup')
  async customers(
    @Ctx() ctx: RequestContext,
    @Parent() _: CustomerGroup
  ): Promise<PaginatedList<Customer>> {
    return { items: [], totalItems: 0 };
  }
}
```

## File: packages/vendure-plugin-public-customer-groups/src/schema.ts

```typescript
import gql from 'graphql-tag';
export const shopApiExtensions = gql`
  extend type Customer {
    customerGroups: [CustomerGroup!]!
  }
`;
```

## File: packages/vendure-plugin-public-customer-groups/test/dev-server.ts

```typescript
import { initialData } from '../../test/src/initial-data';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  Logger,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { PublicCustomerGroupsPlugin } from '../src/public-customer-groups.plugin';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Info }),
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
      port: 1234,
    },
    plugins: [
      PublicCustomerGroupsPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
})();
```

## File: packages/vendure-plugin-public-customer-groups/test/e2e.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { initialData } from '../../test/src/initial-data';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { describe, beforeAll, it, expect } from 'vitest';
import { PublicCustomerGroupsPlugin } from '../src/public-customer-groups.plugin';
import {
  CREATE_CUSTOMER_GROUP,
  getActiveCustomer,
  nonPublicCustomerGroupInput,
  publicCustomerGroupInput,
} from './test-helpers';
describe('Public Customer Groups', function () {
  let server: TestServer;
  let shopClient: SimpleGraphQLClient;
  let adminClient: SimpleGraphQLClient;
  let serverStarted = false;
  let publicCustomerGroupId;
  let nonPublicCustomerGroupId;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [PublicCustomerGroupsPlugin],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, shopClient, adminClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 5,
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
    publicCustomerGroupId = (
      (await adminClient.query(CREATE_CUSTOMER_GROUP, {
        input: publicCustomerGroupInput,
      })) as any
    ).createCustomerGroup.id;
    nonPublicCustomerGroupId = (
      (await adminClient.query(CREATE_CUSTOMER_GROUP, {
        input: nonPublicCustomerGroupInput,
      })) as any
    ).createCustomerGroup.id;
  }, 60000);
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  it('Should fetch only public customer groups for customer and activeCustomer.customerGroups.customers should also be empty', async () => {
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const {
      activeCustomer: { customerGroups },
    } = await shopClient.query(getActiveCustomer);
    expect(
      customerGroups.find(
        (customerGroup) => customerGroup.id === publicCustomerGroupId
      )
    ).toBeDefined();
    expect(
      customerGroups.find(
        (customerGroup) => customerGroup.id === nonPublicCustomerGroupId
      )
    ).not.toBeDefined();
    for (let customerGroup of customerGroups) {
      expect(customerGroup.customers.items.length).toBe(0);
    }
  });
});
```

## File: packages/vendure-plugin-public-customer-groups/test/test-helpers.ts

```typescript
import { gql } from 'graphql-tag';
import { CreateCustomerGroupInput } from '@vendure/common/lib/generated-types';
export const addCustomerToGroups = gql`
  mutation createCustomerGroup($input: CreateCustomerGroupInput!) {
    createCustomerGroup(input: $input) {
      id
      name
      customFields {
        isPublic
      }
    }
  }
`;
export const getActiveCustomer = gql`
  query GetActiveCustomerDetails {
    activeCustomer {
      customerGroups {
        id
        customers {
          items {
            id
          }
        }
      }
    }
  }
`;
export const publicCustomerGroupInput: CreateCustomerGroupInput = {
  name: 'Public Group',
  //hayden.zieme12@hotmail.com's id
  customerIds: ['T_1'],
  customFields: {
    isPublic: true,
  },
};
export const nonPublicCustomerGroupInput: CreateCustomerGroupInput = {
  name: 'Non Public Group',
  //hayden.zieme12@hotmail.com's id
  customerIds: ['T_1'],
  customFields: {
    isPublic: false,
  },
};
export const CUSTOMER_GROUP_FRAGMENT = gql`
  fragment CustomerGroup on CustomerGroup {
    id
    createdAt
    updatedAt
    name
  }
`;
export const CREATE_CUSTOMER_GROUP = gql`
  mutation CreateCustomerGroup($input: CreateCustomerGroupInput!) {
    createCustomerGroup(input: $input) {
      ...CustomerGroup
    }
  }
  ${CUSTOMER_GROUP_FRAGMENT}
`;
```

## File: packages/vendure-plugin-selectable-gifts/src/api/api-extensions.ts

```typescript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import {
  ActiveOrderService,
  Allow,
  Ctx,
  ID,
  Order,
  Permission,
  ProductVariant,
  RequestContext,
  Transaction,
  UserInputError,
} from '@vendure/core';
import { gql } from 'graphql-tag';
import { GiftService } from '../api/gift.service';
export const shopApiExtensions = gql`
  extend type Query {
    eligibleGifts: [ProductVariant!]!
  }
  extend type Mutation {
    addSelectedGiftToOrder(productVariantId: ID!): UpdateOrderItemsResult!
  }
`;
@Resolver()
export class GiftResolver {
  constructor(
    private giftService: GiftService,
    private activeOrderService: ActiveOrderService
  ) {}
  @Query()
  @Allow(Permission.Public)
  async eligibleGifts(@Ctx() ctx: RequestContext): Promise<ProductVariant[]> {
    const activeOrder = await this.getActiveOrder(ctx);
    return this.giftService.getEligibleGiftsForOrder(ctx, activeOrder.id);
  }
  @Transaction()
  @Mutation()
  @Allow(Permission.UpdateOrder, Permission.Owner)
  async addSelectedGiftToOrder(
    @Ctx() ctx: RequestContext,
    @Args('productVariantId') productVariantId: ID
  ): Promise<Order> {
    const activeOrder = await this.getActiveOrder(ctx);
    return this.giftService.addGiftToOrder(
      ctx,
      activeOrder.id,
      productVariantId
    );
  }
  async getActiveOrder(ctx: RequestContext): Promise<Order> {
    const order = await this.activeOrderService.getActiveOrder(
      ctx,
      undefined,
      true
    );
    if (!order) {
      throw new UserInputError('No active order found');
    }
    return order;
  }
}
```

## File: packages/vendure-plugin-selectable-gifts/src/api/custom-fields.ts

```typescript
import { CustomFieldConfig } from '@vendure/core';
export const orderLineCustomFields: CustomFieldConfig[] = [
  {
    name: 'isSelectedAsGift',
    type: 'boolean',
    readonly: true,
    public: true,
    internal: false,
  },
];
```

## File: packages/vendure-plugin-selectable-gifts/src/api/free-gift.promotion-action.ts

```typescript
import { LanguageCode, Logger, PromotionItemAction } from '@vendure/core';
import { loggerCtx } from '../constants';
export const freeGiftPromotionAction = new PromotionItemAction({
  code: 'selectable_gifts',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Allow selected products as free gift',
    },
  ],
  args: {
    variants: {
      type: 'ID',
      description: [
        {
          languageCode: LanguageCode.en,
          value: 'One of these products can be selected as gift',
        },
      ],
      list: true,
      ui: { component: 'product-selector-form-input' },
    },
  },
  init(injector) {},
  async execute(ctx, orderLine, args, state) {
    if ((orderLine.customFields as any).isSelectedAsGift) {
      Logger.verbose(
        `Discounting 1 ${orderLine.productVariant.name} (order line ${orderLine.id}) because it's selected as gift`,
        loggerCtx
      );
      const unitPrice = ctx.channel.pricesIncludeTax
        ? orderLine.unitPriceWithTax
        : orderLine.unitPrice;
      return -unitPrice;
    }
    return 0;
  },
});
```

## File: packages/vendure-plugin-selectable-gifts/src/api/gift.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { ConfigurableOperation } from '@vendure/common/lib/generated-types';
import {
  ID,
  Order,
  OrderService,
  ProductVariant,
  ProductVariantService,
  Promotion,
  PromotionService,
  RequestContext,
  StockLevelService,
  UserInputError,
} from '@vendure/core';
import { freeGiftPromotionAction } from './free-gift.promotion-action';
@Injectable()
export class GiftService {
  constructor(
    private promotionService: PromotionService,
    private orderService: OrderService,
    private variantService: ProductVariantService,
    private stockLevelService: StockLevelService
  ) {}
  async getEligibleGiftsForOrder(
    ctx: RequestContext,
    orderId: ID
  ): Promise<ProductVariant[]> {
    const appliedPromotions =
      await this.promotionService.getActivePromotionsOnOrder(ctx, orderId);
    const freeGiftPromotions = appliedPromotions.filter((promotion) =>
      promotion.actions.some(
        (action) => action.code === freeGiftPromotionAction.code
      )
    );
    if (!freeGiftPromotions.length) {
      return [];
    }
    const variantIds = this.getConfiguredGifts(freeGiftPromotions);
    if (!variantIds.length) {
      return [];
    }
    const variants = await this.variantService.findByIds(ctx, variantIds);
    const variantsWithStock: ProductVariant[] = [];
    await Promise.all(
      variants.map(async (variant) => {
        if ((await this.hasStock(ctx, variant)) && variant.enabled) {
          variantsWithStock.push(variant);
        }
      })
    );
    return variantsWithStock;
  }
  async addGiftToOrder(
    ctx: RequestContext,
    orderId: ID,
    productVariantId: ID
  ): Promise<Order> {
    const eligibleGifts = await this.getEligibleGiftsForOrder(ctx, orderId);
    if (!eligibleGifts.find((gift) => gift.id === productVariantId)) {
      throw new UserInputError(
        `Variant ${productVariantId} is not eligible as gift for this order`
      );
    }
    const order = await this.orderService.findOne(ctx, orderId, [
      'lines',
      'lines.productVariant',
    ]);
    if (!order) {
      throw new UserInputError(`Order with id ${orderId} not found`);
    }
    const giftLine = order.lines.find(
      (line) => (line.customFields as any)?.isSelectedAsGift
    );
    if (giftLine) {
      await this.orderService.adjustOrderLine(ctx, orderId, giftLine.id, 0, {
        isSelectedAsGift: false,
      });
    }
    return this.orderService.addItemToOrder(ctx, orderId, productVariantId, 1, {
      isSelectedAsGift: true,
    }) as any;
  }
  private getConfiguredGifts(promotions: Promotion[]): ID[] {
    const actions: ConfigurableOperation[] = [];
    promotions.forEach((promotion) => {
      promotion.actions.forEach((action) => {
        if (action.code === freeGiftPromotionAction.code) {
          actions.push(action);
        }
      });
    });
    const allVariantIds: ID[] = [];
    actions.forEach(async (action) => {
      const variantsArg = action.args.find(
        (arg) => arg.name === 'variants'
      )?.value;
      if (!variantsArg) {
        return [];
      }
      const variantIds = this.parseConfigArg(variantsArg);
      if (!variantIds.length) {
        return [];
      }
      allVariantIds.push(...variantIds);
    });
    return allVariantIds;
  }
  private parseConfigArg(facetValueIdsArg: string): ID[] {
    return JSON.parse(facetValueIdsArg);
  }
  private async hasStock(
    ctx: RequestContext,
    variant: ProductVariant
  ): Promise<boolean> {
    const { stockAllocated, stockOnHand } =
      await this.stockLevelService.getAvailableStock(ctx, variant.id);
    return stockOnHand > stockAllocated;
  }
}
```

## File: packages/vendure-plugin-selectable-gifts/src/api/placed-orders.promotion-condition.ts

```typescript
import {
  Injector,
  LanguageCode,
  PromotionCondition,
  TransactionalConnection,
  Order,
} from '@vendure/core';
let injector: Injector;
export const minOrdersPlacedPromotionCondition = new PromotionCondition({
  code: 'minimum_orders_placed',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Customer has placed { minimum } orders',
    },
  ],
  args: {
    minimum: {
      type: 'int',
      defaultValue: 1,
    },
    maximum: {
      type: 'int',
      defaultValue: 9999,
    },
  },
  init(_injector) {
    injector = _injector;
  },
  async check(ctx, order, args) {
    if (!order.customerId) {
      return false;
    }
    const placedOrderCount = await injector
      .get(TransactionalConnection)
      .getRepository(ctx, Order)
      .createQueryBuilder('order')
      .where('order.customerId = :customerId', { customerId: order.customerId })
      .andWhere('orderPlacedAt IS NOT NULL')
      .getCount();
    return args.minimum <= placedOrderCount && placedOrderCount <= args.maximum;
  },
});
```

## File: packages/vendure-plugin-selectable-gifts/src/constants.ts

```typescript
export const loggerCtx = 'SelectableGiftsPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-selectable-gifts/src/index.ts

```typescript
export * from './selectable-gifts.plugin';
export * from './api/free-gift.promotion-action';
export * from './api/placed-orders.promotion-condition';
export * from './api/gift.service';
```

## File: packages/vendure-plugin-selectable-gifts/src/selectable-gifts.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { GiftResolver, shopApiExtensions } from './api/api-extensions';
import { orderLineCustomFields } from './api/custom-fields';
import { freeGiftPromotionAction } from './api/free-gift.promotion-action';
import { minOrdersPlacedPromotionCondition } from './api/placed-orders.promotion-condition';
import { GiftService } from './api/gift.service';
export interface GiftPluginOptions {
  enabled: boolean;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [GiftService],
  shopApiExtensions: {
    resolvers: [GiftResolver],
    schema: shopApiExtensions,
  },
  configuration: (config) => {
    config.promotionOptions.promotionActions.push(freeGiftPromotionAction);
    config.promotionOptions.promotionConditions.push(
      minOrdersPlacedPromotionCondition
    );
    config.customFields.OrderLine.push(...orderLineCustomFields);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class SelectableGiftsPlugin {}
```

## File: packages/vendure-plugin-selectable-gifts/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { AssetServerPlugin } from '@vendure/asset-server-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import path from 'path';
import { initialData } from '../../test/src/initial-data';
import { SelectableGiftsPlugin } from '../src';
import {
  ADD_ITEM_TO_ORDER,
  createPromotion,
  ELIGIBLE_GIFTS,
  getEligibleGifts,
} from './helpers';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      AssetServerPlugin.init({
        assetUploadDir: path.join(__dirname, '__data__/assets'),
        route: 'assets',
      }),
      SelectableGiftsPlugin,
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
  await createPromotion(
    adminClient,
    'Gift for orders above $0',
    ['T_1'],
    [
      {
        code: 'minimum_order_amount',
        arguments: [
          {
            name: 'amount',
            value: '0',
          },
          {
            name: 'taxInclusive',
            value: 'false',
          },
        ],
      },
    ]
  );
  await shopClient.query(ADD_ITEM_TO_ORDER, {
    productVariantId: 'T_1',
    quantity: 1,
  });
  const gifts = await getEligibleGifts(shopClient);
  console.log(gifts);
})();
```

## File: packages/vendure-plugin-selectable-gifts/test/e2e.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { SelectableGiftsPlugin } from '../src';
import {
  ADD_GIFT_TO_ORDER,
  ADD_ITEM_TO_ORDER,
  UPDATE_PRODUCT_VARIANT_STOCK_ON_HAND,
  VARIANT_STOCK_LOCATIONS,
  createPromotion,
  getEligibleGifts,
} from './helpers';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
let serverStarted = false;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [SelectableGiftsPlugin],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
}, 60000);
it('Start successfully', async () => {
  await expect(server.app.getHttpServer).toBeDefined;
});
const giftForOrdersAbove0 = 'T_2';
const giftForLoyalCustomer = 'T_4';
describe('Gift management via admin UI', function () {
  it('Creates a gift promotion for orders greater than $0', async () => {
    await adminClient.asSuperAdmin();
    const promotion = await createPromotion(
      adminClient,
      'Free gift for orders above $0',
      [giftForOrdersAbove0],
      [
        {
          code: 'minimum_order_amount',
          arguments: [
            {
              name: 'amount',
              value: '0',
            },
            {
              name: 'taxInclusive',
              value: 'false',
            },
          ],
        },
      ]
    );
    expect(promotion.name).toBe('Free gift for orders above $0');
  });
  it('Creates a gift promotion for customers with 1 or more placed orders', async () => {
    const promotion = await createPromotion(
      adminClient,
      'Free gift for loyal customers',
      [giftForLoyalCustomer],
      [
        {
          code: 'minimum_orders_placed',
          arguments: [
            {
              name: 'minimum',
              value: '1',
            },
            {
              name: 'maximum',
              value: '2',
            },
          ],
        },
      ]
    );
    expect(promotion.name).toBe('Free gift for loyal customers');
  });
});
describe('Storefront free gift selection', function () {
  it('Should not allow setting gift custom field via shop api', async () => {
    let error: string | undefined = undefined;
    try {
      await shopClient.query(ADD_ITEM_TO_ORDER, {
        productVariantId: 'T_1',
        quantity: 1,
        customFields: {
          isSelectedAsGift: true,
        },
      });
    } catch (e) {
      error = e.message;
    }
    expect(error).toBe('The custom field "isSelectedAsGift" is readonly');
  });
  it('Has no eligible gifts for an empty order', async () => {
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const eligibleGifts = await getEligibleGifts(shopClient);
    expect(eligibleGifts.length).toBe(0);
  });
  it('Add item to order, so the order has a total > $0', async () => {
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: 'T_1',
        quantity: 1,
      }
    );
    expect(order.lines.length).toBe(1);
    expect(order.totalWithTax).toBeGreaterThan(0);
  });
  it('Has 1 eligible gift for order > $0', async () => {
    const eligibleGifts = await getEligibleGifts(shopClient);
    expect(eligibleGifts.length).toBe(1);
    expect(eligibleGifts[0].id).toBe(giftForOrdersAbove0);
  });
  it('Adds gift to order', async () => {
    const { addSelectedGiftToOrder: order } = await shopClient.query(
      ADD_GIFT_TO_ORDER,
      { productVariantId: giftForOrdersAbove0 }
    );
    const giftLine = order.lines.find(
      (line) => line.productVariant.id === giftForOrdersAbove0
    );
    expect(order.lines.length).toBe(2);
    expect(giftLine.customFields.isSelectedAsGift).toBe(true);
    expect(giftLine.discountedUnitPriceWithTax).toBe(0);
    expect(giftLine.discountedLinePriceWithTax).toBe(0);
    expect(order.discounts[0].description).toBe(
      'Free gift for orders above $0'
    );
  });
  it('Create a new non-discounted order line when the gift is added as normal item', async () => {
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: giftForOrdersAbove0,
        quantity: 1,
      }
    );
    const linesWithGiftVariant = order.lines.filter(
      (line) => line.productVariant.id === giftForOrdersAbove0
    );
    expect(linesWithGiftVariant.length).toBe(2);
    expect(linesWithGiftVariant[0].discountedLinePriceWithTax).toBe(0);
    expect(linesWithGiftVariant[1].discountedLinePriceWithTax).toBe(167880);
  });
  it('Creates a placed order for customer', async () => {
    const order: any = await createSettledOrder(shopClient, 1, false);
    expect(order.code).toBeDefined();
  });
  it('Has 2 eligible gifts, because both gift promotions are now eligible: 1 order placed and order > $0', async () => {
    await shopClient.query(ADD_ITEM_TO_ORDER, {
      productVariantId: 'T_1',
      quantity: 1,
    });
    const eligibleGifts = await getEligibleGifts(shopClient);
    expect(eligibleGifts.length).toBe(2);
    expect(
      eligibleGifts.find((g) => g.id === giftForLoyalCustomer)
    ).toBeDefined();
    expect(
      eligibleGifts.find((g) => g.id === giftForOrdersAbove0)
    ).toBeDefined();
  });
  it('Adds "Loyal customer" gift to order', async () => {
    const { addSelectedGiftToOrder: order } = await shopClient.query(
      ADD_GIFT_TO_ORDER,
      { productVariantId: giftForLoyalCustomer }
    );
    const giftLine = order.lines.find(
      (line) => line.productVariant.id === giftForLoyalCustomer
    );
    expect(order.lines.length).toBe(2);
    expect(giftLine.customFields.isSelectedAsGift).toBe(true);
    expect(giftLine.discountedUnitPriceWithTax).toBe(0);
    expect(giftLine.discountedLinePriceWithTax).toBe(0);
    expect(order.discounts[0].description).toBe(
      'Free gift for loyal customers'
    );
  });
  it('Adds a new gift to order and removes the old gift', async () => {
    const { addSelectedGiftToOrder: order } = await shopClient.query(
      ADD_GIFT_TO_ORDER,
      { productVariantId: giftForOrdersAbove0 }
    );
    const giftLine = order.lines.find(
      (line) => line.productVariant.id === giftForOrdersAbove0
    );
    const linesSelectedAsGift = order.lines.filter(
      (l) => l.customFields.isSelectedAsGift
    );
    expect(order.lines.length).toBe(2);
    expect(linesSelectedAsGift.length).toBe(1);
    expect(giftLine.customFields.isSelectedAsGift).toBe(true);
    expect(giftLine.discountedUnitPriceWithTax).toBe(0);
    expect(giftLine.discountedLinePriceWithTax).toBe(0);
  });
  it('Still has eligible gifts after a gift has been added', async () => {
    const eligibleGifts = await getEligibleGifts(shopClient);
    expect(eligibleGifts.length).toBeGreaterThan(0);
  });
  it('Creates 2 more placed orders for customer', async () => {
    const order: any = await createSettledOrder(shopClient, 1, false);
    expect(order.code).toBeDefined();
    const order2: any = await createSettledOrder(shopClient, 1, false);
    expect(order2.code).toBeDefined();
  });
  it('Has 1 eligible gift, because the customer has placed 3 orders, and the configured max is 2', async () => {
    await shopClient.query(ADD_ITEM_TO_ORDER, {
      productVariantId: 'T_1',
      quantity: 1,
    });
    const eligibleGifts = await getEligibleGifts(shopClient);
    expect(eligibleGifts.length).toBe(1);
    expect(eligibleGifts[0].name).not.toBeUndefined();
    expect(eligibleGifts[0].name).not.toBeNull();
    expect(eligibleGifts[0].name?.trim()).not.toEqual('');
    expect(eligibleGifts[0].priceWithTax).toBeGreaterThan(0);
  });
  it('Should return only in stock variants as eligible gifts', async () => {
    const {
      productVariant: { stockLevels },
    } = await adminClient.query(VARIANT_STOCK_LOCATIONS, {
      id: giftForOrdersAbove0,
    });
    const stockLevelUpdateInput: any[] = [];
    for (let stockLevel of stockLevels) {
      stockLevelUpdateInput.push({
        stockLocationId: (stockLevel as any).stockLocation.id,
        stockOnHand: 0,
      });
    }
    const { updateProductVariants } = await adminClient.query(
      UPDATE_PRODUCT_VARIANT_STOCK_ON_HAND,
      { id: giftForOrdersAbove0, stockLevels: stockLevelUpdateInput }
    );
    expect(updateProductVariants[0].id).toBe(giftForOrdersAbove0);
    expect(updateProductVariants[0].stockLevel).toBe('OUT_OF_STOCK');
    const eligibleGifts = await getEligibleGifts(shopClient);
    expect(eligibleGifts.length).toBe(0);
  });
  afterAll(() => {
    return server.destroy();
  });
});
```

## File: packages/vendure-plugin-selectable-gifts/test/helpers.ts

```typescript
import { ProductVariant, Promotion } from '@vendure/core';
import { SimpleGraphQLClient } from '@vendure/testing';
import { CreatePromotionInput } from '@vendure/common/lib/generated-types';
import { gql } from 'graphql-tag';
const orderFragment = gql`
  fragment OrderFields on Order {
    id
    code
    totalWithTax
    lines {
      id
      quantity
      linePriceWithTax
      discountedUnitPriceWithTax
      discountedLinePriceWithTax
      productVariant {
        id
        name
        sku
      }
      customFields {
        isSelectedAsGift
      }
    }
    discounts {
      amount
      amountWithTax
      description
    }
  }
`;
export const ADD_ITEM_TO_ORDER = gql`
  ${orderFragment}
  mutation AddItemToOrder(
    $productVariantId: ID!
    $quantity: Int!
    $customFields: OrderLineCustomFieldsInput
  ) {
    addItemToOrder(
      productVariantId: $productVariantId
      quantity: $quantity
      customFields: $customFields
    ) {
      ... on Order {
        ...OrderFields
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const ADD_GIFT_TO_ORDER = gql`
  ${orderFragment}
  mutation addSelectedGiftToOrder($productVariantId: ID!) {
    addSelectedGiftToOrder(productVariantId: $productVariantId) {
      ... on Order {
        ...OrderFields
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const ELIGIBLE_GIFTS = gql`
  query eligibleGifts {
    eligibleGifts {
      id
      name
      sku
      priceWithTax
    }
  }
`;
export const UPDATE_PRODUCT_VARIANT_STOCK_ON_HAND = gql`
  mutation UpdateProductVariantStockOnHandMutation(
    $id: ID!
    $stockLevels: [StockLevelInput!]
  ) {
    updateProductVariants(
      input: [{ id: $id, stockLevels: $stockLevels, trackInventory: TRUE }]
    ) {
      id
      stockLevel
    }
  }
`;
export const VARIANT_STOCK_LOCATIONS = gql`
  query GetVariantStockLocationsQuery($id: ID!) {
    productVariant(id: $id) {
      stockLevels {
        stockLocation {
          id
        }
        stockOnHand
      }
    }
  }
`;
/**
 * Create a promotion that allows for a free  gift for orders above a certain amount
 */
export async function createPromotion(
  adminClient: SimpleGraphQLClient,
  promotionName: string,
  variantsAsGifts: string[],
  conditions: CreatePromotionInput['conditions']
): Promise<Promotion> {
  const input = {
    input: {
      translations: [
        {
          languageCode: 'en',
          name: promotionName,
          description: '',
        },
      ],
      enabled: true,
      startsAt: null,
      endsAt: null,
      conditions,
      actions: [
        {
          code: 'selectable_gifts',
          arguments: [
            {
              name: 'variants',
              value: JSON.stringify(variantsAsGifts),
            },
          ],
        },
      ],
    },
  };
  const { createPromotion } = await adminClient.query(
    gql`
      mutation createPromotion($input: CreatePromotionInput!) {
        createPromotion(input: $input) {
          ... on Promotion {
            id
            createdAt
            updatedAt
            name
            enabled
            couponCode
            perCustomerUsageLimit
            startsAt
            endsAt
          }
        }
      }
    `,
    input
  );
  return createPromotion;
}
export async function getEligibleGifts(
  shopClient: SimpleGraphQLClient
): Promise<ProductVariant[]> {
  const { eligibleGifts } = await shopClient.query(ELIGIBLE_GIFTS);
  return eligibleGifts;
}
```

## File: packages/vendure-plugin-sendcloud/src/api/types/sendcloud-api.types.ts

```typescript
export interface ParcelInput {
  name: string;
  company_name?: string;
  address: string;
  house_number: string;
  city: string;
  postal_code: string;
  country: string;
  telephone?: string;
  request_label: boolean;
  email?: string;
  order_number?: string;
  parcel_items: ParcelInputItem[];
  weight: string;
  shipping_method_checkout_name?: string;
}
export interface ParcelInputItem {
  description: string;
  quantity: number;
  weight: string;
  sku: string;
  value: string;
  hs_code?: string;
  origin_country?: string;
}
export interface Parcel {
  id: number;
  name: string;
  company_name: string;
  address: string;
  address_divided: AddressDivided;
  city: string;
  postal_code: string;
  telephone: string;
  email: string;
  date_created: string;
  date_updated: string;
  date_announced: string;
  tracking_number: string;
  weight: string;
  label: Label;
  customs_declaration: CustomsDeclaration;
  status: Status;
  data: any[];
  country: Country;
  shipment: Shipment;
  colli_tracking_number: string;
  colli_uuid: string;
  collo_nr: number;
  collo_count: number;
  awb_tracking_number: null;
  box_number: null;
  order_number?: string;
}
export interface AddressDivided {
  street: string;
  house_number: string;
}
export interface Country {
  iso_3: string;
  iso_2: string;
  name: string;
}
export interface CustomsDeclaration {}
export interface Label {
  normal_printer: string[];
  label_printer: string;
}
export interface Shipment {
  id: number;
  name: string;
}
export interface Status {
  id: number;
  message: string;
}
export interface IncomingWebhookBody {
  action: 'parcel_status_changed' | string;
  timestamp: number;
  parcel?: Parcel;
}
```

## File: packages/vendure-plugin-sendcloud/src/api/types/sendcloud.types.ts

```typescript
import { Injector, Order, OrderLine, RequestContext } from '@vendure/core';
import { ParcelInput, ParcelInputItem } from './sendcloud-api.types';
export interface SendcloudParcelStatus {
  id: number;
  message: string;
  orderState?: 'Shipped' | 'Delivered' | 'Cancelled';
}
export const sendcloudStates: SendcloudParcelStatus[] = [
  {
    id: 62989,
    message: 'The package has been held at customs',
  },
  {
    id: 6,
    message: 'Not sorted',
    orderState: 'Shipped',
  },
  {
    id: 15,
    message: 'Error collecting',
  },
  {
    id: 62990,
    message: 'The package is in the sorting centre',
    orderState: 'Shipped',
  },
  {
    id: 62991,
    message: 'The package was refused by the recipient when delivered',
  },
  {
    id: 62992,
    message: 'The package was returned to the sender due to an issue',
  },
  {
    id: 62993,
    message:
      'The delivery method was changed by the request of the recipient or due to other circumstances.',
  },
  {
    id: 1002,
    message: 'Announcement failed',
  },
  {
    id: 1999,
    message: 'Cancellation requested',
  },
  {
    id: 62994,
    message:
      'The delivery date was changed by the request of the recipient or due to other.',
  },
  {
    id: 62995,
    message:
      'The delivery address was changed by the request of the recipient or due to other circumstances.',
  },
  {
    id: 62996,
    message: 'For unusual cases: lost, damaged, destroyed, etc.',
  },
  {
    id: 1998,
    message: 'Cancelled upstream',
    orderState: 'Cancelled',
  },
  {
    id: 1000,
    message: 'Ready to send',
    orderState: 'Shipped',
  },
  {
    id: 62997,
    message:
      'The address is incorrect and the carrier needs address correction from the sender or the recipient.',
  },
  {
    id: 12,
    message: 'Awaiting customer pickup',
    orderState: 'Shipped',
  },
  {
    id: 11,
    message: 'Delivered',
    orderState: 'Delivered',
  },
  {
    id: 93,
    message: 'Shipment collected by customer',
    orderState: 'Delivered',
  },
  {
    id: 91,
    message: 'Parcel en route',
    orderState: 'Shipped',
  },
  {
    id: 80,
    message: 'Unable to deliver',
  },
  {
    id: 22,
    message: 'Shipment picked up by driver',
    orderState: 'Shipped',
  },
  {
    id: 13,
    message: 'Announced: not collected',
  },
  {
    id: 8,
    message: 'Delivery attempt failed',
  },
  {
    id: 7,
    message: 'Being sorted',
    orderState: 'Shipped',
  },
  {
    id: 5,
    message: 'Sorted',
    orderState: 'Shipped',
  },
  {
    id: 4,
    message: 'Delivery delayed',
  },
  {
    id: 3,
    message: 'En route to sorting center',
    orderState: 'Shipped',
  },
  {
    id: 1,
    message: 'Announced',
    orderState: 'Shipped',
  },
  {
    id: 1337,
    message:
      'Unknown status - check carrier track & trace page for more insights',
  },
  {
    id: 999,
    message: 'No label',
  },
  {
    id: 1001,
    message: 'Being announced',
    orderState: 'Shipped',
  },
  {
    id: 2000,
    message: 'Cancelled',
    orderState: 'Cancelled',
  },
  {
    id: 2001,
    message: 'Submitting cancellation request',
  },
  {
    id: 92,
    message: 'Driver en route',
    orderState: 'Shipped',
  },
];
export interface SendcloudPluginOptions {
  weightFn?: CustomFieldFn<number>;
  hsCodeFn?: CustomFieldFn<string>;
  originCountryFn?: CustomFieldFn<string>;
  additionalParcelItemsFn?: AdditionalParcelInputFn;
  disabled?: boolean;
}
export type AdditionalParcelInputFn = (
  ctx: RequestContext,
  injector: Injector,
  order: Order
) => Promise<ParcelInputItem[]>;
export type CustomFieldFn<T = string | number> = (line: OrderLine) => T;
```

## File: packages/vendure-plugin-sendcloud/src/api/additional-parcel-input-items.ts

```typescript
import {
  Injector,
  Order,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { ParcelInputItem } from './types/sendcloud-api.types';
export async function getNrOfOrders(
  ctx: RequestContext,
  injector: Injector,
  order: Order
): Promise<ParcelInputItem> {
  let nrOfOrders = 0;
  if (order.customer?.id) {
    const orders = await injector
      .get(TransactionalConnection)
      .getRepository(ctx, Order)
      .find({
        where: {
          customer: { id: order.customer.id },
          state: 'Delivered',
        },
      });
    nrOfOrders = orders.length;
  }
  return {
    description: String(nrOfOrders),
    quantity: 1,
    weight: '0.1',
    sku: `Nr of orders`,
    value: '0',
  };
}
export function getCouponCodes(order: Order): ParcelInputItem | undefined {
  if (!order.couponCodes || order.couponCodes.length === 0) {
    return;
  }
  const couponCodesString = order.couponCodes.join(',');
  return {
    description: couponCodesString,
    quantity: 1,
    weight: '0.1',
    sku: `Couponcodes`,
    value: '0',
  };
}
```

## File: packages/vendure-plugin-sendcloud/src/api/constants.ts

```typescript
export const loggerCtx = 'SendcloudPlugin';
export const PLUGIN_OPTIONS = Symbol('SENDCLOUD_OPTIONS');
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud-config.entity.ts

```typescript
import { DeepPartial, VendureEntity } from '@vendure/core';
import { Entity, Column } from 'typeorm';
@Entity()
export class SendcloudConfigEntity extends VendureEntity {
  constructor(input?: DeepPartial<SendcloudConfigEntity>) {
    super(input);
  }
  @Column({ unique: true })
  channelId!: string;
  @Column({ nullable: true })
  secret?: string;
  @Column({ nullable: true })
  publicKey?: string;
  @Column({ nullable: true })
  defaultPhoneNr?: string;
}
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud.adapter.ts

```typescript
import { Order, OrderLine } from '@vendure/core';
import { ParcelInput, ParcelInputItem } from './types/sendcloud-api.types';
import { SendcloudPluginOptions } from './types/sendcloud.types';
export function toParcelInput(
  order: Order,
  options: SendcloudPluginOptions,
  defaultPhoneNr?: string
): ParcelInput {
  const items = order.lines
    .filter((line) => line.quantity >= 1)
    .map((line) => toParcelInputItem(line, options));
  return {
    name: order.shippingAddress.fullName || '-',
    company_name: order.shippingAddress.company,
    address: order.shippingAddress.streetLine1!,
    house_number: order.shippingAddress.streetLine2!,
    city: order.shippingAddress.city!,
    postal_code: order.shippingAddress.postalCode!,
    country: order.shippingAddress.countryCode!.toUpperCase(),
    telephone: order.customer?.phoneNumber || defaultPhoneNr,
    request_label: false,
    email: order.customer?.emailAddress,
    order_number: order.code,
    parcel_items: items,
    weight: getTotalWeight(items),
    shipping_method_checkout_name:
      order.shippingLines?.[0].shippingMethod?.code,
  };
}
export function toParcelInputItem(
  line: OrderLine,
  options: SendcloudPluginOptions
): ParcelInputItem {
  const variant = line.productVariant;
  let weightPerUnit = options.weightFn?.(line) || 0;
  let hsCode = options.hsCodeFn?.(line);
  if (weightPerUnit < 0.001) {
    weightPerUnit = 0.001;
  }
  const parcelInput: ParcelInputItem = {
    description: variant.name,
    quantity: line.quantity,
    weight: weightPerUnit.toFixed(3),
    sku: variant.sku,
    value: (line.unitPriceWithTax / 100).toFixed(2),
  };
  const originCountry = options.originCountryFn?.(line);
  if (originCountry) {
    parcelInput.origin_country = originCountry;
  }
  if (hsCode && hsCode.length > 1) {
    parcelInput.hs_code = hsCode;
  }
  return parcelInput;
}
export function getTotalWeight(items: ParcelInputItem[]): string {
  let totalWeight = 0;
  items.forEach((item) => {
    totalWeight += parseFloat(item.weight) * item.quantity;
  });
  return totalWeight.toFixed(3);
}
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud.client.ts

```typescript
import fetch from 'node-fetch';
import { Response } from 'node-fetch';
import crypto from 'crypto';
import { Logger } from '@vendure/core';
import { loggerCtx } from './constants';
import { Parcel, ParcelInput } from './types/sendcloud-api.types';
export class SendcloudClient {
  static signatureHeader = 'sendcloud-signature';
  endpoint = 'https://panel.sendcloud.sc/api/v2';
  headers: { [key: string]: string };
  constructor(private publicKey: string, private secret: string) {
    this.headers = {
      'Content-Type': 'application/json',
      Authorization:
        'Basic ' +
        Buffer.from(`${this.publicKey}:${this.secret}`).toString('base64'),
    };
  }
  async createParcel(parcelInput: ParcelInput): Promise<Parcel> {
    const body = { parcel: parcelInput };
    const res = await this.fetch('parcels', body);
    if (!res.ok) {
      throw Error(res.statusText);
    }
    const json = (await res.json()) as any;
    Logger.info(
      `Created parcel in SendCloud with for order ${parcelInput.order_number}  with id ${json.parcel?.id}`,
      loggerCtx
    );
    return json.parcel;
  }
  isValidWebhook(body: string, signature: string): boolean {
    if (!body || !signature) {
      return false;
    }
    const hash = crypto
      .createHmac('sha256', this.secret)
      .update(body)
      .digest('hex');
    return hash === signature;
  }
  async fetch(path: string, body: any): Promise<Response> {
    const res = await fetch(`${this.endpoint}/${path}`, {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify(body),
    });
    if (!res.ok) {
      const json = (await res.json()) as any;
      throw Error(`${res.statusText}: ${json.error?.message}`);
    }
    return res;
  }
}
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud.controller.ts

```typescript
import { Body, Controller, Headers, Param, Post, Req } from '@nestjs/common';
import { Request } from 'express';
import { SendcloudService } from './sendcloud.service';
import { SendcloudClient } from './sendcloud.client';
import { Logger } from '@vendure/core';
import { loggerCtx } from './constants';
import { IncomingWebhookBody } from './types/sendcloud-api.types';
import { sendcloudStates } from './types/sendcloud.types';
import { inspect } from 'util';
@Controller('sendcloud')
export class SendcloudController {
  constructor(private sendcloudService: SendcloudService) {}
  @Post('webhook/:channelToken')
  async webhook(
    @Req() req: Request,
    @Headers(SendcloudClient.signatureHeader) signature: string,
    @Param('channelToken') channelToken: string
  ): Promise<unknown> {
    let body: IncomingWebhookBody;
    if (!Buffer.isBuffer(req.body)) {
      Logger.warn(
        `Incoming webhook body is not a Buffer. This means the body was already parsed by some other middleware. This might cause problems when validating the incoming webhook signature.`,
        loggerCtx
      );
      body = req.body as IncomingWebhookBody;
    } else {
      try {
        body = JSON.parse(req.body.toString()) as IncomingWebhookBody;
      } catch (e: any) {
        Logger.error(
          `Error parsing incoming webhook body: ${e?.message ?? e}`,
          loggerCtx,
          inspect(req.body)
        );
        return;
      }
    }
    const rawBody = (req as any).rawBody;
    const ctx = await this.sendcloudService.createContext(channelToken);
    const { client } = await this.sendcloudService.getClient(ctx);
    if (!client.isValidWebhook(rawBody, signature)) {
      Logger.warn(
        `Ignoring incoming webhook for channel ${channelToken}, because it has an invalid signature`,
        loggerCtx
      );
      return;
    }
    if (body.action !== 'parcel_status_changed') {
      return Logger.info(
        `Incoming webhook: ${body.action}. skipping...`,
        loggerCtx
      );
    }
    Logger.info(
      `Incoming Sendcloud webhook: ${body.action} - ${body.parcel?.id} - ${body.parcel?.order_number} - ${body.parcel?.status.id} (${body.parcel?.status.message})`,
      loggerCtx
    );
    const status = sendcloudStates.find(
      (s) => s.id === body.parcel?.status?.id
    );
    if (!status) {
      return Logger.warn(
        `Unknown SendCloud status "${body.parcel?.status?.message}", not handling this webhook.`,
        loggerCtx
      );
    }
    if (!status.orderState) {
      return Logger.info(
        `Ignoring incoming webhook status "${body.parcel?.status?.message}", because we don't update Vendure order status for this sendcloud status.`,
        loggerCtx
      );
    }
    if (!body.parcel?.order_number) {
      return Logger.warn(
        `No order_number in incoming Sendcloud webhook: ${JSON.stringify(
          body.parcel
        )}`,
        loggerCtx
      );
    }
    await this.sendcloudService.updateOrderStatus(
      ctx,
      status,
      body.parcel.order_number
    );
  }
}
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud.handler.ts

```typescript
import { FulfillmentHandler, LanguageCode, Logger } from '@vendure/core';
import { loggerCtx } from './constants';
export const sendcloudHandler = new FulfillmentHandler({
  code: 'sendcloud',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Send order to SendCloud',
    },
  ],
  args: {},
  createFulfillment: async (ctx, orders, orderItems, args) => {
    const orderCodes = orders.map((o) => o.code);
    Logger.info(`Fulfilled orders ${orderCodes.join(',')}`, loggerCtx);
    return {
      method: `SendCloud - ${orderCodes.join(',')} `,
    };
  },
});
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud.resolver.ts

```typescript
import { Args, Mutation, Resolver, Query } from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  Logger,
  OrderService,
  Permission,
  RequestContext,
  PermissionDefinition,
} from '@vendure/core';
import { SendcloudService } from './sendcloud.service';
import { SendcloudConfigEntity } from './sendcloud-config.entity';
export const sendcloudPermission = new PermissionDefinition({
  name: 'SetSendCloudConfig',
  description: 'Allows setting SendCloud configuration',
});
@Resolver()
export class SendcloudResolver {
  constructor(
    private service: SendcloudService,
    private orderService: OrderService
  ) {}
  @Mutation()
  @Allow(Permission.UpdateOrder)
  async sendToSendCloud(
    @Ctx() ctx: RequestContext,
    @Args('orderId') orderId: string
  ): Promise<boolean> {
    const order = await this.orderService.findOne(ctx, orderId);
    if (!order) {
      throw new Error(`No order with id ${orderId} exists`);
    }
    Logger.info(
      `Sync to Sendcloud mutation called by user ${ctx.activeUserId} for order ${orderId}`
    );
    await this.service.createOrderInSendcloud(ctx, order);
    return true;
  }
  @Query()
  @Allow(sendcloudPermission.Permission)
  async sendCloudConfig(
    @Ctx() ctx: RequestContext
  ): Promise<SendcloudConfigEntity | null> {
    return this.service.getConfig(ctx);
  }
  @Mutation()
  @Allow(sendcloudPermission.Permission)
  async updateSendCloudConfig(
    @Ctx() ctx: RequestContext,
    @Args('input')
    input: { secret: string; publicKey: string; defaultPhoneNr: string }
  ): Promise<SendcloudConfigEntity> {
    return this.service.upsertConfig(ctx, input);
  }
}
```

## File: packages/vendure-plugin-sendcloud/src/api/sendcloud.service.ts

```typescript
import {
  Inject,
  Injectable,
  OnApplicationBootstrap,
  OnModuleInit,
} from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  ChannelService,
  EntityHydrator,
  EventBus,
  HistoryService,
  ID,
  Injector,
  JobQueue,
  JobQueueService,
  Logger,
  Order,
  OrderPlacedEvent,
  OrderService,
  RequestContext,
  SerializedRequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { toParcelInput } from './sendcloud.adapter';
import { Connection } from 'typeorm';
import { loggerCtx, PLUGIN_OPTIONS } from './constants';
import { SendcloudConfigEntity } from './sendcloud-config.entity';
import { SendcloudClient } from './sendcloud.client';
import { sendcloudHandler } from './sendcloud.handler';
import {
  fulfillAll,
  transitionToDelivered,
  transitionToShipped,
} from '../../../util/src';
import { Parcel, ParcelInputItem } from './types/sendcloud-api.types';
import util from 'util';
import {
  SendcloudParcelStatus,
  SendcloudPluginOptions,
} from './types/sendcloud.types';
interface SendcloudJobData {
  orderCode: string;
  ctx: SerializedRequestContext;
}
@Injectable()
export class SendcloudService implements OnApplicationBootstrap {
  private jobQueue!: JobQueue<SendcloudJobData>;
  constructor(
    private eventBus: EventBus,
    private connection: TransactionalConnection,
    private orderService: OrderService,
    private channelService: ChannelService,
    private jobQueueService: JobQueueService,
    private moduleRef: ModuleRef,
    @Inject(PLUGIN_OPTIONS) private options: SendcloudPluginOptions,
    private entityHydrator: EntityHydrator,
    private historyService: HistoryService
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    this.eventBus.ofType(OrderPlacedEvent).subscribe(async (event) => {
      await this.jobQueue.add(
        {
          orderCode: event.order.code,
          ctx: event.ctx.serialize(),
        },
        { retries: 20 }
      );
    });
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'sendcloud',
      process: async ({ data }) => {
        const ctx = RequestContext.deserialize(data.ctx);
        try {
          await this.syncOrder(ctx, data.orderCode);
        } catch (error) {
          Logger.warn(
            `Failed to sync order ${data.orderCode} for channel ${ctx.channel.token}: ${error}`,
            loggerCtx
          );
          throw error;
        }
      },
    });
  }
  async createOrderInSendcloud(
    userCtx: RequestContext,
    order: Order
  ): Promise<Parcel | undefined> {
    if (this.options.disabled) {
      Logger.info(
        `Plugin is disabled, not syncing order ${order.code}`,
        loggerCtx
      );
      return;
    }
    const ctx = await this.createContext(userCtx.channel.token);
    try {
      await this.entityHydrator.hydrate(ctx, order, {
        relations: [
          'customer',
          'lines.productVariant.product',
          'shippingLines.shippingMethod',
        ],
      });
      const additionalParcelItems: ParcelInputItem[] = [];
      if (this.options.additionalParcelItemsFn) {
        additionalParcelItems.push(
          ...(await this.options.additionalParcelItemsFn(
            ctx,
            new Injector(this.moduleRef),
            order
          ))
        );
      }
      const { client, defaultPhoneNr } = await this.getClient(ctx);
      const parcelInput = toParcelInput(order, this.options, defaultPhoneNr);
      parcelInput.parcel_items.unshift(...additionalParcelItems);
      const parcel = await client.createParcel(parcelInput);
      await this.logHistoryEntry(ctx, order.id);
      return parcel;
    } catch (err: unknown) {
      await this.logHistoryEntry(ctx, order.id, err);
      throw err;
    }
  }
  async updateOrderStatus(
    ctx: RequestContext,
    sendcloudStatus: SendcloudParcelStatus,
    orderCode: string
  ): Promise<void> {
    let order = await this.connection
      .getRepository(ctx, Order)
      .findOne({ where: { code: orderCode }, relations: ['lines'] });
    if (!order) {
      Logger.warn(
        `Cannot update status from SendCloud: No order with code ${orderCode} found`,
        loggerCtx
      );
      throw Error(
        `Cannot update status from SendCloud: No order with code ${orderCode} found`
      );
    }
    if (order.state === sendcloudStatus.orderState) {
      return Logger.info(
        `Not updating order with code ${orderCode}: Order already has state ${order.state}`,
        loggerCtx
      );
    }
    if (sendcloudStatus.orderState === 'Shipped') {
      await this.shipAll(ctx, order);
      return Logger.info(
        `Successfully updated order ${orderCode} to Shipped`,
        loggerCtx
      );
    }
    order = await this.connection
      .getRepository(ctx, Order)
      .findOneOrFail({ where: { code: orderCode }, relations: ['lines'] });
    if (sendcloudStatus.orderState === 'Delivered') {
      await transitionToDelivered(this.orderService, ctx, order, {
        code: sendcloudHandler.code,
        arguments: [],
      });
      return Logger.info(
        `Successfully updated order ${orderCode} to Delivered`,
        loggerCtx
      );
    }
    Logger.info(`Not handling state ${sendcloudStatus.orderState}`, loggerCtx);
  }
  async shipAll(ctx: RequestContext, order: Order): Promise<void> {
    await transitionToShipped(
      this.orderService as any,
      ctx as any,
      order as any,
      {
        code: sendcloudHandler.code,
        arguments: [],
      }
    );
  }
  private async safeFulfill(ctx: RequestContext, order: Order): Promise<void> {
    try {
      const fulfillment = await fulfillAll(ctx, this.orderService, order, {
        code: sendcloudHandler.code,
        arguments: [],
      });
      Logger.info(
        `Created fulfillment (${fulfillment.id}) for order ${order.code}`,
        loggerCtx
      );
    } catch (e: any) {
      Logger.error(
        `Failed to fulfill order ${order.code}: ${e?.message}. Transition this order manually to 'Delivered' after checking that it exists in Sendcloud.`,
        loggerCtx,
        util.inspect(e)
      );
    }
  }
  async upsertConfig(
    ctx: RequestContext,
    config: {
      secret: string;
      publicKey: string;
      defaultPhoneNr: string;
    }
  ): Promise<SendcloudConfigEntity> {
    const repo = this.connection.getRepository(ctx, SendcloudConfigEntity);
    const existing = await repo.findOne({
      where: { channelId: String(ctx.channelId) },
    });
    if (existing) {
      await repo.update(existing.id, {
        secret: config.secret,
        publicKey: config.publicKey,
        defaultPhoneNr: config.defaultPhoneNr,
      });
    } else {
      await repo.insert({
        channelId: String(ctx.channelId),
        secret: config.secret,
        publicKey: config.publicKey,
        defaultPhoneNr: config.defaultPhoneNr,
      });
    }
    return repo.findOneOrFail({ where: { channelId: String(ctx.channelId) } });
  }
  async getConfig(ctx: RequestContext): Promise<SendcloudConfigEntity | null> {
    return this.connection
      .getRepository(ctx, SendcloudConfigEntity)
      .findOne({ where: { channelId: String(ctx.channelId) } });
  }
  async getClient(
    ctx: RequestContext
  ): Promise<{ client: SendcloudClient; defaultPhoneNr?: string }> {
    const config = await this.getConfig(ctx);
    if (!config || !config?.secret || !config.publicKey) {
      throw Error(`Incomplete config found for channel ${ctx.channel.token}`);
    }
    return {
      client: new SendcloudClient(config.publicKey, config.secret),
      defaultPhoneNr: config.defaultPhoneNr,
    };
  }
  async createContext(channelToken: string): Promise<RequestContext> {
    const channel = await this.channelService.getChannelFromToken(channelToken);
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      languageCode: channel.defaultLanguageCode,
      channel,
    });
  }
  private async syncOrder(
    ctx: RequestContext,
    orderCode: string
  ): Promise<void> {
    const config = await this.getConfig(ctx);
    if (!config?.secret || !config?.publicKey) {
      return;
    }
    let order = await this.orderService.findOneByCode(ctx, orderCode, [
      'shippingLines',
      'shippingLines.shippingMethod',
      'lines',
    ]);
    if (!order) {
      return Logger.error(
        `No order found with code ${orderCode}. Can not sync this order.`,
        loggerCtx
      );
    }
    const hasSendcloudHandler = order.shippingLines.find(
      (line) =>
        line.shippingMethod?.fulfillmentHandlerCode === sendcloudHandler.code
    );
    if (!hasSendcloudHandler) {
      return Logger.info(
        `Order ${order.code} does not have SendCloud set as handler. Not syncing this order.`,
        loggerCtx
      );
    }
    await this.safeFulfill(ctx, order);
    Logger.info(
      `Syncing order ${orderCode} for channel ${ctx.channel.token}`,
      loggerCtx
    );
    const result = await this.createOrderInSendcloud(ctx, order);
    if (result) {
      Logger.info(
        `Order ${order.code} synced to SendCloud: ${result.id}`,
        loggerCtx
      );
    }
  }
  async logHistoryEntry(
    ctx: RequestContext,
    orderId: ID,
    error?: unknown
  ): Promise<void> {
    let prettifiedError = error
      ? JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)))
      : undefined;
    await this.historyService.createHistoryEntryForOrder(
      {
        ctx,
        orderId,
        type: 'SENDCLOUD_NOTIFICATION' as any,
        data: {
          name: 'SendCloud',
          valid: !error,
          error: prettifiedError,
        },
      },
      false
    );
  }
}
```

## File: packages/vendure-plugin-sendcloud/src/ui/history-entry.component.ts

```typescript
import { Component } from '@angular/core';
import {
  DataService,
  NotificationService,
  OrderDetailFragment,
  OrderHistoryEntryComponent,
  TimelineDisplayType,
  TimelineHistoryEntry,
} from '@vendure/admin-ui/core';
import gql from 'graphql-tag';
@Component({
  selector: 'sendcloud-notification-component',
  template: `
    <span *ngIf="entry.data.valid"> Synced to {{ getName(entry) }} </span>
    <span *ngIf="!entry.data.valid">
      Failed to sync to {{ getName(entry) }}
    </span>
    <button (click)="mutate()" class="btn btn-link btn-sm details-button">
      <clr-icon shape="sync" size="16"></clr-icon>
    </button>
    <br />
    <vdr-history-entry-detail *ngIf="entry.data.error">
      <vdr-object-tree [value]="entry.data.error"></vdr-object-tree>
    </vdr-history-entry-detail>
  `,
})
export class HistoryEntryComponent implements OrderHistoryEntryComponent {
  entry!: TimelineHistoryEntry;
  order!: OrderDetailFragment;
  constructor(
    protected dataService: DataService,
    protected notificationService: NotificationService
  ) {}
  async mutate(): Promise<void> {
    try {
      await this.dataService
        .mutate(
          gql`
          mutation {
              sendToSendCloud(orderId: "${this.order.id}")
          }
      `
        )
        .toPromise();
      this.notificationService.success('Success');
    } catch (e) {
      this.notificationService.error('Error');
    }
  }
  getDisplayType(entry: TimelineHistoryEntry): TimelineDisplayType {
    return entry.data.valid ? 'success' : 'error';
  }
  getName(entry: TimelineHistoryEntry): string {
    return entry.data.name;
  }
  isFeatured(entry: TimelineHistoryEntry): boolean {
    return !entry.data.valid;
  }
  getIconShape(entry: TimelineHistoryEntry) {
    return entry.data.valid ? 'check-circle' : 'exclamation-circle';
  }
}
```

## File: packages/vendure-plugin-sendcloud/src/ui/queries.ts

```typescript
import gql from 'graphql-tag';
export const UPDATE_SENDCLOUD_CONFIG = gql`
  mutation updateSendCloudConfig($input: SendCloudConfigInput) {
    updateSendCloudConfig(input: $input) {
      id
      secret
      publicKey
      defaultPhoneNr
    }
  }
`;
export const GET_SENDCLOUD_CONFIG = gql`
  query sendCloudConfig {
    sendCloudConfig {
      id
      secret
      publicKey
      defaultPhoneNr
    }
  }
`;
```

## File: packages/vendure-plugin-sendcloud/src/ui/sendcloud-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import {
  addNavMenuItem,
  registerHistoryEntryComponent,
  SharedModule,
} from '@vendure/admin-ui/core';
import { HistoryEntryComponent } from './history-entry.component';
@NgModule({
  imports: [SharedModule],
  declarations: [HistoryEntryComponent],
  providers: [
    addNavMenuItem(
      {
        id: 'sendcloud',
        label: 'SendCloud',
        routerLink: ['/extensions/sendcloud'],
        icon: 'cloud',
        requiresPermission: 'SetSendCloudConfig',
      },
      'settings'
    ),
    registerHistoryEntryComponent({
      type: 'SENDCLOUD_NOTIFICATION',
      component: HistoryEntryComponent,
    }),
  ],
})
export class SendcloudNavModule {}
```

## File: packages/vendure-plugin-sendcloud/src/ui/sendcloud.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { DataService, NotificationService } from '@vendure/admin-ui/core';
import { GET_SENDCLOUD_CONFIG, UPDATE_SENDCLOUD_CONFIG } from './queries';
@Component({
  selector: 'sendcloud-component',
  template: `
    <div class="clr-row">
      <div class="clr-col">
        <form [formGroup]="form" clrForm>
          <clr-input-container>
            <label>SendCloud secret</label>
            <input
              id="secret"
              type="text"
              formControlName="secret"
              clrInput
              size="28"
            />
          </clr-input-container>
          <clr-input-container>
            <label>SendCloud public key</label>
            <input
              id="publicKey"
              type="text"
              formControlName="publicKey"
              clrInput
              size="28"
            />
          </clr-input-container>
          <clr-input-container>
            <label>Fallback phone nr.</label>
            <input
              id="defaultPhoneNr"
              type="text"
              formControlName="defaultPhoneNr"
              clrInput
              size="28"
            />
            <clr-control-helper
              >Used when a customer hasn't entered a phone number. <br />
              Phone number is required in some cases by
              Sendcloud</clr-control-helper
            >
          </clr-input-container>
          <button
            class="btn btn-primary"
            (click)="save()"
            style="margin-left: 20rem"
            [disabled]="form.invalid || form.pristine"
          >
            Save
          </button>
        </form>
      </div>
    </div>
  `,
})
export class SendcloudComponent implements OnInit {
  form: FormGroup;
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService
  ) {
    this.form = this.formBuilder.group({
      secret: ['your-secret'],
      publicKey: ['your-public-key'],
      defaultPhoneNr: ['your-phone-number'],
    });
  }
  async ngOnInit(): Promise<void> {
    await this.dataService
      .query(GET_SENDCLOUD_CONFIG)
      .mapStream((d: any) => d.sendCloudConfig)
      .subscribe((config) => {
        this.form.controls['secret'].setValue(config.secret);
        this.form.controls['publicKey'].setValue(config.publicKey);
        this.form.controls['defaultPhoneNr'].setValue(config.defaultPhoneNr);
      });
  }
  async save(): Promise<void> {
    try {
      if (this.form.dirty) {
        const formValue = this.form.value;
        await this.dataService
          .mutate(UPDATE_SENDCLOUD_CONFIG, {
            input: {
              secret: formValue.secret,
              publicKey: formValue.publicKey,
              defaultPhoneNr: formValue.defaultPhoneNr,
            },
          })
          .toPromise();
      }
      this.form.markAsPristine();
      this.changeDetector.markForCheck();
      this.notificationService.success('common.notify-update-success', {
        entity: 'SendCloud config',
      });
    } catch (e: any) {
      this.notificationService.error('common.notify-update-error', {
        entity: 'SendCloud config',
      });
    }
  }
}
```

## File: packages/vendure-plugin-sendcloud/src/ui/sendcloud.module.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
import { SendcloudComponent } from './sendcloud.component';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: SendcloudComponent,
        data: { breadcrumb: 'SendCloud' },
      },
    ]),
  ],
  providers: [],
  declarations: [SendcloudComponent],
})
export class SendcloudModule {}
```

## File: packages/vendure-plugin-sendcloud/src/index.ts

```typescript
export * from './sendcloud.plugin';
export * from './api/sendcloud.handler';
export * from './api/additional-parcel-input-items';
export * from './api/types/sendcloud.types';
export * from './api/types/sendcloud-api.types';
```

## File: packages/vendure-plugin-sendcloud/src/sendcloud.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { gql } from 'graphql-tag';
import path from 'path';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { SendcloudPluginOptions } from './api/types/sendcloud.types';
import {
  SendcloudResolver,
  sendcloudPermission,
} from './api/sendcloud.resolver';
import { SendcloudService } from './api/sendcloud.service';
import { PLUGIN_OPTIONS } from './api/constants';
import { SendcloudController } from './api/sendcloud.controller';
import { SendcloudConfigEntity } from './api/sendcloud-config.entity';
import { sendcloudHandler } from './api/sendcloud.handler';
import { rawBodyMiddleware } from '../../util/src/raw-body.middleware';
@VendurePlugin({
  adminApiExtensions: {
    schema: gql`
      extend enum HistoryEntryType {
        SENDCLOUD_NOTIFICATION
      }
      type SendCloudConfig {
        id: ID!
        secret: String
        publicKey: String
        defaultPhoneNr: String
      }
      input SendCloudConfigInput {
        secret: String
        publicKey: String
        defaultPhoneNr: String
      }
      extend type Mutation {
        sendToSendCloud(orderId: ID!): Boolean!
        updateSendCloudConfig(input: SendCloudConfigInput): SendCloudConfig!
      }
      extend type Query {
        sendCloudConfig: SendCloudConfig
      }
    `,
    resolvers: [SendcloudResolver],
  },
  providers: [
    SendcloudService,
    {
      provide: PLUGIN_OPTIONS,
      useFactory: () => SendcloudPlugin.options,
    },
  ],
  imports: [PluginCommonModule],
  controllers: [SendcloudController],
  entities: [SendcloudConfigEntity],
  configuration: (config) => {
    config.apiOptions.middleware.push({
      route: '/sendcloud/webhook*',
      handler: rawBodyMiddleware,
      beforeListen: true,
    });
    config.shippingOptions.fulfillmentHandlers.push(sendcloudHandler);
    config.authOptions.customPermissions.push(sendcloudPermission);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class SendcloudPlugin {
  private static options: SendcloudPluginOptions;
  static init(options: SendcloudPluginOptions): typeof SendcloudPlugin {
    this.options = options;
    return SendcloudPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'sendcloud',
        ngModuleFileName: 'sendcloud.module.ts',
        ngModuleName: 'SendcloudModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'sendcloud-nav.module.ts',
        ngModuleName: 'SendcloudNavModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-sendcloud/test/dev-server.ts

```typescript
import { initialData } from '../../test/src/initial-data';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  Order,
  OrderState,
  RequestContext,
  StockAllocationStrategy,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import {
  getCouponCodes,
  getNrOfOrders,
  ParcelInputItem,
  sendcloudHandler,
  SendcloudPlugin,
} from '../src';
import { addShippingMethod, updateVariants } from '../../test/src/admin-utils';
import { createSettledOrder } from '../../test/src/shop-utils';
import { updateSendCloudConfig } from './test.helpers';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import * as path from 'path';
import { GlobalFlag } from '../../test/src/generated/admin-graphql';
require('dotenv').config();
export class AllocateStockOnSettlementStrategy
  implements StockAllocationStrategy
{
  shouldAllocateStock(
    ctx: RequestContext,
    fromState: OrderState,
    toState: OrderState,
    order: Order
  ): boolean | Promise<boolean> {
    return false;
  }
}
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: true,
      shopApiPlayground: true,
    },
    plugins: [
      SendcloudPlugin.init({
        additionalParcelItemsFn: async (ctx, injector, order) => {
          const additionalInputs: ParcelInputItem[] = [];
          additionalInputs.push(await getNrOfOrders(ctx, injector, order));
          const coupons = getCouponCodes(order);
          if (coupons) {
            additionalInputs.push(coupons);
          }
          return additionalInputs;
        },
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData: {
      ...initialData,
      shippingMethods: [],
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 2,
  });
  await addShippingMethod(adminClient, sendcloudHandler.code);
  await adminClient.asSuperAdmin();
  await updateSendCloudConfig(
    adminClient,
    process.env.SECRET!,
    process.env.PUBLIC!,
    '058123456789'
  );
  await updateVariants(adminClient, [
    { id: 'T_1', trackInventory: GlobalFlag.True },
  ]);
  await new Promise((resolve) => setTimeout(resolve, 20000));
  await createSettledOrder(shopClient, 1, true, [{ id: 'T_1', quantity: 1 }]);
  console.log('created test order');
})();
```

## File: packages/vendure-plugin-sendcloud/test/sendcloud.spec.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
  TestServer,
} from '@vendure/testing';
import {
  DeepPartial,
  DefaultLogger,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { initialData } from '../../test/src/initial-data';
import {
  getNrOfOrders,
  IncomingWebhookBody,
  ParcelInput,
  ParcelInputItem,
  sendcloudHandler,
  SendcloudPlugin,
} from '../src';
import { getSendCloudConfig, updateSendCloudConfig } from './test.helpers';
import { addShippingMethod, getOrder } from '../../test/src/admin-utils';
import { createSettledOrder } from '../../test/src/shop-utils';
import nock from 'nock';
import { SendcloudClient } from '../src/api/sendcloud.client';
import { expect, describe, beforeAll, afterAll, it } from 'vitest';
import crypto from 'crypto';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
describe('SendCloud', () => {
  let shopClient: SimpleGraphQLClient;
  let adminClient: SimpleGraphQLClient;
  let server: TestServer;
  let orderCode: string | undefined;
  let orderId: string | undefined;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const devConfig = mergeConfig(testConfig, {
      apiOptions: {
        port: 3050,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        SendcloudPlugin.init({
          weightFn: (line) =>
            (line.productVariant.product?.customFields as any)?.weight || 5,
          hsCodeFn: (line) =>
            (line.productVariant.product?.customFields as any)?.hsCode ||
            'test hs',
          originCountryFn: (line) => 'NL',
          additionalParcelItemsFn: async (ctx, injector, order) => {
            const additionalInputs: ParcelInputItem[] = [
              {
                sku: 'additional',
                weight: '0.1',
                description: 'Nr of orders for this customer',
                quantity: 1,
                value: '12',
              },
            ];
            additionalInputs.push(await getNrOfOrders(ctx, injector, order));
            return additionalInputs;
          },
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    const env = createTestEnvironment(devConfig);
    shopClient = env.shopClient;
    adminClient = env.adminClient;
    server = env.server;
    await server.init({
      initialData: {
        ...initialData,
        shippingMethods: [],
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
  }, 60000);
  let authHeader: any | undefined;
  let body: { parcel: ParcelInput } | undefined;
  nock('https://panel.sendcloud.sc')
    .persist()
    .post('/api/v2/parcels', (reqBody) => {
      body = reqBody;
      return true;
    })
    .matchHeader('Authorization', (val) => {
      authHeader = val;
      return true;
    })
    .reply(200, {
      parcel: { id: 'test-id' },
    });
  it('Creates shippingmethod with Sendcloud handler', async () => {
    await addShippingMethod(adminClient, sendcloudHandler.code);
  });
  it('Fails to update SendCloud config without permission', async () => {
    await adminClient.asAnonymousUser();
    await expect(
      updateSendCloudConfig(
        adminClient,
        'test-secret',
        'test-public',
        '06123456789'
      )
    ).rejects.toThrow('authorized');
  });
  it('Updates SendCloudConfig as superadmin', async () => {
    await adminClient.asSuperAdmin();
    await updateSendCloudConfig(
      adminClient,
      'test-secret',
      'test-public',
      '06123456789'
    );
    const config = await getSendCloudConfig(adminClient);
    expect(config.secret).toBe('test-secret');
    expect(config.publicKey).toBe('test-public');
    expect(config.defaultPhoneNr).toBe('06123456789');
    expect(config.id).toBeDefined();
  });
  it('Syncs order after placement when it has Sendcloud handler', async () => {
    const { id } = await createSettledOrder(shopClient, 1);
    await new Promise((resolve) => setTimeout(resolve, 500));
    const order = await getOrder(adminClient, String(id));
    orderCode = order?.code;
    orderId = order?.id;
    expect(
      body?.parcel.parcel_items.find((i) => i.sku === 'additional')
    ).toBeDefined();
    expect(
      body?.parcel.parcel_items.find((i) => i.weight === '5.000')
    ).toBeDefined();
    expect(
      body?.parcel.parcel_items.find((i) => i.origin_country === 'NL')
    ).toBeDefined();
    expect(
      body?.parcel.parcel_items.find((i) => i.hs_code === 'test hs')
    ).toBeDefined();
    expect(
      body?.parcel.parcel_items.find((item) => item.sku === 'L2201308')?.value
    ).toBe('1558.80');
    expect(
      body?.parcel.parcel_items.find((item) => item.sku === 'L2201508')?.value
    ).toBe('1678.80');
    expect(authHeader?.[0]).toContain('Basic');
    expect(body?.parcel.shipping_method_checkout_name).toContain(
      'test-shipping-method'
    );
    expect(body?.parcel.telephone).toContain('029 1203 1336');
    expect(body?.parcel.email).toContain('hayden.zieme12@hotmail.com');
  });
  it('Updates order to Shipped via webhook', async () => {
    const body: DeepPartial<IncomingWebhookBody> = {
      action: 'parcel_status_changed',
      parcel: {
        order_number: orderCode,
        status: {
          id: 62990,
          message: 'At sorting centre',
        },
      },
    };
    const signature = crypto
      .createHmac('sha256', 'test-secret')
      .update(JSON.stringify(body))
      .digest('hex');
    await adminClient.fetch(
      'http://localhost:3050/sendcloud/webhook/e2e-default-channel',
      {
        method: 'POST',
        body: JSON.stringify(body),
        headers: { [SendcloudClient.signatureHeader]: signature },
      }
    );
    const order = await getOrder(adminClient, String(orderId));
    expect(order?.state).toBe('Shipped');
  });
  it('Updates order to Delivered via webhook', async () => {
    const body: DeepPartial<IncomingWebhookBody> = {
      action: 'parcel_status_changed',
      parcel: {
        order_number: orderCode,
        status: {
          id: 11,
          message: 'Delivered',
        },
      },
    };
    const signature = crypto
      .createHmac('sha256', 'test-secret')
      .update(JSON.stringify(body))
      .digest('hex');
    await adminClient.fetch(
      'http://localhost:3050/sendcloud/webhook/e2e-default-channel',
      {
        method: 'POST',
        body: JSON.stringify(body),
        headers: { [SendcloudClient.signatureHeader]: signature },
      }
    );
    const order = await getOrder(adminClient, String(orderId));
    expect(order?.state).toBe('Delivered');
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        SendcloudPlugin.ui
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-sendcloud/test/test.helpers.ts

```typescript
import { SimpleGraphQLClient } from '@vendure/testing';
import {
  GET_SENDCLOUD_CONFIG,
  UPDATE_SENDCLOUD_CONFIG,
} from '../src/ui/queries';
import { SendcloudConfigEntity } from '../src/api/sendcloud-config.entity';
export async function updateSendCloudConfig(
  adminClient: SimpleGraphQLClient,
  secret: string,
  publicKey: string,
  defaultPhoneNr: string
): Promise<SendcloudConfigEntity> {
  const { updateSendCloudConfig } = await adminClient.query(
    UPDATE_SENDCLOUD_CONFIG,
    {
      input: { secret, publicKey, defaultPhoneNr },
    }
  );
  return updateSendCloudConfig;
}
export async function getSendCloudConfig(
  adminClient: SimpleGraphQLClient
): Promise<SendcloudConfigEntity> {
  const { sendCloudConfig } = await adminClient.query(GET_SENDCLOUD_CONFIG);
  return sendCloudConfig;
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate-client.ts

```typescript
import { Logger } from '@vendure/core';
import axios, { AxiosInstance } from 'axios';
import { loggerCtx } from '../constants';
import {
  CreateShipmentResponse,
  DeleteShipmentResponse,
  GetTokenRespose,
  NewShipment,
  Shipment,
} from '../types';
interface ShipmateClientInput {
  apiUrl: string;
  username: string;
  password: string;
  apiKey: string;
}
export class ShipmateClient {
  client: AxiosInstance;
  private token: string | undefined;
  constructor(private input: ShipmateClientInput) {
    this.client = axios.create({
      headers: {
        'X-SHIPMATE-API-KEY': input.apiKey,
        Accept: 'application/json',
        'Content-Type': 'application/json',
      },
      baseURL: input.apiUrl,
    });
  }
  async createShipment(shipment: Shipment): Promise<NewShipment[] | undefined> {
    try {
      await this.setToken();
      const result = await this.client.post<CreateShipmentResponse>(
        `/shipments`,
        shipment
      );
      Logger.info(result.data.message, loggerCtx);
      return result.data?.data;
    } catch (error) {
      this.handleShipmateAPIError(error);
    }
  }
  async cancelShipment(shipment_reference: string): Promise<void> {
    try {
      await this.setToken();
      const result = await this.client.delete<DeleteShipmentResponse>(
        `/shipments/${shipment_reference}`
      );
      Logger.info(result.data.message, loggerCtx);
    } catch (error) {
      this.handleShipmateAPIError(error);
    }
  }
  private handleShipmateAPIError(error: any) {
    Logger.error(JSON.stringify(error.response?.data), loggerCtx);
    if (error.response?.data) {
      throw Error(JSON.stringify(error.response.data));
    }
    throw error;
  }
  async getShipmentToken(
    shipmateUsername: string,
    shipmatePassword: string
  ): Promise<string> {
    const response = await this.client.post<GetTokenRespose>(`/tokens`, {
      username: shipmateUsername,
      password: shipmatePassword,
    });
    if (!response.data.data?.token) {
      Logger.error(
        response.data.message,
        loggerCtx,
        JSON.stringify(response.data)
      );
      throw new Error(response.data.message);
    }
    return response.data.data.token;
  }
  private async setToken(): Promise<void> {
    if (!this.token) {
      this.token = await this.getShipmentToken(
        this.input.username,
        this.input.password
      );
    }
    this.client.defaults.headers.common['X-SHIPMATE-TOKEN'] = this.token;
  }
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate-config.entity.ts

```typescript
import { Column, Entity, OneToMany } from 'typeorm';
import { DeepPartial, VendureEntity } from '@vendure/core';
import { ShipmateWebhookTokenEntity } from './shipmate-webhook-token.entitiy';
@Entity()
export class ShipmateConfigEntity extends VendureEntity {
  constructor(input?: DeepPartial<ShipmateConfigEntity>) {
    super(input);
  }
  @Column({ unique: true })
  channelId!: string;
  @Column()
  apiKey!: string;
  @OneToMany(
    () => ShipmateWebhookTokenEntity,
    (shipmateConfig) => shipmateConfig.shipmateConfig
  )
  webhookAuthTokens!: ShipmateWebhookTokenEntity[];
  @Column()
  username!: string;
  @Column()
  password!: string;
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate-config.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { RequestContext, TransactionalConnection } from '@vendure/core';
import { ShipmateConfigEntity } from './shipmate-config.entity';
import { ShipmateWebhookTokenEntity } from './shipmate-webhook-token.entitiy';
@Injectable()
export class ShipmateConfigService {
  constructor(private connection: TransactionalConnection) {}
  async getConfig(ctx: RequestContext): Promise<ShipmateConfigEntity | null> {
    return this.connection
      .getRepository(ctx, ShipmateConfigEntity)
      .createQueryBuilder('config')
      .innerJoinAndSelect('config.webhookAuthTokens', 'webhookAuthToken')
      .setFindOptions({ where: { channelId: ctx.channelId as string } })
      .getOne();
  }
  async getConfigWithWebhookAuthToken(
    webhookAuthToken: string
  ): Promise<ShipmateConfigEntity | null> {
    return this.connection
      .getRepository(ShipmateConfigEntity)
      .createQueryBuilder('config')
      .innerJoin('config.webhookAuthTokens', 'webhookAuthToken')
      .where('webhookAuthToken.token = :token', {
        token: `${webhookAuthToken}`,
      })
      .getOne();
  }
  async upsertConfig(
    ctx: RequestContext,
    apiKey?: string,
    username?: string,
    password?: string,
    webhookAuthTokens?: string[]
  ): Promise<ShipmateConfigEntity | null> {
    const shipmateConfigRepo = this.connection.getRepository(
      ctx,
      ShipmateConfigEntity
    );
    const existing = await shipmateConfigRepo
      .createQueryBuilder('config')
      .innerJoinAndSelect('config.webhookAuthTokens', 'webhookAuthToken')
      .setFindOptions({ where: { channelId: ctx.channelId as string } })
      .getOne();
    if (
      (!apiKey || apiKey === '') &&
      (!username || username === '') &&
      (!password || password === '') &&
      !webhookAuthTokens?.length &&
      existing
    ) {
      await shipmateConfigRepo.delete(existing.id);
    } else if (existing) {
      existing.apiKey = apiKey!;
      existing.username = username!;
      existing.password = password!;
      existing.webhookAuthTokens = await this.getShipmateWebhookTokenEntities(
        ctx,
        existing,
        webhookAuthTokens ?? []
      );
      await shipmateConfigRepo.save(existing);
    } else {
      const newShipmateConfig = await shipmateConfigRepo.save({
        apiKey,
        channelId: ctx.channelId as string,
        username,
        password,
        webhookAuthTokens: [],
      });
      newShipmateConfig.webhookAuthTokens =
        (await this.getShipmateWebhookTokenEntities(
          ctx,
          newShipmateConfig,
          webhookAuthTokens ?? []
        )) as never[];
      await shipmateConfigRepo.save(newShipmateConfig);
    }
    return this.connection.getRepository(ctx, ShipmateConfigEntity).findOne({
      where: { channelId: ctx.channelId as string },
      relations: ['webhookAuthTokens'],
    });
  }
  private async getShipmateWebhookTokenEntities(
    ctx: RequestContext,
    shipmateConfig: ShipmateConfigEntity,
    tokens: string[]
  ): Promise<ShipmateWebhookTokenEntity[]> {
    const webhooksRepo = this.connection.getRepository(
      ctx,
      ShipmateWebhookTokenEntity
    );
    const existingAndKept = shipmateConfig.webhookAuthTokens.filter(
      (webhookToken) => !!tokens.find((token) => token === webhookToken.token)
    );
    const existingButNotKept = shipmateConfig.webhookAuthTokens.filter(
      (webhookToken) => !tokens.find((token) => token === webhookToken.token)
    );
    for (const webhookAuthTokenEntity of existingButNotKept) {
      await webhooksRepo.delete(webhookAuthTokenEntity);
    }
    const newWebhooksTokens = tokens.filter(
      (token) =>
        !shipmateConfig.webhookAuthTokens.find(
          (webhookAuthToken) => webhookAuthToken.token === token
        )
    );
    const newShipmateWebhooksTokens: ShipmateWebhookTokenEntity[] = [];
    for (const token of newWebhooksTokens) {
      const webhooksToken = new ShipmateWebhookTokenEntity();
      webhooksToken.shipmateConfig = shipmateConfig;
      webhooksToken.token = token;
      newShipmateWebhooksTokens.push(await webhooksRepo.save(webhooksToken));
    }
    return [...existingAndKept, ...newShipmateWebhooksTokens];
  }
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate-webhook-token.entitiy.ts

```typescript
import { Column, ManyToOne, Entity } from 'typeorm';
import { DeepPartial, VendureEntity } from '@vendure/core';
import { ShipmateConfigEntity } from './shipmate-config.entity';
@Entity()
export class ShipmateWebhookTokenEntity extends VendureEntity {
  constructor(input?: DeepPartial<ShipmateWebhookTokenEntity>) {
    super(input);
  }
  @Column({ unique: true })
  token!: string;
  @ManyToOne(
    () => ShipmateConfigEntity,
    (shipmateConfig) => shipmateConfig.webhookAuthTokens
  )
  shipmateConfig!: ShipmateConfigEntity;
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate.admin.graphql.ts

```typescript
import gql from 'graphql-tag';
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { ShipmateConfigService } from './shipmate-config.service';
import {
  PermissionDefinition,
  Allow,
  Ctx,
  RequestContext,
} from '@vendure/core';
import { ShipmateConfigEntity } from './shipmate-config.entity';
export const shipmatePermission = new PermissionDefinition({
  name: 'SetShipmateConfig',
  description: 'Allows setting Shipmate configurations',
});
export const adminSchema = gql`
  input ShipmateConfigInput {
    apiKey: String
    username: String
    password: String
    webhookAuthTokens: [String!]
  }
  type ShipmateWebhookToken {
    token: String
    shipmateConfig: ShipmateConfig
  }
  type ShipmateConfig {
    apiKey: String
    username: String
    password: String
    webhookAuthTokens: [ShipmateWebhookToken!]
  }
  extend type Mutation {
    updateShipmateConfig(input: ShipmateConfigInput!): ShipmateConfig
  }
  extend type Query {
    shipmateConfig: ShipmateConfig
  }
`;
@Resolver()
export class ShipmateAdminResolver {
  constructor(private service: ShipmateConfigService) {}
  @Query()
  @Allow(shipmatePermission.Permission)
  async shipmateConfig(
    @Ctx() ctx: RequestContext
  ): Promise<ShipmateConfigEntity | null> {
    return this.service.getConfig(ctx);
  }
  @Mutation()
  @Allow(shipmatePermission.Permission)
  async updateShipmateConfig(
    @Ctx() ctx: RequestContext,
    @Args('input')
    input: {
      apiKey?: string;
      username?: string;
      password?: string;
      webhookAuthTokens?: string[];
    }
  ): Promise<ShipmateConfigEntity | null> {
    return this.service.upsertConfig(
      ctx,
      input.apiKey,
      input.username,
      input.password,
      input.webhookAuthTokens
    );
  }
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate.controller.ts

```typescript
import { Controller, Post, Body } from '@nestjs/common';
import { EventPayload } from '../types';
import { ShipmateService } from './shipmate.service';
import { RequestContext, Ctx, Logger } from '@vendure/core';
import { asError } from 'catch-unknown';
@Controller('shipmate')
export class ShipmateController {
  constructor(private shipmentService: ShipmateService) {}
  @Post()
  async event(@Ctx() ctx: RequestContext, @Body() payload: EventPayload) {
    try {
      await this.shipmentService.updateOrderState(payload);
    } catch (e) {
      Logger.error(
        `Shipmate Order state update failed with the message: ${
          asError(e).message
        }`
      );
    }
  }
}
```

## File: packages/vendure-plugin-shipmate/src/api/shipmate.service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { FulfillOrderInput } from '@vendure/common/lib/generated-types';
import {
  Channel,
  EntityHydrator,
  EventBus,
  FulfillmentState,
  ID,
  JobQueue,
  JobQueueService,
  Logger,
  Order,
  OrderPlacedEvent,
  OrderService,
  OrderStateTransitionEvent,
  RequestContext,
  SerializedRequestContext,
  TransactionalConnection,
  isGraphQlErrorResult,
  manualFulfillmentHandler,
} from '@vendure/core';
import util from 'util';
import { PLUGIN_INIT_OPTIONS, loggerCtx } from '../constants';
import { ShipmatePluginConfig } from '../shipmate.plugin';
import { EventPayload, TrackingEventPayload } from '../types';
import { ShipmateClient } from './shipmate-client';
import { ShipmateConfigService } from './shipmate-config.service';
import { parseOrder } from './util';
interface JobData {
  ctx: SerializedRequestContext;
  orderCode: string;
  cancelExistingFirst: boolean;
}
@Injectable()
export class ShipmateService implements OnApplicationBootstrap {
  jobQueue!: JobQueue<JobData>;
  constructor(
    @Inject(PLUGIN_INIT_OPTIONS) private config: ShipmatePluginConfig,
    private shipmateConfigService: ShipmateConfigService,
    private orderService: OrderService,
    private eventBus: EventBus,
    private connection: TransactionalConnection,
    private entityHydrator: EntityHydrator,
    private jobQueueService: JobQueueService
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'shipmate',
      process: async (job) => {
        const ctx = RequestContext.deserialize(job.data.ctx);
        await this.upsertShipment(
          ctx,
          job.data.orderCode,
          job.data.cancelExistingFirst
        );
      },
    });
    this.eventBus.ofType(OrderPlacedEvent).subscribe((event) => {
      this.addJob(event).catch((e) => {
        Logger.error(
          `Error adding job to queue: ${e?.message}`,
          loggerCtx,
          util.inspect(e)
        );
      });
    });
    this.eventBus.ofType(OrderStateTransitionEvent).subscribe((event) => {
      this.addJob(event).catch((e) => {
        Logger.error(
          `Error adding job to queue: ${e?.message}`,
          loggerCtx,
          util.inspect(e)
        );
      });
    });
  }
  async addJob(
    event: OrderStateTransitionEvent | OrderPlacedEvent
  ): Promise<void> {
    await this.entityHydrator.hydrate(event.ctx, event.order, {
      relations: [
        'shippingLines.shippingMethod',
        'customer',
        'lines.productVariant',
      ],
    });
    if (!this.config.shouldSendOrder(event.ctx, event.order)) {
      Logger.info(`Order ${event.order.code} not sent to shipmate`);
      return;
    }
    const { ctx, order, fromState, toState } = event;
    if (event instanceof OrderPlacedEvent) {
      await this.jobQueue.add(
        {
          ctx: ctx.serialize(),
          orderCode: order.code,
          cancelExistingFirst: false,
        },
        { retries: 10 }
      );
      return;
    }
    if (
      toState === 'Shipped' ||
      toState === 'Delivered' ||
      toState === 'Cancelled'
    ) {
      return;
    }
    if (fromState === 'Modifying') {
      await this.jobQueue.add(
        {
          ctx: ctx.serialize(),
          orderCode: order.code,
          cancelExistingFirst: true,
        },
        { retries: 10 }
      );
    }
  }
  async upsertShipment(
    ctx: RequestContext,
    orderCode: string,
    cancelExistingFirst: boolean
  ): Promise<void> {
    const client = await this.getClient(ctx);
    if (!client) {
      Logger.info(
        `Can not create shipment for '${ctx.channel.code}'. Shipmate is not enabled`,
        loggerCtx
      );
      return;
    }
    const order = await this.orderService.findOneByCode(ctx, orderCode);
    if (!order) {
      throw Error(`[${loggerCtx}] Order with code ${orderCode} not found`);
    }
    if (cancelExistingFirst) {
      try {
        await client.cancelShipment(order.code);
        Logger.info(
          `Cancelled shipment for order '${order.code}', because we will create a new update shipment.`,
          loggerCtx
        );
      } catch (err: any) {
        Logger.warn(
          `Failed to cancel Shipment for order '${order.code}' on Shipmate: ${err?.message}`,
          loggerCtx
        );
        throw err;
      }
    }
    try {
      await this.entityHydrator.hydrate(ctx, order, { relations: ['lines'] });
      for (const line of order.lines) {
        await this.entityHydrator.hydrate(ctx, line, {
          relations: ['productVariant.product'],
        });
      }
      const payload = parseOrder(order, order.code);
      await client.createShipment(payload);
      Logger.info(`Created shipment for order '${order.code}'`, loggerCtx);
    } catch (err: any) {
      await this.logErrorAndAddNote(
        ctx,
        order.id,
        `Failed to send order '${order.code}' to Shipmate: ${err?.message}`,
        err
      );
      throw err;
    }
  }
  async logErrorAndAddNote(
    ctx: RequestContext,
    orderId: ID,
    message: string,
    err: unknown
  ): Promise<void> {
    await this.orderService
      .addNoteToOrder(ctx, {
        id: orderId,
        isPublic: false,
        note: message,
      })
      .catch((err) =>
        Logger.error(
          `Error adding note to order ${orderId}: ${err?.message}`,
          loggerCtx
        )
      );
    Logger.error(message, loggerCtx, util.inspect(err));
  }
  async updateOrderState(payload: EventPayload): Promise<void> {
    const ctx = await this.createCtxForWebhookToken(payload.auth_token);
    if (!ctx) {
      Logger.warn(
        `No Shipmate config found with webhook auth token '${payload.auth_token}'`,
        loggerCtx
      );
      return;
    }
    const order = await this.orderService.findOneByCode(
      ctx,
      payload.order_reference
    );
    if (!order) {
      Logger.warn(
        `No Order with code ${payload.order_reference} in channel ${ctx.channel.code}`,
        loggerCtx
      );
      return;
    }
    Logger.info(
      `${payload.event} event received for Order with code ${payload.order_reference} in channel ${ctx.channel.code}`,
      loggerCtx
    );
    if (payload.event === 'TRACKING_COLLECTED') {
      await this.updateFulFillment(ctx, order, payload, 'Shipped');
      Logger.info(`Order successfully marked as  Shipped`, loggerCtx);
      return;
    } else if (payload.event === 'TRACKING_DELIVERED') {
      await this.updateFulFillment(ctx, order, payload, 'Delivered');
      Logger.info(`Order successfully marked as Delivered`, loggerCtx);
      return;
    }
    Logger.info(
      `No configured handler for event "${payload.event}"`,
      loggerCtx
    );
  }
  async updateFulFillment(
    ctx: RequestContext,
    order: Order,
    payload: EventPayload,
    state: FulfillmentState
  ) {
    await this.entityHydrator.hydrate(ctx, order, {
      relations: ['fulfillments'],
    });
    if (!order.fulfillments?.length) {
      const fulfillmentInputs = this.createFulfillOrderInput(order, payload);
      const createdFulfillmentResult =
        await this.orderService.createFulfillment(ctx, fulfillmentInputs);
      if (isGraphQlErrorResult(createdFulfillmentResult)) {
        await this.logErrorAndAddNote(
          ctx,
          order.id,
          `Unable to create Fulfillment for order ${order.code}: ${createdFulfillmentResult.message}`,
          createdFulfillmentResult
        );
        throw createdFulfillmentResult.message;
      }
      if (createdFulfillmentResult.state !== state) {
        const transitionResult =
          await this.orderService.transitionFulfillmentToState(
            ctx,
            createdFulfillmentResult.id,
            state
          );
        if (isGraphQlErrorResult(transitionResult)) {
          await this.logErrorAndAddNote(
            ctx,
            order.id,
            `Unable to transition Fulfillment ${createdFulfillmentResult.id} of order ${order.code} to ${state}: ${transitionResult.transitionError}`,
            createdFulfillmentResult
          );
          throw transitionResult.transitionError;
        }
      }
    }
    for (const fulfillment of order.fulfillments) {
      if (fulfillment.state !== state) {
        const transitionResult =
          await this.orderService.transitionFulfillmentToState(
            ctx,
            fulfillment.id,
            state
          );
        if (isGraphQlErrorResult(transitionResult)) {
          await this.logErrorAndAddNote(
            ctx,
            order.id,
            `Unable to transition Fulfillment ${fulfillment.id} of order ${order.code} to ${state}: ${transitionResult.transitionError}`,
            transitionResult
          );
          throw transitionResult.transitionError;
        }
      }
    }
  }
  createFulfillOrderInput(
    order: Order,
    payload: EventPayload
  ): FulfillOrderInput {
    return {
      handler: {
        arguments: [
          { name: 'method', value: manualFulfillmentHandler.code },
          {
            name: 'trackingCode',
            value: (payload as TrackingEventPayload).tracking_number,
          },
        ],
        code: manualFulfillmentHandler.code,
      },
      lines: order.lines.map((line) => {
        return {
          orderLineId: line.id,
          quantity: line.quantity,
        };
      }),
    };
  }
  async getClient(ctx: RequestContext): Promise<ShipmateClient | undefined> {
    const shipmateConfig = await this.shipmateConfigService.getConfig(ctx);
    if (!shipmateConfig) {
      Logger.info(
        `Shipmate credentials not configured for channel ${ctx.channel.code}`,
        loggerCtx
      );
      return;
    }
    return new ShipmateClient({
      apiKey: shipmateConfig.apiKey,
      username: shipmateConfig.username,
      password: shipmateConfig.password,
      apiUrl: this.config.apiUrl,
    });
  }
  private async createCtxForWebhookToken(
    webhookAuthToken: string
  ): Promise<RequestContext | undefined> {
    const config =
      await this.shipmateConfigService.getConfigWithWebhookAuthToken(
        webhookAuthToken
      );
    if (!config) {
      Logger.error(`No channel with this webhooks auth token`, loggerCtx);
      return;
    }
    const channel = (await this.connection.getRepository(Channel).findOne({
      where: { id: config.channelId },
      relations: ['defaultTaxZone', 'defaultShippingZone'],
    })) as Channel;
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel,
    });
  }
}
```

## File: packages/vendure-plugin-shipmate/src/api/util.ts

```typescript
import type { Order, Customer, OrderLine } from '@vendure/core';
import type { Shipment, ShipmateAddress, Parcels, Items } from '../types';
import type { OrderAddress } from '@vendure/common/lib/generated-types';
export function parseOrder(order: Order, shipmateReference?: string): Shipment {
  return {
    shipment_reference: shipmateReference || order.code,
    order_reference: order.code,
    to_address: parseAddress(order.shippingAddress, order.customer),
    parcels: [parseParcels(order)],
    delivery_instructions: '',
    print_labels: false,
  };
}
export function parseAddress(
  address: OrderAddress,
  customer?: Customer
): ShipmateAddress {
  return {
    name: getRecepientName(
      address.fullName,
      customer?.firstName,
      customer?.lastName
    ),
    company_name: address.company?.substring(0, 40) ?? '',
    telephone: customer?.phoneNumber?.substring(0, 40) ?? '',
    email_address: customer?.emailAddress?.substring(0, 40) ?? '',
    line_1: address?.streetLine1?.substring(0, 40) ?? '',
    line_2: address?.streetLine2?.substring(0, 40) ?? '',
    line_3: '',
    city: address?.city?.substring(0, 40) ?? '',
    county: address.province?.substring(0, 40) ?? '',
    postcode: address.postalCode?.substring(0, 40) ?? '',
    country: address.countryCode?.substring(0, 40) ?? '',
  };
}
export function parseParcels(order: Order): Parcels {
  return {
    reference: Math.random().toString(36).substring(2, 8),
    value: `${order.totalWithTax / 100}`,
    items: order.lines.map((line) => parseOrderLine(line)),
    weight: 30,
    width: 20,
    length: 10,
    depth: 10,
  };
}
export function parseOrderLine(line: OrderLine): Items {
  return {
    item_quantity: line.quantity,
    item_value: line.proratedUnitPriceWithTax / 100,
    full_description: line.productVariant?.product?.description?.substring(
      0,
      40
    ),
    short_description: line.productVariant?.name?.substring(0, 40),
  };
}
export function getRecepientName(
  fullName?: string,
  customerFirstName?: string,
  customerLastName?: string
) {
  if (fullName) {
    return fullName.substring(0, 40);
  }
  if (customerFirstName && customerLastName) {
    return `${customerFirstName} ${customerLastName}`.substring(0, 40);
  }
  return '';
}
```

## File: packages/vendure-plugin-shipmate/src/ui/providers.ts

```typescript
import { addNavMenuItem } from '@vendure/admin-ui/core';
export default [
  addNavMenuItem(
    {
      id: 'shipmate-config',
      label: 'Shipmate',
      routerLink: ['/extensions/shipmate-config'],
      requiresPermission: 'SetShipmateConfig',
      icon: 'star',
    },
    'settings'
  ),
];
```

## File: packages/vendure-plugin-shipmate/src/ui/queries.ts

```typescript
import gql from 'graphql-tag';
export const updateShipmateConfig = gql`
  mutation updateShipmateConfig($input: ShipmateConfigInput!) {
    updateShipmateConfig(input: $input) {
      apiKey
      username
      password
      webhookAuthTokens {
        token
      }
    }
  }
`;
export const getShipmateConfig = gql`
  query getShipmateConfig {
    shipmateConfig {
      apiKey
      username
      password
      webhookAuthTokens {
        token
      }
    }
  }
`;
```

## File: packages/vendure-plugin-shipmate/src/ui/routes.ts

```typescript
import { registerRouteComponent } from '@vendure/admin-ui/core';
import { ShipmateComponent } from './shipmate.component';
export default [
  registerRouteComponent({
    path: '',
    component: ShipmateComponent,
    breadcrumb: 'Shipmate',
  }),
];
```

## File: packages/vendure-plugin-shipmate/src/ui/shipmate.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, FormControl } from '@angular/forms';
import {
  DataService,
  NotificationService,
  SharedModule,
} from '@vendure/admin-ui/core';
import { getShipmateConfig, updateShipmateConfig } from './queries';
import { firstValueFrom } from 'rxjs';
@Component({
  selector: 'shipmate-component',
  template: `
    <div class="clr-row">
      <div class="clr-col">
        <form class="form" [formGroup]="form" *ngIf="dataHasLoaded">
          <section class="form-block">
            <vdr-form-field label="Shipmate apikey" for="apiKey">
              <input id="apiKey" type="text" formControlName="apiKey" />
            </vdr-form-field>
            <vdr-form-field label="Shipmate username" for="username">
              <input id="username" type="text" formControlName="username" />
            </vdr-form-field>
            <vdr-form-field label="Shipmate password" for="password">
              <input type="password" [formControl]="form.get('password')" />
            </vdr-form-field>
            <vdr-form-field label="Webhook auth tokens" for="webhookAuthToken">
              <table class="facet-values-list table">
                <thead>
                  <tr>
                    <th>Token</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody formArrayName="webhookAuthTokens">
                  <ng-container
                    *ngFor="
                      let item of form.get('webhookAuthTokens')?.controls;
                      let i = index
                    "
                  >
                    <tr class="facet-value">
                      <td>
                        <input type="password" [formControlName]="i" />
                      </td>
                      <td class="align-middle">
                        <vdr-dropdown>
                          <button
                            type="button"
                            class="icon-button"
                            vdrDropdownTrigger
                          >
                            <clr-icon shape="ellipsis-vertical"></clr-icon>
                          </button>
                          <vdr-dropdown-menu vdrPosition="bottom-right">
                            <button
                              type="button"
                              class="delete-button"
                              (click)="deleteAuthToken(i)"
                              vdrDropdownItem
                            >
                              <clr-icon
                                shape="trash"
                                class="is-danger"
                              ></clr-icon>
                              {{ 'common.delete' | translate }}
                            </button>
                          </vdr-dropdown-menu>
                        </vdr-dropdown>
                      </td>
                    </tr>
                  </ng-container>
                </tbody>
                <div>
                  <button
                    type="button"
                    class="button m-3"
                    (click)="addAuthToken()"
                  >
                    <clr-icon shape="add"></clr-icon>
                    Add Token
                  </button>
                </div>
              </table>
            </vdr-form-field>
            <button class="btn btn-primary" (click)="save()">Save</button>
          </section>
        </form>
      </div>
    </div>
  `,
  standalone: true,
  imports: [SharedModule],
})
export class ShipmateComponent implements OnInit {
  form: FormGroup;
  dataHasLoaded: boolean = false;
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService
  ) {
    this.form = this.formBuilder.group({
      apiKey: ['your-api-key'],
      username: [''],
      password: [''],
      webhookAuthTokens: new FormArray([]),
    });
  }
  ngOnInit(): void {
    this.dataService
      .query(getShipmateConfig)
      .refetchOnChannelChange()
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
      .mapStream((d: any) => d.shipmateConfig)
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      .subscribe((config) => {
        if (config) {
          this.updateFormControl(config);
        }
        this.dataHasLoaded = true;
        this.changeDetector.markForCheck();
      });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  updateFormControl(config: any) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    this.form.controls['apiKey'].setValue(config.apiKey);
    this.form.controls['username'].setValue(config.username);
    this.form.controls['password'].setValue(config.password);
    for (const authTokenIndex in config.webhookAuthTokens ?? []) {
      const authToken = config.webhookAuthTokens[authTokenIndex].token;
      (this.form.controls['webhookAuthTokens'] as FormArray).setControl(
        parseInt(authTokenIndex),
        new FormControl(authToken)
      );
    }
    if (!config.webhookAuthTokens?.length) {
      (this.form.controls['webhookAuthTokens'] as FormArray).setControl(
        0,
        new FormControl('')
      );
    }
  }
  addAuthToken() {
    const webhookAuthTokensFormArray = this.form.controls[
      'webhookAuthTokens'
    ] as FormArray;
    webhookAuthTokensFormArray.setControl(
      webhookAuthTokensFormArray.length,
      new FormControl('')
    );
    this.changeDetector.markForCheck();
  }
  deleteAuthToken(index: number) {
    const webhookAuthTokensFormArray = this.form.controls[
      'webhookAuthTokens'
    ] as FormArray;
    webhookAuthTokensFormArray.removeAt(index);
  }
  async save(): Promise<void> {
    try {
      const formValue = this.form.value;
      await firstValueFrom(
        this.dataService.mutate(updateShipmateConfig, {
          input: {
            apiKey: formValue.apiKey,
            username: formValue.username,
            password: formValue.password,
            webhookAuthTokens: formValue.webhookAuthTokens,
          },
        })
      );
      this.form.markAsPristine();
      this.changeDetector.markForCheck();
      this.notificationService.success('common.notify-update-success', {
        entity: 'ShipmateConfig',
      });
    } catch (e) {
      this.notificationService.error('common.notify-update-error', {
        entity: 'ShipmateConfig',
      });
    }
  }
}
```

## File: packages/vendure-plugin-shipmate/src/constants.ts

```typescript
export const loggerCtx = 'VendureShipmatePlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('SHIPMATE_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-shipmate/src/index.ts

```typescript
export * from './shipmate.plugin';
export * from './api/shipmate-client';
export * from './api/shipmate-config.entity';
export * from './api/shipmate-config.service';
export * from './api/shipmate-webhook-token.entitiy';
export * from './api/shipmate-config.service';
```

## File: packages/vendure-plugin-shipmate/src/shipmate.plugin.ts

```typescript
import {
  Order,
  PluginCommonModule,
  RequestContext,
  VendurePlugin,
} from '@vendure/core';
import { ShipmateService } from './api/shipmate.service';
import { HttpModule } from '@nestjs/axios';
import { ShipmateConfigEntity } from './api/shipmate-config.entity';
import { ShipmateConfigService } from './api/shipmate-config.service';
import {
  ShipmateAdminResolver,
  adminSchema,
  shipmatePermission,
} from './api/shipmate.admin.graphql';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { ShipmateController } from './api/shipmate.controller';
import { ShipmateWebhookTokenEntity } from './api/shipmate-webhook-token.entitiy';
export interface ShipmatePluginConfig {
  apiUrl:
    | 'https://api.shipmate.co.uk/v1.2'
    | 'https://api-staging.shipmate.co.uk/v1.2';
  shouldSendOrder(
    ctx: RequestContext,
    order: Order
  ): Promise<boolean> | boolean;
}
@VendurePlugin({
  imports: [PluginCommonModule, HttpModule],
  controllers: [ShipmateController],
  providers: [
    ShipmateService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => ShipmatePlugin.config,
    },
    ShipmateConfigService,
  ],
  entities: [ShipmateConfigEntity, ShipmateWebhookTokenEntity],
  configuration: (config) => {
    config.authOptions.customPermissions.push(shipmatePermission);
    return config;
  },
  adminApiExtensions: {
    schema: adminSchema,
    resolvers: [ShipmateAdminResolver],
  },
  compatibility: '>=2.2.0',
})
export class ShipmatePlugin {
  static config: ShipmatePluginConfig;
  static init(config: ShipmatePluginConfig): typeof ShipmatePlugin {
    this.config = config;
    return ShipmatePlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    routes: [{ filePath: 'routes.ts', route: 'shipmate-config' }],
    providers: ['providers.ts'],
  };
}
```

## File: packages/vendure-plugin-shipmate/src/types.ts

```typescript
import { CurrencyCode } from '@vendure/core';
type JSONLike = {
  [key in string]: string;
};
export interface ShipmateUser {
  id: string;
  user_type: string;
  first_name: string;
  last_name: string;
  email: string;
  account_name: string;
  merchant_id: string;
}
export interface GetResponseTokenBody {
  username: string;
  password: string;
}
export interface GetTokenReponseData {
  token: string;
  user: ShipmateUser;
}
export interface GetTokenRespose {
  message: string;
  data: GetTokenReponseData;
}
export interface ValidationRules {
  is_required: boolean;
  min_length: number;
  max_length: number;
  regex: string;
  options: string;
  numeric_type: 'INT' | 'DECIMAL';
  min_value: number;
  max_value: number;
}
export interface ShipmateCustomFields {
  name: string;
  key: string;
  entity: 'SHIPMENT' | 'PARCEL' | 'CONTACT' | 'SKU';
  data_type: 'NUMERIC' | 'TEXT' | 'BOOLEAN' | 'LIST';
  source: 'DIRECT' | 'FIXED' | 'MAPPED';
  mapped_to: string;
  default_value: string;
  data_validation_rules: ValidationRules;
}
export interface ShipmateAddress {
  name: string;
  company_name: string;
  telephone: string;
  email_address: string;
  line_1: string;
  line_2: string;
  line_3: string;
  city: string;
  county: string;
  postcode: string;
  country: string;
}
export interface Items {
  item_line_id?: string;
  sku?: string;
  short_description?: string;
  full_description?: string;
  country_of_origin?: string;
  harmonised_code?: string;
  item_weight?: number;
  item_value?: number;
  item_quantity?: number;
}
export interface ExportPurpose {
  gift: boolean;
  documents: boolean;
  sale_of_goods: boolean;
  commercial_sample: boolean;
  returned_goods: boolean;
  other: string;
}
export interface CustomsDeclarations {
  duty_method?: 'DAP' | 'DDP';
  commercial_invoice_number?: string;
  insurance_value?: number;
  freight_value?: number;
  packing_value?: number;
  handling_value?: number;
  other_value?: number;
  currency_code?: CurrencyCode;
  export_license_number?: string;
  export_certificate_number?: string;
  other_export_comments?: string;
  export_purpose: ExportPurpose;
}
export interface Parcels {
  reference: string;
  packaging_type_key?: string;
  weight: number;
  width: number;
  length: number;
  depth: number;
  value: string;
  items: Items[];
  customs_declaration?: CustomsDeclarations;
  custom_fields?: JSONLike;
}
export interface Shipment {
  shipment_reference: string;
  order_reference: string;
  delivery_service_key?: string;
  location_code?: string;
  despatch_date?: string;
  to_address: ShipmateAddress;
  parcels: Parcels[];
  delivery_instructions: string;
  custom_fields?: JSONLike;
  customs_declaration?: CustomsDeclarations;
  recipient_vat_number?: string;
  recipient_eori_number?: string;
  format?: string;
  print_labels: boolean;
  print_to_user?: string;
}
export interface CreateShipmentResponse {
  message: string;
  data: NewShipment[];
}
export interface DeleteShipmentResponse {
  message: string;
  data: null;
}
export interface NewShipmentAddress {
  delivery_name: string;
  line_1: string;
  line_2: string;
  line_3: string;
  city: string;
  county: string;
  postcode: string;
  country: string;
}
export interface NewShipment {
  shipment_reference: string;
  parcel_reference: string;
  carrier: string;
  service_name: string;
  tracking_reference: string;
  created_by: string;
  created_with: string;
  created_at: string;
  price: string;
  estimated_delivery_date: string;
  to_address: NewShipmentAddress;
  pdf: string;
  zpl: string;
  png: string;
}
export interface EventPayload {
  auth_token: string;
  request_token: string;
  event:
    | 'SHIPMENT_CREATED'
    | 'SHIPMENT_CANCELLED'
    | 'TRACKING_UPDATED'
    | 'TRACKING_COLLECTED'
    | 'TRACKING_IN_TRANSIT'
    | 'TRACKING_OUT_FOR_DELIVERY'
    | 'TRACKING_DELIVERED'
    | 'TRACKING_DELIVERY_FAILED';
  shipment_reference: string;
  source: string;
  order_reference: string;
  carrier: string;
  carrier_account: string;
}
export interface TrackingEventPayload extends EventPayload {
  parcel_reference: string;
  tracking_number: string;
  tracking_event_code: string;
  tracking_event_type: string;
  tracking_event_name: string;
  tracking_event_description: string;
  tracking_event_time: string;
  tracking_url: string;
  tracking_url_carrier: string;
}
export interface ShipmentEventPayload extends EventPayload {
  parcel_references: string;
  tracking_numbers: string;
}
export interface LabelEventPayload extends EventPayload {
  parcel_references: string;
  tracking_numbers: string;
  labels: string;
}
```

## File: packages/vendure-plugin-shipmate/test/dev-server.ts

```typescript
require('dotenv').config();
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  ChannelService,
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
  Order,
  RequestContext,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { ShipmatePlugin } from '../src/shipmate.plugin';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler/';
import path from 'node:path';
import { ShipmateConfigService } from '../src/api/shipmate-config.service';
import { createSettledOrder } from '../../test/src/shop-utils';
(async () => {
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      ShipmatePlugin.init({
        apiUrl: process.env.SHIPMATE_BASE_URL as any,
        shouldSendOrder: function (
          ctx: RequestContext,
          order: Order
        ): Promise<boolean> | boolean {
          return true;
        },
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
    apiOptions: {
      shopApiPlayground: true,
      adminApiPlayground: true,
    },
    authOptions: {
      tokenMethod: 'bearer',
    },
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...initialData,
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
    customerCount: 5,
  });
  const channel = await server.app.get(ChannelService).getDefaultChannel();
  const ctx = new RequestContext({
    apiType: 'admin',
    isAuthorized: true,
    authorizedAsOwnerOnly: false,
    channel,
  });
  const result = await server.app
    .get(ShipmateConfigService)
    .upsertConfig(
      ctx,
      process.env.SHIPMATE_API_KEY!,
      process.env.SHIPMATE_USERNAME!,
      process.env.SHIPMATE_PASSWORD!,
      [
        process.env.SHIPMATE_WEBHOOK_AUTH_TOKEN1!,
        process.env.SHIPMATE_WEBHOOK_AUTH_TOKEN2!,
      ]
    );
  console.log('Created Shipmate Config');
  const res = await createSettledOrder(
    shopClient,
    1,
    true,
    undefined,
    undefined,
    {
      input: {
        fullName: 'Martinho Pinelabio',
        streetLine1: 'Verzetsstraat',
        streetLine2: '12a',
        city: 'Liwwa',
        postalCode: 'SA35 0AE',
        countryCode: 'GB',
      },
    }
  );
  console.log(`Placed order ${res.code}`);
})();
```

## File: packages/vendure-plugin-shipmate/test/shipmate.spec.ts

```typescript
import {
  DefaultLogger,
  DefaultOrderCodeStrategy,
  isGraphQlErrorResult,
  LogLevel,
  mergeConfig,
  Order,
  OrderService,
  RequestContext,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import nock from 'nock';
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import {
  ModifyOrderInput,
  MutationModifyOrderArgs,
} from '@vendure/common/lib/generated-types';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import axios from 'axios';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { ShipmateConfigService } from '../src/api/shipmate-config.service';
import { ShipmatePlugin } from '../src/shipmate.plugin';
import type { TrackingEventPayload } from '../src/types';
import {
  authToken,
  cancelShipmentResponse,
  mockShipment,
  MODIFY_ORDER,
} from './test-helpers';
let orderFromShouldSendStrategy: Order | undefined;
describe('Shipmate plugin', async () => {
  let server: TestServer;
  let shopClient: SimpleGraphQLClient;
  let adminClient: SimpleGraphQLClient;
  let ctx: RequestContext;
  const port = 3105;
  const nockBaseUrl = 'https://api-staging.shipmate.co.uk/v1.2';
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      apiOptions: {
        port,
      },
      plugins: [
        ShipmatePlugin.init({
          apiUrl: nockBaseUrl,
          shouldSendOrder: function (
            ctx: RequestContext,
            order: Order
          ): Promise<boolean> | boolean {
            orderFromShouldSendStrategy = order;
            return order.totalQuantity < 5;
          },
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, shopClient, adminClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 2,
    });
    ctx = await getSuperadminContext(server.app);
    await server.app
      .get(ShipmateConfigService)
      .upsertConfig(
        ctx,
        'SHIPMATE_API_KEY',
        'SHIPMATE_USERNAME',
        'SHIPMATE_PASSWORD',
        [authToken]
      );
  }, 60000);
  it('Should start successfully', () => {
    expect(server.app.getHttpServer()).toBeDefined();
  });
  let order: Order | undefined;
  nock(nockBaseUrl)
    .post('/tokens', (reqBody) => {
      return true;
    })
    .reply(200, {
      message: 'Login Successful',
      data: {
        token: '749a75e3c1048965c498017efae8051f',
      },
    })
    .persist(true);
  let shipmentRequests: any[] = [];
  nock(nockBaseUrl)
    .post('/shipments', (reqBody) => {
      shipmentRequests.push(reqBody);
      return true;
    })
    .reply(200, { data: [mockShipment], message: 'Shipment Created' })
    .persist(true);
  it('Should not create a Shipment when an Order.totalQuantity is >= 5', async () => {
    await createSettledOrder(shopClient, 'T_1', true, [
      { id: 'T_1', quantity: 2 },
      { id: 'T_2', quantity: 3 },
    ]);
    await new Promise((resolve) => setTimeout(resolve, 1000));
    const orderService = server.app.get(OrderService);
    order = await orderService.findOne(ctx, 1);
    expect(shipmentRequests.length).toBe(0);
  });
  it('Should create a Shipment when an Order is placed', async () => {
    vi.spyOn(DefaultOrderCodeStrategy.prototype, 'generate').mockImplementation(
      () => mockShipment.shipment_reference
    );
    await shopClient.asAnonymousUser();
    await createSettledOrder(shopClient, 'T_1');
    await new Promise((resolve) => setTimeout(resolve, 1000));
    const orderService = server.app.get(OrderService);
    order = await orderService.findOne(ctx, 2);
    expect(shipmentRequests.length).toBe(1);
    expect(shipmentRequests[0]?.shipment_reference).toBe(order?.code);
  });
  it('Should pass the order with relations into "shouldSendOrder" strategy', async () => {
    expect(orderFromShouldSendStrategy?.customer?.emailAddress).toBeDefined();
    expect(
      orderFromShouldSendStrategy?.lines[0].productVariant.name
    ).toBeDefined();
    expect(
      orderFromShouldSendStrategy?.shippingLines[0].shippingMethod.name
    ).toBeDefined();
  });
  it('Should cancel and recreate order on Order Modification', async () => {
    const cancelShipmentScope = nock(nockBaseUrl)
      .delete(`/shipments/${mockShipment.shipment_reference}`)
      .reply(200, cancelShipmentResponse)
      .persist(true);
    const orderService = server.app.get(OrderService);
    const ctx = await getSuperadminContext(server.app);
    await adminClient.asSuperAdmin();
    try {
      const modifyOrderInput: ModifyOrderInput = {
        dryRun: true,
        orderId: 2,
        addItems: [
          {
            productVariantId: 3,
            quantity: 3,
          },
        ],
      };
      const transitionToModifyingResult = await orderService.transitionToState(
        ctx,
        2,
        'Modifying'
      );
      if (isGraphQlErrorResult(transitionToModifyingResult)) {
        throw transitionToModifyingResult.transitionError;
      }
      await adminClient.query<any, MutationModifyOrderArgs>(MODIFY_ORDER, {
        input: modifyOrderInput,
      });
      const transitionArrangingAdditionalPaymentResult =
        await orderService.transitionToState(
          ctx,
          2,
          'ArrangingAdditionalPayment'
        );
      if (isGraphQlErrorResult(transitionArrangingAdditionalPaymentResult)) {
        throw transitionArrangingAdditionalPaymentResult.transitionError;
      }
    } catch (e) {
      console.error(e);
      throw e;
    }
    await new Promise((resolve) => setTimeout(resolve, 1 * 1000));
    expect(cancelShipmentScope.isDone()).toBe(true);
    expect(shipmentRequests.length).toBe(2);
    expect(shipmentRequests[1]?.shipment_reference).toBe(order?.code);
  });
  it('Should mark Order as Shipped when receiving "TRACKING_COLLECTED" event', async () => {
    const result = await axios.post(`http://localhost:${port}/shipmate`, <
      TrackingEventPayload
    >{
      auth_token: authToken,
      event: 'TRACKING_COLLECTED',
      order_reference: mockShipment.shipment_reference,
      shipment_reference: mockShipment.shipment_reference,
    });
    expect(result.status).toBe(201);
    const orderService = server.app.get(OrderService);
    const detailedOrder = await orderService.findOne(ctx, 2, ['fulfillments']);
    expect(detailedOrder?.state).toBe('Shipped');
    expect(detailedOrder?.fulfillments?.length).toBeGreaterThan(0);
  });
  it('Should mark Order as Delivered when receiving "TRACKING_DELIVERED" event', async () => {
    const result = await axios.post(`http://localhost:${port}/shipmate`, <
      TrackingEventPayload
    >{
      auth_token: authToken,
      event: 'TRACKING_DELIVERED',
      order_reference: mockShipment.shipment_reference,
      shipment_reference: mockShipment.shipment_reference,
    });
    expect(result.status).toBe(201);
    const orderService = server.app.get(OrderService);
    const detailedOrder = await orderService.findOne(ctx, 2, ['fulfillments']);
    expect(detailedOrder?.state).toBe('Delivered');
    expect(detailedOrder?.fulfillments?.length).toBeGreaterThan(0);
  });
  afterAll(() => {
    return server.destroy();
  });
});
```

## File: packages/vendure-plugin-shipmate/test/test-helpers.ts

```typescript
import type { ShipmateConfigEntity } from '../src/api/shipmate-config.entity';
import { gql } from 'graphql-tag';
export const authToken = 'SHIPMATE_WEBHOOK_AUTH_TOKEN';
const mockShipment = {
  id: '4e084315-f87f-4d9f-994e-9b25f6b9844d',
  shipment_reference: 'FBJYSHC7WTRQEA14',
  parcel_reference: 'rai10d',
  carrier: 'GENERIC_LABEL',
  service_name: 'Demo Label',
  tracking_reference: 'P5D414200003',
  universal_tracking_reference: 'C5D414200003',
  created_by: 'Surafel .',
  created_with: 'vendure-test',
  created_at: '2024-05-21 13:24:12',
  price: '0.00',
  estimated_delivery_date: '2024-05-23 23:59',
  to_address: {
    delivery_name: 'Hayden Zieme',
    line_1: '9584 Judge Harbor',
    line_2: '',
    line_3: '',
    city: 'South Shadberg',
    county: 'Bedfordshire',
    postcode: 'RX44 5LD',
    country: 'GB',
  },
  pdf: '',
  zpl:
    'CT~~CD,~CC^~CT~\n' +
    '^XA\n' +
    '\n' +
    '~TA000~JSN^MNW^MTD^PON^PMN^JMA^PR5,5~SD15^JUS^LRN^CI0^XZ\n' +
    '^XA\n' +
    '^MMT\n' +
    '^PW812\n' +
    '^LL1218\n' +
    '\n' +
    '^FO509,32^GFA,1734,1734,34,003FF8I01O03CgQ01ER0F801JFI07CN0FEgQ03FQ01DC03JF800FEN0FFgQ03F8P01760KFC00FEN0FFgQ03F8P037E1KFE00FEN0FFgQ03F8P03721LF00FEN0FFgQ03F8P03563FF87FF00FEN0FEgQ03F8P01CE3FC00FF80FEN07EgQ03F8P01FC7F8007F80FEhG03F8Q07,7FI03F80FEhG03F8,7FI01F00FEhG03F8,7FJ0E00FE1FCS03FCK07E07EJ07F8K03F8L07F8,7FM0FE7FF8007FFEJ07CIFI07CFF9FF8001IF3E07LFI03FFE,7F8L0FEIFC00JFJ0KFC00MF8007JFE07LF800JF8,3FEL0KFE00JFJ0KFE00MFC00LF0MF801JFC,3FF8K0LF00JFJ0LF00MFC01LF07LF803JFE,3IF8J0LF007IFJ0LF00MFE03LF07LF007KF,1JFJ0IF0FF003IFJ0FFE0FF80FF1FF1FE03FE0IF01KFE007FC1FF8,0JFEI0FFC07F8I07FJ0FF803F80FF0FE0FE07F803FFI03F8J0FF007F8,07JF800FF803F8I07FJ0FF003FC0FE0FE0FE07F001FFI03F8J0FE003FC,01JFE00FF003F8I07FJ0FF001FC0FE0FE0FE0FFI0FFI03F8I01FC001FC,003JF00FF003F8I07FJ0FE001FC0FE0FE0FE0FEI0FFI03F8I01FCI0FC,I07IF00FE003F8I07FJ0FEI0FE0FE0FE0FE0FEI0FFI03F8I01LFC,J07FF80FE003F8I07FJ0FEI0FE0FE0FE0FE0FEI07FI03F8I03LFE,K0FFC0FE003F8I07FJ0FCI0FE0FE0FE0FE0FCI07FI03F8I03LFE,K03FC0FE003F8I07FJ0FCI0FE0FE0FE0FE0FCI07FI03F8I03LFE,K03FC0FE003F8I07FJ0FCI0FE0FE0FE0FE0FCI07FI03F8I03LFC,K01FC0FE003F8I07FJ0FCI0FE0FE0FE0FE0FEI07FI03F8I03LFC,7CI01FC0FE003F8I07FJ0FEI0FE0FE0FE0FE0FEI07FI03F8I03LF,FEI01FC0FE003F8I07FJ0FEI0FE0FE0FE0FE0FEI0FFI03F8I01FC,FEI01FC0FE003F8I07FJ0FE001FC0FE0FE0FE0FEI0FFI03F8I01FC,FFI03FC0FE003F8I07FJ0FF001FC0FE0FE0FE07F001FFI03F8I01FEI078,FFC007FC0FE003F8I07FJ0FF803FC0FE0FE0FE07F801FFI03F80380FE001FC,7FF00FF80FE003F8I07FJ0FFC07F80FE0FE0FE07FC07FFI03FC0FC0FF803FC,7LF80FE003F80LF80IF1FF80FE0FE0FE03FF1IFI01FF3FC07FF1FFC,3LF00FE003F81LFC0LF00FE0FE0FE01LFI01JFC07KF8,1KFE00FE003F81LFE0KFE00FE0FE0FE01LFJ0JFC03KF,0KFC00FE003F81LFE0KFC00FE0FC0FE00KFEJ0JF801JFE,03JFI07C001F01LFC0KF800FC0FC0FC003IF7EJ07IFI07IFC,00IFCI038I0E00LF80FCFFEI078078078I0FFE3CJ01FFCI01IF,I038g0FC0EV0EN01CK01E,gK0FC,::::::::gK078,^FS\n' +
    '\n' +
    '^FO32,32^A0N,22,20^FB460,3,0,L,0^FH^FDSender: Shipmate Systems Limited, Friar Gate Studios, Ford Street, Derby DE1 1EE United Kingdom^FS\n' +
    '\n' +
    '^FO32,110^A0N,24,22^FB300,1,0,L,0^FH^FDDeliver To^FS\n' +
    '\n' +
    '^FT32,180^A0N,34,32^FH^FDHayden Zieme^FS\n' +
    '%COMPANY_NAME%\n' +
    '^FT32,224^A0N,34,32^FH^FD9584 Judge Harbor^FS\n' +
    '%ADDRESS_LINE_2%\n' +
    '%ADDRESS_LINE_3%\n' +
    '^FT32,268^A0N,34,32^FH^FDSouth Shadberg^FS\n' +
    '^FT32,312^A0N,34,32^FH^FDRX44 5LD^FS\n' +
    '%ADDRESS_LINE_6%\n' +
    '\n' +
    '\n' +
    '^FO0,520^GB812,0,3^FS\n' +
    '^FO0,640^GB812,0,3^FS\n' +
    '^FO0,740^GB812,0,3^FS\n' +
    '^FO0,840^GB812,0,3^FS\n' +
    '^FO0,935^GB812,0,3^FS\n' +
    '\n' +
    '\n' +
    '^FO32,544^A0N,24,22^FB300,1,0,L,0^FH^FDDespatch Date^FS\n' +
    '^FO320,544^A0N,24,22^FB200,1,0,C,0^FH^FDWeight^FS\n' +
    '^FO600,544^A0N,24,22^FB200,1,0,C,0^FH^FDParcel^FS\n' +
    '\n' +
    '^FO32,590^A0N,32,32^FB300,1,0,L,0^FH^FD21-May-2024^FS\n' +
    '^FO320,590^A0N,32,32^FB200,1,0,C,0^FH^FD0.03kg^FS\n' +
    '^FO600,590^A0N,32,32^FB200,1,0,C,0^FH^FD1 of 1^FS\n' +
    '\n' +
    '^FO32,659^A0N,24,22^FB300,1,0,L,0^FH^FDSender Reference^FS\n' +
    '^FO32,695^A0N,32,32^FB600,1,0,L,0^FH^FDrai10d^FS\n' +
    '\n' +
    '^FO32,759^A0N,24,22^FB300,1,0,L,0^FH^FDConsignment Number^FS\n' +
    '^FO32,795^A0N,32,32^FB600,1,0,L,0^FH^FD24052159466^FS\n' +
    '\n' +
    '^FO32,859^A0N,24,22^FB300,1,0,L,0^FH^FDDelivery Instructions^FS\n' +
    '^FO32,895^A0N,28,26^FB600,1,0,L,0^FH^FD^FS\n' +
    '\n' +
    '\n' +
    '\n' +
    '^FO0,1170^A0N,31,30^FB812,1,0,C,0^FH^FD24052159466-1^FS\n' +
    '\n' +
    '\n' +
    '\n' +
    '^FT688,475^A0N,14,16^FH^FDLabelled by^FS\n' +
    '^FO664,482^GFA,400,400,16,,07F81CI07T038,0FFC3CI0F8S038,1FFE3CI0F8S038,1E3E3CI07T038,3C0E3CX038,3C063FF07F00FF83FDF07F63FFE0FE,3F003FFC7F81FFE3IF8IF7FFE1FF8,1FE03FFC7F81FFE3IF8IF7FFE3FF8,1FFC3F3C0781F9F3DF79F3F03803C7C,07FE3E3C0781F0F3DE79E1F0380783C,00FF3C1C0781E073DE7BC0F03807FFC,001F3C1C0781E073DE7BC0F03807FFC,380F3C1C0781E073DE7BC0F03807FFC,3C0F3C1C0781E0F3DE79C0F038078,3E1F3C1C0781F0F3DE79E1F03C67C,3IF3C1C7FF9IF3DE79IF03FF3FFC,1FFE3C1CIFDFFE3DE78IF03FF3FFC,0FFC1C1CIF9FFC3CE787FF01FE1FF8,01EN01E6L01CI07003C,Q01E,:::,^FS\n' +
    '\n' +
    '\n' +
    '^PQ1,0,1,Y^XZ',
  png: '',
};
const cancelShipmentResponse = {
  message: 'Shipment Cancelled',
  data: null,
};
const testShipmateConfig: ShipmateConfigEntity = {
  channelId: '1',
  apiKey: 'SHIPMATE_API_KEY',
  webhookAuthTokens: [],
  id: 1,
  username: 'SHIPMATE_USERNAME',
  password: 'SHIPMATE_PASSWORD',
  createdAt: new Date(),
  updatedAt: new Date(),
};
testShipmateConfig.webhookAuthTokens.push({
  token: authToken,
  shipmateConfig: testShipmateConfig,
  id: '1',
  createdAt: new Date(),
  updatedAt: new Date(),
});
const MODIFY_ORDER = gql`
  mutation modifyOrder($input: ModifyOrderInput!) {
    modifyOrder(input: $input) {
      ... on Order {
        id
        code
        state
      }
      ... on ErrorResult {
        message
        errorCode
      }
    }
  }
`;
export {
  testShipmateConfig,
  mockShipment,
  cancelShipmentResponse,
  MODIFY_ORDER,
};
```

## File: packages/vendure-plugin-shipping-extensions/src/config/shipping/distance-based-shipping-calculator.ts

```typescript
import {
  LanguageCode,
  ShippingCalculator,
  Injector,
  InternalServerError,
  Logger,
} from '@vendure/core';
import { ShippingExtensionsOptions } from '../../shipping-extensions.plugin';
import { loggerCtx, PLUGIN_OPTIONS } from '../../constants';
import { getDistanceBetweenPointsInKMs } from '../../util/get-distance-between-points';
import { getHighestTaxRateOfOrder } from './shipping-util';
let pluginOptions: ShippingExtensionsOptions;
let injector: Injector;
export const distanceBasedShippingCalculator = new ShippingCalculator({
  code: 'distance-based-shipping-calculator',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Distance Based Shipping Calculator',
    },
  ],
  args: {
    storeLatitude: {
      type: 'float',
      ui: { component: 'number-form-input', min: -90, max: 90 },
      label: [{ languageCode: LanguageCode.en, value: 'Store Latitude' }],
    },
    storeLongitude: {
      type: 'float',
      ui: { component: 'number-form-input', min: -180, max: 180 },
      label: [{ languageCode: LanguageCode.en, value: 'Store Longitude' }],
    },
    pricePerKm: {
      type: 'int',
      ui: { component: 'currency-form-input' },
      label: [{ languageCode: LanguageCode.en, value: 'Price per KM' }],
    },
    minPrice: {
      type: 'int',
      ui: { component: 'currency-form-input' },
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'MinimumPrice',
        },
      ],
    },
  },
  init(_injector: Injector) {
    pluginOptions = _injector.get<ShippingExtensionsOptions>(PLUGIN_OPTIONS);
    injector = _injector;
  },
  calculate: async (ctx, order, args, method) => {
    if (!pluginOptions?.orderAddressToGeolocationStrategy) {
      throw new InternalServerError(
        'OrderAddress to geolocation conversion strategy not configured'
      );
    }
    const taxRate = await getHighestTaxRateOfOrder(ctx, injector, order);
    const storeGeoLocation = {
      latitude: args.storeLatitude,
      longitude: args.storeLongitude,
    };
    const minimumPrice = {
      price: args.minPrice,
      priceIncludesTax: ctx.channel.pricesIncludeTax,
      taxRate,
      metadata: { storeGeoLocation },
    };
    if (
      !order?.shippingAddress?.postalCode ||
      !order.shippingAddress?.countryCode
    ) {
      return minimumPrice;
    }
    try {
      const shippingAddressGeoLocation =
        await pluginOptions.orderAddressToGeolocationStrategy.getGeoLocationForAddress(
          order.shippingAddress
        );
      if (!shippingAddressGeoLocation) {
        return minimumPrice;
      }
      const distance = getDistanceBetweenPointsInKMs(
        shippingAddressGeoLocation,
        storeGeoLocation
      );
      let price = distance * args.pricePerKm;
      if (price < args.minPrice) {
        price = args.minPrice;
      }
      return {
        price,
        priceIncludesTax: ctx.channel.pricesIncludeTax,
        taxRate,
        metadata: { shippingAddressGeoLocation, storeGeoLocation },
      };
    } catch (e) {
      Logger.error(
        `Failed to calculate shipping for ${method.name}: ${
          (e as Error)?.message
        }`,
        loggerCtx
      );
      return minimumPrice;
    }
  },
});
```

## File: packages/vendure-plugin-shipping-extensions/src/config/shipping/facet-and-country-checker.ts

```typescript
import {
  CountryService,
  FacetValueChecker,
  Injector,
  LanguageCode,
  RequestContext,
  ShippingEligibilityChecker,
} from '@vendure/core';
import { isEligibleForCountry } from './shipping-util';
import { ShippingExtensionsPlugin } from '../../shipping-extensions.plugin';
let injector: Injector;
export const facetAndCountryChecker = new ShippingEligibilityChecker({
  code: 'shipping-by-facets-and-country',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Check by facets and country',
    },
  ],
  args: {
    facets: {
      type: 'ID',
      list: true,
      label: [{ languageCode: LanguageCode.en, value: `Facets` }],
      description: [
        {
          languageCode: LanguageCode.en,
          value: `All items in order should have all of the facets`,
        },
      ],
      ui: {
        component: 'facet-value-form-input',
      },
    },
    countries: {
      type: 'string',
      list: true,
      ui: {
        component: 'select-form-input',
        options: [
          {
            value: 'nl',
            label: [{ languageCode: LanguageCode.en, value: 'Nederland' }],
          },
        ],
      },
    },
    excludeCountries: {
      type: 'boolean',
      description: [
        {
          languageCode: LanguageCode.en,
          value: 'Eligible for all countries except the ones listed above',
        },
      ],
      ui: {
        component: 'boolean-form-input',
      },
    },
  },
  async init(_injector) {
    injector = _injector;
    const ctx = RequestContext.empty();
    const countries = await _injector.get(CountryService).findAll(ctx);
    this.args.countries.ui.options = countries.items.map((c) => ({
      value: c.code,
      label: [
        {
          languageCode: LanguageCode.en,
          value: c.name,
        },
      ],
    }));
  },
  async check(ctx, order, { facets, countries, excludeCountries }, method) {
    const isEligibleByCountry = isEligibleForCountry(
      order,
      countries,
      excludeCountries
    );
    if (isEligibleByCountry === false) {
      return false;
    }
    for (const line of order.lines) {
      const hasFacetValues = await injector
        .get(FacetValueChecker)
        .hasFacetValues(line, facets);
      if (!hasFacetValues) {
        return false;
      }
    }
    const additionalIsEligible =
      await ShippingExtensionsPlugin.options.additionalShippingEligibilityCheck?.(
        ctx,
        injector,
        order,
        method
      );
    if (additionalIsEligible === false) {
      return false;
    }
    return true;
  },
});
```

## File: packages/vendure-plugin-shipping-extensions/src/config/shipping/flat-rate-item-based-shipping-calculator.ts

```typescript
import { LanguageCode } from '@vendure/common/lib/generated-types';
import { Injector, RequestContext, ShippingCalculator } from '@vendure/core';
import { getHighestTaxRateOfOrder } from './shipping-util';
import { ShippingExtensionsPlugin } from '../../shipping-extensions.plugin';
export enum TaxSetting {
  include = 'include',
  exclude = 'exclude',
  auto = 'auto',
}
let injector: Injector;
export const flatRateItemBasedShippingCalculator = new ShippingCalculator({
  code: 'flat-rate-item-based-shipping-calculator',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Flat rate. Tax based on highest tax rate in cart.',
    },
  ],
  args: {
    rate: {
      type: 'int',
      defaultValue: 0,
      ui: { component: 'currency-form-input' },
      label: [{ languageCode: LanguageCode.en, value: 'Shipping price' }],
    },
    includesTax: {
      type: 'string',
      defaultValue: TaxSetting.auto,
      ui: {
        component: 'select-form-input',
        options: [
          {
            label: [{ languageCode: LanguageCode.en, value: 'Includes tax' }],
            value: TaxSetting.include,
          },
          {
            label: [{ languageCode: LanguageCode.en, value: 'Excludes tax' }],
            value: TaxSetting.exclude,
          },
          {
            label: [
              {
                languageCode: LanguageCode.en,
                value: 'Auto (based on Channel)',
              },
            ],
            value: TaxSetting.auto,
          },
        ],
      },
      label: [{ languageCode: LanguageCode.en, value: 'Price includes tax' }],
    },
  },
  init: (_injector) => {
    injector = _injector;
  },
  calculate: async (ctx, order, args, method) => {
    const flatRateSurchargeFn =
      ShippingExtensionsPlugin.options?.flatRateSurchargeFn;
    const [taxRate, surcharge] = await Promise.all([
      getHighestTaxRateOfOrder(ctx, injector, order),
      flatRateSurchargeFn?.(ctx, injector, order, method) || 0,
    ]);
    return {
      price: args.rate + surcharge,
      taxRate,
      priceIncludesTax: priceIncludesTax(ctx, args.includesTax as TaxSetting),
    };
  },
});
function priceIncludesTax(ctx: RequestContext, setting: TaxSetting): boolean {
  switch (setting) {
    case TaxSetting.auto:
      return ctx.channel.pricesIncludeTax;
    case TaxSetting.exclude:
      return false;
    case TaxSetting.include:
      return true;
  }
}
```

## File: packages/vendure-plugin-shipping-extensions/src/config/shipping/shipping-util.spec.ts

```typescript
import { describe, it, expect } from 'vitest';
import { isEligibleForCountry } from './shipping-util';
import { getHighestTaxRateOfOrder } from './shipping-util';
import { Order, RequestContext, Injector } from '@vendure/core';
describe('isEligibleForCountry', () => {
  it('Is eligible if the order country is in the list and excludeCountries is false', () => {
    const order = {
      shippingAddress: {
        countryCode: 'US',
      },
    } as Order;
    const result = isEligibleForCountry(order, ['US', 'CA'], false);
    expect(result).toBe(true);
  });
  it('Is not eligible if the order country is in the list and excludeCountries is true', () => {
    const order = {
      shippingAddress: {
        countryCode: 'US',
      },
    } as Order;
    const result = isEligibleForCountry(order, ['US', 'CA'], true);
    expect(result).toBe(false);
  });
  it('Is not eligible if the order country is not in the list', () => {
    const order = {
      shippingAddress: {
        countryCode: 'MX',
      },
    } as Order;
    const result = isEligibleForCountry(order, ['US', 'CA'], false);
    expect(result).toBe(false);
  });
  it('should return true if the order country is not in the list and excludeCountries is true', () => {
    const order = {
      shippingAddress: {
        countryCode: 'MX',
      },
    } as Order;
    const result = isEligibleForCountry(order, ['US', 'CA'], true);
    expect(result).toBe(true);
  });
});
describe('getHighestTaxRateOfOrder', () => {
  const mockCtx = {} as RequestContext;
  const mockInjector = {} as Injector;
  it('should return the highest tax rate when surcharge has highest rate, because shipping lines should be ignored', async () => {
    const order = {
      lines: [{ taxRate: 0.1 }],
      surcharges: [{ taxRate: 0.2 }],
      shippingLines: [{ taxRate: 0.3 }],
    } as unknown as Order;
    const result = await getHighestTaxRateOfOrder(mockCtx, mockInjector, order);
    expect(result).toBe(0.2);
  });
  it('should return order line as highest tax rate', async () => {
    const order = {
      lines: [{ taxRate: 0.2 }],
      surcharges: [{ taxRate: 0.1 }],
      shippingLines: [{ taxRate: 0.3 }],
    } as unknown as Order;
    const result = await getHighestTaxRateOfOrder(mockCtx, mockInjector, order);
    expect(result).toBe(0.2);
  });
  it('should return 0 for order without lines and surcharges', async () => {
    const order = {
      lines: [],
      surcharges: [],
      shippingLines: [{ taxRate: 0.3 }],
    } as unknown as Order;
    const result = await getHighestTaxRateOfOrder(mockCtx, mockInjector, order);
    expect(result).toBe(0);
  });
});
```

## File: packages/vendure-plugin-shipping-extensions/src/config/shipping/shipping-util.ts

```typescript
import { EntityHydrator, Injector, Order, RequestContext } from '@vendure/core';
export function isEligibleForCountry(
  order: Order,
  countryCodes: string[],
  excludeCountries: boolean
): boolean {
  const shippingCountry = order.shippingAddress.countryCode;
  const orderIsInSelectedCountry = shippingCountry
    ? countryCodes.includes(shippingCountry)
    : false;
  if (orderIsInSelectedCountry && excludeCountries) {
    return false;
  }
  if (!orderIsInSelectedCountry && !excludeCountries) {
    return false;
  }
  return true;
}
export async function getHighestTaxRateOfOrder(
  ctx: RequestContext,
  injector: Injector,
  order: Order
): Promise<number> {
  if (!order.surcharges || !order.lines) {
    await injector.get(EntityHydrator).hydrate(ctx, order, {
      relations: ['lines', 'surcharges'],
    });
  }
  const lineTaxRates = order.lines.map((line) => line.taxRate);
  const surchargeTaxRates = order.surcharges.map(
    (surcharge) => surcharge.taxRate
  );
  return Math.max(...lineTaxRates, ...surchargeTaxRates, 0);
}
```

## File: packages/vendure-plugin-shipping-extensions/src/config/shipping/weight-and-country-checker.ts

```typescript
import {
  CountryService,
  EntityHydrator,
  Injector,
  LanguageCode,
  Order,
  RequestContext,
  ShippingEligibilityChecker,
} from '@vendure/core';
import { ShippingExtensionsPlugin } from '../../shipping-extensions.plugin';
import { isEligibleForCountry } from './shipping-util';
export function calculateOrderWeight(order: Order): number {
  return order.lines.reduce((acc, line) => {
    const weight =
      (line.productVariant.customFields as any).weight ??
      (line.productVariant.product?.customFields as any).weight ??
      0;
    const lineWeight = weight * line.quantity;
    return acc + lineWeight;
  }, 0);
}
let entityHydrator: EntityHydrator;
let injector: Injector;
export const weightAndCountryChecker = new ShippingEligibilityChecker({
  code: 'shipping-by-weight-and-country',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Check by weight and country',
    },
  ],
  args: {
    minWeight: {
      type: 'int',
      description: [{ languageCode: LanguageCode.en, value: `Minimum weight` }],
    },
    maxWeight: {
      type: 'int',
      description: [{ languageCode: LanguageCode.en, value: `Maximum weight` }],
    },
    countries: {
      type: 'string',
      list: true,
      ui: {
        component: 'select-form-input',
        options: [
          {
            value: 'nl',
            label: [{ languageCode: LanguageCode.en, value: 'Nederland' }],
          },
        ],
      },
    },
    excludeCountries: {
      type: 'boolean',
      description: [
        {
          languageCode: LanguageCode.en,
          value: 'Eligible for all countries except the ones listed above',
        },
      ],
      ui: {
        component: 'boolean-form-input',
      },
    },
  },
  async init(_injector) {
    entityHydrator = _injector.get(EntityHydrator);
    injector = _injector;
    const ctx = RequestContext.empty();
    const countries = await _injector.get(CountryService).findAll(ctx);
    this.args.countries.ui.options = countries.items.map((c) => ({
      value: c.code,
      label: [
        {
          languageCode: LanguageCode.en,
          value: c.name,
        },
      ],
    }));
    this.args.minWeight.description = [
      {
        languageCode: LanguageCode.en,
        value: `Minimum weight in ${ShippingExtensionsPlugin.options?.weightUnit}`,
      },
    ];
    this.args.maxWeight.description = [
      {
        languageCode: LanguageCode.en,
        value: `Maximum weight in ${ShippingExtensionsPlugin.options?.weightUnit}`,
      },
    ];
  },
  async check(
    ctx,
    order,
    { minWeight, maxWeight, countries, excludeCountries },
    method
  ) {
    const isEligibleByCountry = isEligibleForCountry(
      order,
      countries,
      excludeCountries
    );
    if (isEligibleByCountry === false) {
      return false;
    }
    await entityHydrator.hydrate(ctx, order, {
      relations: [
        'lines',
        'lines.productVariant',
        'lines.productVariant.product',
      ],
    });
    let totalOrderWeight = 0;
    if (ShippingExtensionsPlugin.options?.weightCalculationFunction) {
      totalOrderWeight =
        await ShippingExtensionsPlugin.options.weightCalculationFunction(
          ctx,
          order,
          injector
        );
    } else {
      totalOrderWeight = calculateOrderWeight(order);
    }
    const isBetweenWeights =
      totalOrderWeight <= maxWeight && totalOrderWeight >= minWeight;
    if (!isBetweenWeights) {
      return false;
    }
    const additionalIsEligible =
      await ShippingExtensionsPlugin.options.additionalShippingEligibilityCheck?.(
        ctx,
        injector,
        order,
        method
      );
    if (additionalIsEligible === false) {
      return false;
    }
    return true;
  },
});
```

## File: packages/vendure-plugin-shipping-extensions/src/config/order-in-country-promotion-condition.ts

```typescript
import {
  CountryService,
  LanguageCode,
  PromotionCondition,
  RequestContext,
} from '@vendure/core';
export const orderInCountryPromotionCondition = new PromotionCondition({
  code: 'order_in_country',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Shipping country is in one of { countries }',
    },
  ],
  args: {
    countries: {
      type: 'string',
      list: true,
      ui: {
        component: 'select-form-input',
        options: [
          {
            value: 'NL',
            label: [{ languageCode: LanguageCode.en, value: 'Nederland' }],
          },
        ],
      },
    },
  },
  async init(injector) {
    const ctx = RequestContext.empty();
    const countries = await injector.get(CountryService).findAll(ctx);
    this.args.countries.ui.options = countries.items.map((c) => ({
      value: c.code,
      label: [
        {
          languageCode: LanguageCode.en,
          value: c.name,
        },
      ],
    }));
  },
  check(ctx, order, args) {
    if (!order.shippingAddress?.countryCode) {
      return false;
    }
    return args.countries.includes(order.shippingAddress.countryCode);
  },
});
```

## File: packages/vendure-plugin-shipping-extensions/src/strategies/order-address-to-geolocation-strategy.ts

```typescript
import { OrderAddress } from '@vendure/common/lib/generated-shop-types';
export interface OrderAddressToGeolocationConversionStrategy {
  getGeoLocationForAddress: (
    orderAddress: OrderAddress
  ) => Promise<GeoLocation | undefined>;
}
export interface GeoLocation {
  latitude: number;
  longitude: number;
}
```

## File: packages/vendure-plugin-shipping-extensions/src/strategies/uk-postalcode-to-geolocation-strategy.ts

```typescript
import {
  OrderAddressToGeolocationConversionStrategy,
  GeoLocation,
} from './order-address-to-geolocation-strategy';
import { OrderAddress } from '@vendure/common/lib/generated-shop-types';
export const POSTCODES_URL = `https://postcodes.io/postcodes`;
export class UKPostalCodeToGelocationConversionStrategy
  implements OrderAddressToGeolocationConversionStrategy
{
  async getGeoLocationForAddress(
    orderAddress: OrderAddress
  ): Promise<GeoLocation | undefined> {
    if (!orderAddress?.postalCode) {
      return undefined;
    }
    const url = `${POSTCODES_URL}/${encodeURIComponent(
      orderAddress.postalCode
    )}`;
    const response = await fetch(url);
    if (response.status === 404) {
      return undefined;
    }
    if (!response.ok) {
      throw new Error(`${response.status}: ${await response.text()}`);
    }
    const responseBody: any = await response.json();
    return {
      latitude: responseBody.result.latitude,
      longitude: responseBody.result.longitude,
    };
  }
}
```

## File: packages/vendure-plugin-shipping-extensions/src/util/get-distance-between-points.ts

```typescript
import { GeoLocation } from '../strategies/order-address-to-geolocation-strategy';
export function getDistanceBetweenPointsInKMs(
  pointA: GeoLocation,
  pointB: GeoLocation
): number {
  const EARTH_RADIUS = 6371;
  const dLat = deg2rad(pointA.latitude - pointB.latitude);
  const dLon = deg2rad(pointA.longitude - pointB.longitude);
  const a =
    Math.pow(Math.sin(dLat / 2), 2) +
    Math.cos(deg2rad(pointB.latitude)) *
      Math.cos(deg2rad(pointB.longitude)) *
      Math.pow(Math.sin(dLon / 2), 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const d = EARTH_RADIUS * c;
  return d;
}
function deg2rad(deg: number) {
  return deg * (Math.PI / 180);
}
```

## File: packages/vendure-plugin-shipping-extensions/src/constants.ts

```typescript
export const loggerCtx = 'ShippingExtensionsPlugin';
export const PLUGIN_OPTIONS = Symbol('ShippingExtensionsOptions');
```

## File: packages/vendure-plugin-shipping-extensions/src/index.ts

```typescript
export * from './shipping-extensions.plugin';
export * from './strategies/uk-postalcode-to-geolocation-strategy';
export * from './strategies/order-address-to-geolocation-strategy';
export * from './config/shipping/distance-based-shipping-calculator';
export * from './config/order-in-country-promotion-condition';
export * from './config/shipping/facet-and-country-checker';
export * from './config/shipping/weight-and-country-checker';
export * from './config/shipping/flat-rate-item-based-shipping-calculator';
export * from './config/shipping/shipping-util';
```

## File: packages/vendure-plugin-shipping-extensions/src/shipping-extensions.plugin.ts

```typescript
import {
  Injector,
  LanguageCode,
  Order,
  PluginCommonModule,
  RequestContext,
  ShippingMethod,
  VendurePlugin,
} from '@vendure/core';
import { weightAndCountryChecker } from './config/shipping/weight-and-country-checker';
import { OrderAddressToGeolocationConversionStrategy } from './strategies/order-address-to-geolocation-strategy';
import { PLUGIN_OPTIONS } from './constants';
import { distanceBasedShippingCalculator } from './config/shipping/distance-based-shipping-calculator';
import { orderInCountryPromotionCondition } from './config/order-in-country-promotion-condition';
import { flatRateItemBasedShippingCalculator } from './config/shipping/flat-rate-item-based-shipping-calculator';
import { facetAndCountryChecker } from './config/shipping/facet-and-country-checker';
export interface ShippingExtensionsOptions {
  weightUnit?: string;
  customFieldsTab?: string;
  weightCalculationFunction?: (
    ctx: RequestContext,
    order: Order,
    injector: Injector
  ) => Promise<number>;
  orderAddressToGeolocationStrategy?: OrderAddressToGeolocationConversionStrategy;
  additionalShippingEligibilityCheck?: (
    ctx: RequestContext,
    injector: Injector,
    order: Order,
    method: ShippingMethod
  ) => Promise<boolean> | boolean;
  flatRateSurchargeFn?: (
    ctx: RequestContext,
    injector: Injector,
    order: Order,
    method: ShippingMethod
  ) => Promise<number> | number;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    {
      provide: PLUGIN_OPTIONS,
      useFactory: () => ShippingExtensionsPlugin.options,
    },
  ],
  configuration: (config) => {
    config.shippingOptions.shippingEligibilityCheckers.push(
      weightAndCountryChecker,
      facetAndCountryChecker
    );
    config.shippingOptions.shippingCalculators.push(
      distanceBasedShippingCalculator,
      flatRateItemBasedShippingCalculator
    );
    config.promotionOptions.promotionConditions.push(
      orderInCountryPromotionCondition
    );
    config.customFields.Product.push({
      name: 'weight',
      label: [
        {
          languageCode: LanguageCode.en,
          value: `Weight in ${ShippingExtensionsPlugin.options?.weightUnit}`,
        },
      ],
      ui: {
        component: 'number-form-input',
        tab: ShippingExtensionsPlugin.options?.customFieldsTab,
        options: { min: 0 },
      },
      public: true,
      nullable: true,
      type: 'int',
    });
    config.customFields.ProductVariant.push({
      name: 'weight',
      label: [
        {
          languageCode: LanguageCode.en,
          value: `Weight in ${ShippingExtensionsPlugin.options?.weightUnit}`,
        },
      ],
      ui: {
        component: 'number-form-input',
        tab: ShippingExtensionsPlugin.options?.customFieldsTab,
        options: { min: 0 },
      },
      public: true,
      nullable: true,
      type: 'int',
    });
    return config;
  },
  compatibility: '>=2.2.0',
})
export class ShippingExtensionsPlugin {
  static options: ShippingExtensionsOptions;
  static init(
    options: ShippingExtensionsOptions
  ): typeof ShippingExtensionsPlugin {
    if (!options.weightUnit) {
      options.weightUnit = 'grams';
    }
    this.options = options;
    return ShippingExtensionsPlugin;
  }
}
```

## File: packages/vendure-plugin-shipping-extensions/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import {
  AutoIncrementIdStrategy,
  DefaultLogger,
  DefaultSearchPlugin,
  LanguageCode,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { ShippingExtensionsPlugin } from '../src/shipping-extensions.plugin';
import { UKPostalCodeToGelocationConversionStrategy } from '../src/strategies/uk-postalcode-to-geolocation-strategy';
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    dbConnectionOptions: {
      synchronize: true,
    },
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    entityOptions: {
      entityIdStrategy: new AutoIncrementIdStrategy(),
    },
    customFields: {
      Product: [
        {
          name: 'width',
          label: [{ value: 'Width', languageCode: LanguageCode.en }],
          type: 'localeString',
          ui: { component: 'text-form-input', tab: 'Physical properties' },
        },
        {
          name: 'metaTitle',
          label: [{ value: 'Meta title', languageCode: LanguageCode.en }],
          type: 'localeString',
          ui: { component: 'text-form-input', tab: 'SEO' },
        },
      ],
    },
    plugins: [
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
      ShippingExtensionsPlugin.init({
        weightUnit: 'kg',
        customFieldsTab: 'Physical properties',
        orderAddressToGeolocationStrategy:
          new UKPostalCodeToGelocationConversionStrategy(),
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-shipping-extensions/test/shipping-extensions.spec.ts

```typescript
import {
  DefaultLogger,
  DefaultSearchPlugin,
  FacetValue,
  FacetValueChecker,
  ID,
  LogLevel,
  mergeConfig,
  OrderService,
  ProductService,
  ProductVariantService,
  RequestContext,
  roundMoney,
  TaxRateService,
  ZoneService,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import nock from 'nock';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { LanguageCode } from '../../test/src/generated/admin-graphql';
import { CreateAddressInput } from '../../test/src/generated/shop-graphql';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { ShippingExtensionsPlugin } from '../src/shipping-extensions.plugin';
import { GeoLocation } from '../src/strategies/order-address-to-geolocation-strategy';
import {
  POSTCODES_URL,
  UKPostalCodeToGelocationConversionStrategy,
} from '../src/strategies/uk-postalcode-to-geolocation-strategy';
import { getDistanceBetweenPointsInKMs } from '../src/util/get-distance-between-points';
import {
  createDistanceBasedShippingMethod,
  createFlatRateShippingMethod,
  createPromotion,
  createShippingMethodForCountriesAndFacets,
  createShippingMethodForCountriesAndWeight,
  DistanceBasedShippingCalculatorOptions,
} from './test-helpers';
let server: TestServer;
let adminClient: SimpleGraphQLClient;
let shopClient: SimpleGraphQLClient;
let serverStarted = false;
let ctx: RequestContext;
beforeAll(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    plugins: [
      ShippingExtensionsPlugin.init({
        orderAddressToGeolocationStrategy:
          new UKPostalCodeToGelocationConversionStrategy(),
      }),
      DefaultSearchPlugin.init({}),
    ],
    paymentOptions: {
      paymentMethodHandlers: [testPaymentMethod],
    },
  });
  ({ server, adminClient, shopClient } = createTestEnvironment(config));
  await server.init({
    initialData: {
      ...initialData,
      shippingMethods: [],
      paymentMethods: [
        {
          name: testPaymentMethod.code,
          handler: { code: testPaymentMethod.code, arguments: [] },
        },
      ],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  serverStarted = true;
  ctx = await getSuperadminContext(server.app);
  const zoneService = server.app.get(ZoneService);
  const taxRateService = server.app.get(TaxRateService);
  const noTaxZone = await zoneService.create(ctx, {
    name: 'NL No Tax Zone',
    memberIds: [8],
  });
  await taxRateService.create(ctx, {
    categoryId: 3,
    enabled: true,
    name: 'Tax Exempt Country (Export)',
    value: 0,
    zoneId: noTaxZone.id,
  });
}, 60000);
it('Should start successfully', async () => {
  await expect(serverStarted).toBe(true);
});
describe('Shipping by weight and country eligibility checker', function () {
  it('Creates shipping method 1 for NL and BE, with weight between 0 and 100 ', async () => {
    await adminClient.asSuperAdmin();
    const res = await createShippingMethodForCountriesAndWeight(adminClient, {
      minWeight: 0,
      maxWeight: 100,
      countries: ['NL', 'BE'],
      rate: 111,
      exclude: false,
    });
    expect(res.code).toBeDefined();
  });
  it('Creates shipping method 2 for everything except NL and BE, with weight between 0 and 100 ', async () => {
    await adminClient.asSuperAdmin();
    const res = await createShippingMethodForCountriesAndWeight(adminClient, {
      minWeight: 0,
      maxWeight: 100,
      countries: ['NL', 'BE'],
      rate: 222,
      exclude: true,
    });
    expect(res.code).toBeDefined();
  });
  it('Creates shipping method 3 for everything except BE, with weight between 150 and 200 ', async () => {
    await adminClient.asSuperAdmin();
    const res = await createShippingMethodForCountriesAndWeight(adminClient, {
      minWeight: 0,
      maxWeight: 100,
      countries: ['BE'],
      rate: 333,
      exclude: true,
    });
    expect(res.code).toBeDefined();
  });
  it('Is eligible for method 1 with country NL and weight 0', async () => {
    const order = await createSettledOrder(shopClient, 1, true, [
      { id: 'T_1', quantity: 1 },
    ]);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shipping).toBe(111);
    expect(order.shippingWithTax).toBe(133);
  });
  it('Is not eligible for quantity 123, because of the custom strategy', async () => {
    ShippingExtensionsPlugin.options.additionalShippingEligibilityCheck =
      async (ctx, injector, order) => {
        if (order.totalQuantity === 123) {
          return false;
        } else {
          return true;
        }
      };
    const createSettledOrderPromise = createSettledOrder(shopClient, 1, true, [
      { id: 'T_1', quantity: 123 },
    ]);
    await expect(createSettledOrderPromise).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
    ShippingExtensionsPlugin.options.additionalShippingEligibilityCheck =
      undefined;
  });
  it('Is eligible for method 3 with country NL and weight 200', async () => {
    const order = await createSettledOrder(shopClient, 3);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shipping).toBe(333);
    expect(order.shippingWithTax).toBe(400);
  });
  it('Is eligible for method 1 with country NL and product weight 100', async () => {
    const product = await server.app
      .get(ProductService)
      .update(ctx, { id: 1, customFields: { weight: 25 } });
    expect((product.customFields as any).weight).toBe(25);
    const order = await createSettledOrder(shopClient, 1);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shipping).toBe(111);
    expect(order.shippingWithTax).toBe(133);
  });
  it('Is eligible for method 1 with country NL and product weight 25 variant weight 50', async () => {
    const product = await server.app
      .get(ProductService)
      .update(ctx, { id: 1, customFields: { weight: 25 } });
    expect((product.customFields as any).weight).toBe(25);
    const productVariants = await server.app
      .get(ProductVariantService)
      .update(ctx, [{ id: 1, customFields: { weight: 50 } }]);
    expect(productVariants.length).toBe(1);
    expect((productVariants[0].customFields as any).weight).toBe(50);
    const order = await createSettledOrder(shopClient, 1);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shipping).toBe(111);
    expect(order.shippingWithTax).toBe(133);
  });
  it('Is eligible for method 1 with country NL and product weight 50 variant weight 0', async () => {
    const product = await server.app
      .get(ProductService)
      .update(ctx, { id: 1, customFields: { weight: 50 } });
    expect((product.customFields as any).weight).toBe(50);
    const productVariants = await server.app
      .get(ProductVariantService)
      .update(ctx, [{ id: 1, customFields: { weight: 0 } }]);
    expect(productVariants.length).toBe(1);
    expect((productVariants[0].customFields as any).weight).toBe(0);
    const order = await createSettledOrder(shopClient, 1);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shipping).toBe(111);
    expect(order.shippingWithTax).toBe(133);
  });
  it('Is NOT eligible for method 2 with country NL', async () => {
    await expect(createSettledOrder(shopClient, 2)).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
  });
  it('Is NOT eligible for method 1 and 2 with weight 200', async () => {
    const product = await server.app
      .get(ProductService)
      .update(ctx, { id: 1, customFields: { weight: 200 } });
    expect((product.customFields as any).weight).toBe(200);
    await expect(createSettledOrder(shopClient, 1)).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
    await expect(createSettledOrder(shopClient, 2)).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
  });
  it('Is NOT eligible for method 1 and 2 with variant weight 200', async () => {
    const product = await server.app
      .get(ProductService)
      .update(ctx, { id: 1, customFields: { weight: 0 } });
    expect((product.customFields as any).weight).toBe(0);
    const productVariants = await server.app
      .get(ProductVariantService)
      .update(ctx, [{ id: 1, customFields: { weight: 200 } }]);
    expect(productVariants.length).toBe(1);
    expect((productVariants[0].customFields as any).weight).toBe(200);
    await expect(createSettledOrder(shopClient, 1)).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
    await expect(createSettledOrder(shopClient, 2)).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
  });
});
describe('Distance based shipping calculator', function () {
  it('Should calculate distance based Shipping Price', async () => {
    const shippingAddressPostalCode = 'SW1W 0NY';
    const shippingAddressGeoLocation: GeoLocation = {
      longitude: -0.147421,
      latitude: 51.495373,
    };
    const storeGeoLocation: GeoLocation = {
      latitude: 51.5072,
      longitude: -0.118092,
    };
    const shippingAdress: CreateAddressInput = {
      countryCode: 'GB',
      streetLine1: 'London Street',
      postalCode: shippingAddressPostalCode,
    };
    nock(POSTCODES_URL)
      .get(`/${shippingAddressPostalCode}`)
      .reply(200, {
        data: {
          status: 200,
          result: {
            postcode: shippingAddressPostalCode,
            longitude: shippingAddressGeoLocation.longitude,
            latitude: shippingAddressGeoLocation.latitude,
          },
        },
      });
    const priceBasedShippingMethodArgs: DistanceBasedShippingCalculatorOptions =
      {
        storeLatitude: storeGeoLocation.latitude,
        storeLongitude: storeGeoLocation.longitude,
        pricePerKm: 10,
        fallbackPrice: 20,
        taxRate: 0,
      };
    const shippingDistance = getDistanceBetweenPointsInKMs(
      storeGeoLocation,
      shippingAddressGeoLocation
    );
    const expectedPrice = roundMoney(
      priceBasedShippingMethodArgs.pricePerKm * shippingDistance
    );
    const distanceBasedShippingMethod = await createDistanceBasedShippingMethod(
      adminClient,
      priceBasedShippingMethodArgs
    );
    expect(distanceBasedShippingMethod.id).toBeDefined();
    const order: any = await createSettledOrder(
      shopClient,
      distanceBasedShippingMethod.id,
      true,
      [
        { id: 'T_1', quantity: 1 },
        { id: 'T_2', quantity: 2 },
      ],
      undefined,
      { input: shippingAdress }
    );
    expect(order.shipping).toBe(expectedPrice);
  });
});
describe('Country based Promotion condition', function () {
  it('Creates promotion hat gives free shipping for orders in NL', async () => {
    const promotion = await createPromotion(adminClient, {
      input: {
        conditions: [
          {
            code: 'order_in_country',
            arguments: [
              {
                name: 'countries',
                value: '["NL"]',
              },
            ],
          },
        ],
        actions: [
          {
            code: 'free_shipping',
            arguments: [],
          },
        ],
        enabled: true,
        translations: [
          {
            languageCode: LanguageCode.En,
            name: 'Free Shipping for NL',
            customFields: {},
          },
        ],
        customFields: {},
      },
    });
    expect(promotion.name).toBe('Free Shipping for NL');
  });
  it('Order in NL should have free shipping', async () => {
    const order = await createSettledOrder(shopClient, 1, true, [
      {
        id: 'T_3',
        quantity: 1,
      },
    ]);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shippingWithTax).toBe(0);
  });
  it('Order in BE should NOT have free shipping', async () => {
    const order = await createSettledOrder(
      shopClient,
      1,
      true,
      [
        {
          id: 'T_3',
          quantity: 1,
        },
      ],
      undefined,
      {
        input: {
          countryCode: 'BE',
          streetLine1: 'Brussels Street',
        },
      }
    );
    expect(order.state).toBe('PaymentSettled');
    expect(order.shipping).toBe(111);
  });
});
describe('Shipping by facet and country eligibility checker', function () {
  let shippingMethodId: ID;
  it('Creates shipping method for NL and facet "limited" ', async () => {
    await adminClient.asSuperAdmin();
    const res = await createShippingMethodForCountriesAndFacets(adminClient, {
      facetIds: [4],
      countries: ['NL'],
      rate: 456,
      exclude: false,
    });
    shippingMethodId = res.id;
    expect(res.code).toBeDefined();
  });
  it('Is eligible for an order where all items have facet "limited"', async () => {
    const order = await createSettledOrder(shopClient, shippingMethodId, true, [
      { id: 'T_4', quantity: 1 },
    ]);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shippingLines[0].price).toBe(456);
  });
  it('Is not eligible for quantity 123, because of the custom strategy', async () => {
    ShippingExtensionsPlugin.options.additionalShippingEligibilityCheck =
      async (ctx, injector, order) => {
        if (order.totalQuantity === 123) {
          return false;
        } else {
          return true;
        }
      };
    const createSettledOrderPromise = createSettledOrder(
      shopClient,
      shippingMethodId,
      true,
      [{ id: 'T_4', quantity: 123 }]
    );
    await expect(createSettledOrderPromise).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
    ShippingExtensionsPlugin.options.additionalShippingEligibilityCheck =
      undefined;
  });
  it('Is not eligible for order that does not have facet "limited"', async () => {
    const createSettledOrderPromise = createSettledOrder(
      shopClient,
      shippingMethodId,
      true,
      [{ id: 'T_1', quantity: 1 }]
    );
    await expect(createSettledOrderPromise).rejects.toThrow(
      'ORDER_STATE_TRANSITION_ERROR'
    );
  });
});
describe('Flat Rate, tax by items in cart shipping calculator', function () {
  let shippingMethodId: ID;
  it('Creates flat rate shipping method', async () => {
    const res = await createFlatRateShippingMethod(adminClient, 123);
    shippingMethodId = res.id;
    expect(res.code).toBeDefined();
  });
  it('Calculates flat rate with tax based on items in cart', async () => {
    const order = await createSettledOrder(shopClient, shippingMethodId, true, [
      { id: 'T_1', quantity: 1 },
    ]);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shippingLines[0].price).toBe(123);
    expect(order.shippingLines[0].priceWithTax).toBe(123 + 25);
  });
  it('Calculates flat rate, with consumer defined surcharge ', async () => {
    ShippingExtensionsPlugin.options.flatRateSurchargeFn = () => 100;
    const order = await createSettledOrder(shopClient, shippingMethodId, true, [
      { id: 'T_1', quantity: 1 },
    ]);
    expect(order.state).toBe('PaymentSettled');
    expect(order.shippingLines[0].price).toBe(123 + 100);
    expect(order.shippingLines[0].priceWithTax).toBe(268);
    ShippingExtensionsPlugin.options.flatRateSurchargeFn = undefined;
  });
});
afterAll(async () => {
  await server.destroy();
}, 100000);
```

## File: packages/vendure-plugin-shipping-extensions/test/test-helpers.ts

```typescript
import { defaultShippingEligibilityChecker, Promotion } from '@vendure/core';
import { SimpleGraphQLClient } from '@vendure/testing';
import { gql } from 'graphql-tag';
import {
  CreatePromotion,
  CreatePromotionMutation,
  CreatePromotionMutationVariables,
} from '../../test/src/generated/admin-graphql';
import { distanceBasedShippingCalculator } from '../src/config/shipping/distance-based-shipping-calculator';
import { flatRateItemBasedShippingCalculator } from '../src';
const CREATE_SHIPPING_METHOD = gql`
  mutation CreateShippingMethod($input: CreateShippingMethodInput!) {
    createShippingMethod(input: $input) {
      ... on ShippingMethod {
        id
        code
      }
      __typename
    }
  }
`;
interface CountryAndWeightOptions {
  minWeight: number;
  maxWeight: number;
  countries: string[];
  exclude: boolean;
  rate: number;
}
export async function createShippingMethodForCountriesAndWeight(
  adminClient: SimpleGraphQLClient,
  options: CountryAndWeightOptions
) {
  const res = await adminClient.query(CREATE_SHIPPING_METHOD, {
    input: {
      code: 'shipping-by-weight-and-country',
      checker: {
        code: 'shipping-by-weight-and-country',
        arguments: [
          {
            name: 'minWeight',
            value: String(options.minWeight),
          },
          {
            name: 'maxWeight',
            value: String(options.maxWeight),
          },
          {
            name: 'countries',
            value: JSON.stringify(options.countries),
          },
          {
            name: 'excludeCountries',
            value: String(options.exclude),
          },
        ],
      },
      calculator: {
        code: 'flat-rate-item-based-shipping-calculator',
        arguments: [
          {
            name: 'rate',
            value: String(options.rate),
          },
          {
            name: 'includesTax',
            value: 'exclude',
          },
        ],
      },
      fulfillmentHandler: 'manual-fulfillment',
      customFields: {},
      translations: [
        {
          languageCode: 'en',
          name: 'Shipping by weight and country',
          description: '',
          customFields: {},
        },
      ],
    },
  });
  return res.createShippingMethod;
}
interface CountryAndFacetOptions {
  facetIds: string | number[];
  countries: string[];
  exclude: boolean;
  rate: number;
}
export async function createShippingMethodForCountriesAndFacets(
  adminClient: SimpleGraphQLClient,
  options: CountryAndFacetOptions
) {
  const res = await adminClient.query(CREATE_SHIPPING_METHOD, {
    input: {
      code: 'shipping-by-facets-and-country',
      checker: {
        code: 'shipping-by-facets-and-country',
        arguments: [
          {
            name: 'facets',
            value: JSON.stringify(options.facetIds),
          },
          {
            name: 'countries',
            value: JSON.stringify(options.countries),
          },
          {
            name: 'excludeCountries',
            value: String(options.exclude),
          },
        ],
      },
      calculator: {
        code: 'flat-rate-item-based-shipping-calculator',
        arguments: [
          {
            name: 'rate',
            value: String(options.rate),
          },
          {
            name: 'includesTax',
            value: 'exclude',
          },
        ],
      },
      fulfillmentHandler: 'manual-fulfillment',
      customFields: {},
      translations: [
        {
          languageCode: 'en',
          name: 'Shipping by facet and country',
          description: '',
          customFields: {},
        },
      ],
    },
  });
  return res.createShippingMethod;
}
export interface DistanceBasedShippingCalculatorOptions {
  storeLatitude: number;
  storeLongitude: number;
  pricePerKm: number;
  fallbackPrice: number;
  taxRate: number;
}
export async function createDistanceBasedShippingMethod(
  adminClient: SimpleGraphQLClient,
  options: DistanceBasedShippingCalculatorOptions
) {
  const res = await adminClient.query(CREATE_SHIPPING_METHOD, {
    input: {
      code: 'shipping-by-distance',
      checker: {
        code: defaultShippingEligibilityChecker.code,
        arguments: [{ name: 'orderMinimum', value: '0' }],
      },
      calculator: {
        code: distanceBasedShippingCalculator.code,
        arguments: [
          {
            name: 'storeLatitude',
            value: String(options.storeLatitude),
          },
          {
            name: 'storeLongitude',
            value: String(options.storeLongitude),
          },
          {
            name: 'taxRate',
            value: String(options.taxRate),
          },
          {
            name: 'pricePerKm',
            value: String(options.pricePerKm),
          },
        ],
      },
      fulfillmentHandler: 'manual-fulfillment',
      customFields: {},
      translations: [
        {
          languageCode: 'en',
          name: 'Shipping by Distance',
          description: 'Distance Based Shipping Method',
          customFields: {},
        },
      ],
    },
  });
  return res.createShippingMethod;
}
export async function createFlatRateShippingMethod(
  adminClient: SimpleGraphQLClient,
  amount: number
) {
  const res = await adminClient.query(CREATE_SHIPPING_METHOD, {
    input: {
      code: 'shipping-by-distance',
      checker: {
        code: defaultShippingEligibilityChecker.code,
        arguments: [{ name: 'orderMinimum', value: '0' }],
      },
      calculator: {
        code: flatRateItemBasedShippingCalculator.code,
        arguments: [
          {
            name: 'rate',
            value: String(amount),
          },
          {
            name: 'includesTax',
            value: 'exclude',
          },
        ],
      },
      fulfillmentHandler: 'manual-fulfillment',
      customFields: {},
      translations: [
        {
          languageCode: 'en',
          name: 'Standard Shipping',
          description: 'Flat Rate, Tax based on items in cart',
          customFields: {},
        },
      ],
    },
  });
  return res.createShippingMethod;
}
export async function createPromotion(
  adminClient: SimpleGraphQLClient,
  input: CreatePromotionMutationVariables
): Promise<Promotion> {
  const { createPromotion } = await adminClient.query<
    CreatePromotionMutation,
    CreatePromotionMutationVariables
  >(CreatePromotion, input);
  return createPromotion as Promotion;
}
```

## File: packages/vendure-plugin-stock-monitoring/src/api/low-stock.email-handler.ts

```typescript
import { EmailEventHandler, EmailEventListener } from '@vendure/email-plugin';
import {
  Injector,
  OrderLine,
  OrderPlacedEvent,
  RequestContext,
  StockLevelService,
  VendureEvent,
} from '@vendure/core';
type StockEmailRecipientsFn = (
  injector: Injector,
  event: VendureEvent
) => Promise<string[]> | string[];
export interface LowStockEmailOptions {
  threshold: number;
  emailRecipients: string[] | StockEmailRecipientsFn;
  subject: string;
}
export function createLowStockEmailHandler({
  threshold,
  subject,
  emailRecipients,
}: LowStockEmailOptions): EmailEventHandler<any, any> {
  let stockLevelService: StockLevelService;
  return new EmailEventListener('low-stock')
    .on(OrderPlacedEvent)
    .loadData(async ({ event, injector }) => {
      stockLevelService = injector.get(StockLevelService);
      const dropped = !!event.order.lines.find(
        async (line) =>
          await droppedBelowThreshold(
            threshold,
            line,
            event.ctx,
            stockLevelService
          )
      );
      if (Array.isArray(emailRecipients)) {
        return { adminRecipients: emailRecipients };
      }
      return {
        adminRecipients: dropped ? await emailRecipients(injector, event) : [],
      };
    })
    .setRecipient((event) => event.data.adminRecipients.join(','))
    .setFrom(`{{ fromAddress }}`)
    .setSubject(subject)
    .setTemplateVars((event) => {
      const lines = event.order.lines.filter(
        async (line) =>
          await droppedBelowThreshold(
            threshold,
            line,
            event.ctx,
            stockLevelService
          )
      );
      return {
        lines,
      };
    });
}
export async function droppedBelowThreshold(
  threshold: number,
  line: OrderLine,
  ctx: RequestContext,
  stockLevelService: StockLevelService
): Promise<boolean> {
  const { productVariant, quantity } = line;
  const variantStocks = await stockLevelService.getAvailableStock(
    ctx,
    productVariant.id
  );
  const stockAfterOrder = variantStocks.stockOnHand;
  const stockBeforeOrder = stockAfterOrder + quantity;
  return stockAfterOrder <= threshold && stockBeforeOrder >= threshold;
}
```

## File: packages/vendure-plugin-stock-monitoring/src/api/stock-monitoring.resolver.ts

```typescript
import { Query, Resolver } from '@nestjs/graphql';
import {
  Ctx,
  ProductVariant,
  RequestContext,
  TransactionalConnection,
  Permission,
  Allow,
} from '@vendure/core';
import { StockMonitoringPlugin } from '../stock-monitoring.plugin';
@Resolver()
export class StockMonitoringResolver {
  constructor(private connection: TransactionalConnection) {}
  @Query()
  @Allow(Permission.ReadCatalog)
  async productVariantsWithLowStock(
    @Ctx() ctx: RequestContext
  ): Promise<ProductVariant[]> {
    return this.connection
      .getRepository(ctx, ProductVariant)
      .createQueryBuilder('variant')
      .leftJoin('variant.product', 'product')
      .leftJoin('variant.stockLevels', 'stockLevel')
      .addGroupBy('variant.id')
      .addSelect('SUM(stockLevel.stockOnHand)', 'stockOnHand')
      .addSelect('SUM(stockLevel.stockAllocated)', 'stockAllocated')
      .leftJoin('product.channels', 'channel')
      .where('variant.enabled = true')
      .andWhere('"stockOnHand" - "stockAllocated" < :threshold', {
        threshold: StockMonitoringPlugin.threshold,
      })
      .andWhere('variant.deletedAt IS NULL')
      .andWhere('channel.id = :channelId', { channelId: ctx.channelId })
      .limit(100)
      .orderBy('"stockOnHand"', 'ASC')
      .getMany();
  }
}
```

## File: packages/vendure-plugin-stock-monitoring/src/ui/providers.ts

```typescript
import {
  registerDashboardWidget,
  setDashboardWidgetLayout,
} from '@vendure/admin-ui/core';
export default [
  registerDashboardWidget('stock-levels', {
    title: 'Low stock',
    supportedWidths: [4, 6, 8, 12],
    loadComponent: () =>
      import('./stock-widget').then((m) => m.StockWidgetComponent),
  }),
  setDashboardWidgetLayout([
    { id: 'welcome', width: 12 },
    { id: 'orderSummary', width: 6 },
    { id: 'reviews', width: 6 },
    { id: 'latestOrders', width: 12 },
  ]),
];
```

## File: packages/vendure-plugin-stock-monitoring/src/ui/stock-widget.ts

```typescript
import { Component, NgModule, OnInit } from '@angular/core';
import { DataService, SharedModule } from '@vendure/admin-ui/core';
import { ProductVariant } from '@vendure/core';
import { Observable } from 'rxjs';
import gql from 'graphql-tag';
@Component({
  standalone: true,
  imports: [SharedModule],
  selector: 'stock-widget',
  template: `
    <vdr-data-table [items]="variant$ | async" class="stock-widget-overflow">
      <ng-template let-variant="item">
        <td
          class="left align-middle"
          [class.out-of-stock]="!variant.stockOnHand"
        >
          <a [routerLink]="['/catalog', 'inventory', variant.productId]">{{
            variant.name
          }}</a>
        </td>
        <td
          class="left align-middle"
          [class.out-of-stock]="!variant.stockOnHand"
        >
          {{ reduceSum(variant.stockLevels) }}
        </td>
      </ng-template>
    </vdr-data-table>
  `,
  styles: [
    '.out-of-stock { background-color: #FCE2DE;}',
    '.stock-widget-overflow { max-height: 300px; overflow: scroll; }',
  ],
})
export class StockWidgetComponent implements OnInit {
  constructor(private dataService: DataService) {}
  variant$: Observable<ProductVariant[]>;
  ngOnInit() {
    this.variant$ = this.dataService
      .query(
        gql`
          query productVariantsWithLowStock {
            productVariantsWithLowStock {
              id
              name
              enabled
              stockOnHand
              productId
              stockLevels {
                stockOnHand
              }
            }
          }
        `
      )
      .mapStream((data) => (data as any).productVariantsWithLowStock);
  }
  reduceSum(stockLevels: any[]): number {
    return stockLevels.reduce((acc, val) => (acc += val.stockOnHand), 0);
  }
}
```

## File: packages/vendure-plugin-stock-monitoring/src/stock-monitoring.plugin.ts

```typescript
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { gql } from 'graphql-tag';
import { StockMonitoringResolver } from './api/stock-monitoring.resolver';
export * from './api/low-stock.email-handler';
export interface StockMonitoringPlugin {
  threshold: number;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  adminApiExtensions: {
    schema: gql`
      extend type Query {
        productVariantsWithLowStock: [ProductVariant!]!
      }
    `,
    resolvers: [StockMonitoringResolver],
  },
  compatibility: '>=2.2.0',
})
export class StockMonitoringPlugin {
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    providers: ['providers.ts'],
  };
  static threshold = 10;
  static init(options: StockMonitoringPlugin): typeof StockMonitoringPlugin {
    this.threshold = options.threshold;
    return StockMonitoringPlugin;
  }
}
```

## File: packages/vendure-plugin-stock-monitoring/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LanguageCode,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { StockMonitoringPlugin } from '../src/stock-monitoring.plugin';
import path from 'path';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    plugins: [
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: compileUiExtensions({
          outputPath: path.join(__dirname, '__admin-ui'),
          extensions: [StockMonitoringPlugin.ui],
          devMode: true,
        }),
      }),
      StockMonitoringPlugin.init({
        threshold: 10,
      }),
    ],
  });
  const { server, shopClient } = createTestEnvironment(config);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-stock-monitoring/test/stock.spec.ts

```typescript
import {
  ClientError,
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { initialData } from '../../test/src/initial-data';
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import { EmailPlugin } from '@vendure/email-plugin';
import { TestServer } from '@vendure/testing/lib/test-server';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import gql from 'graphql-tag';
import { StockMonitoringPlugin } from '../src/stock-monitoring.plugin';
import { createLowStockEmailHandler } from '../src/api/low-stock.email-handler';
import * as path from 'path';
import { createSettledOrder } from '../../test/src/shop-utils';
import * as fs from 'fs';
import { expect, describe, beforeAll, it, afterAll } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
describe('Stock monitoring plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  const testEmailDir = path.join(__dirname, './test-emails');
  const emailHandlerConfig = {
    subject: 'Low stock',
    threshold: 100,
  };
  beforeAll(async () => {
    try {
      const files = fs.readdirSync(testEmailDir);
      for (const file of files) {
        fs.unlinkSync(path.join(testEmailDir, file));
      }
    } catch (err) {}
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        StockMonitoringPlugin.init({ threshold: 101 }),
        EmailPlugin.init({
          handlers: [
            createLowStockEmailHandler({
              ...emailHandlerConfig,
              emailRecipients: async () => ['test@test.com'],
            }),
            createLowStockEmailHandler({
              ...emailHandlerConfig,
              emailRecipients: () => ['test@test.com'],
            }),
            createLowStockEmailHandler({
              ...emailHandlerConfig,
              emailRecipients: ['test@test.com'],
            }),
          ],
          route: 'mailbox',
          templatePath: path.join(__dirname, './templates/'),
          outputPath: testEmailDir,
          devMode: true,
        }),
      ],
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
    });
    serverStarted = true;
  }, 60000);
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Fails for unauthenticated call', async () => {
    const queryPromise = adminClient.query(gql`
      query productVariantsWithLowStock {
        productVariantsWithLowStock {
          name
        }
      }
    `);
    await expect(queryPromise).rejects.toThrow(ClientError);
  });
  it('Gets variants with stocklevels below threshold', async () => {
    await adminClient.asSuperAdmin();
    const { productVariantsWithLowStock } = await adminClient.query(
      GET_OUT_OF_STOCK_VARIANTS
    );
    expect(productVariantsWithLowStock.length).toBe(4);
    expect(productVariantsWithLowStock[0].name).toBeDefined();
    expect(productVariantsWithLowStock[0].enabled).toBe(true);
    expect(productVariantsWithLowStock[0].stockOnHand).toBeLessThan(101);
    expect(productVariantsWithLowStock[0].productId).toBeDefined();
  });
  it('Does not return variants with stock above threshold', async () => {
    await adminClient.asSuperAdmin();
    await adminClient.query(gql`
      mutation updateProductVariants {
        updateProductVariants(input: [{ id: 1, stockOnHand: 105 }]) {
          id
        }
      }
    `);
    const { productVariantsWithLowStock } = await adminClient.query(
      GET_OUT_OF_STOCK_VARIANTS
    );
    expect(productVariantsWithLowStock.length).toBe(3);
  });
  it('Sends an email when stock is low after order placement', async () => {
    await createSettledOrder(shopClient, 1);
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for event handling
    const files = fs.readdirSync(testEmailDir);
    expect(files.length).toBe(3); // 3 emails should be sent, one for every handler
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(
        __dirname,
        StockMonitoringPlugin.ui
      );
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
    afterAll(async () => {
      await server.destroy();
    }, 100000);
  }
});
export const GET_OUT_OF_STOCK_VARIANTS = gql`
  query productVariantsWithLowStock {
    productVariantsWithLowStock {
      name
      enabled
      stockOnHand
      productId
    }
  }
`;
```

## File: packages/vendure-plugin-stripe-subscription/src/api/types/stripe-invoice.ts

```typescript
import { Metadata } from './stripe.common';
export interface StripeInvoice {
  id: string;
  object: string;
  account_country: string;
  account_name: string;
  account_tax_ids: any;
  amount_due: number;
  amount_paid: number;
  amount_remaining: number;
  amount_shipping: number;
  application: any;
  application_fee_amount: any;
  attempt_count: number;
  attempted: boolean;
  auto_advance: boolean;
  automatic_tax: AutomaticTax;
  billing_reason: string;
  charge: any;
  collection_method: string;
  created: number;
  currency: string;
  custom_fields: any;
  customer: string;
  customer_address: any;
  customer_email: string;
  customer_name: string;
  customer_phone: any;
  customer_shipping: any;
  customer_tax_exempt: string;
  customer_tax_ids: any[];
  default_payment_method: any;
  default_source: any;
  default_tax_rates: any[];
  description: string;
  discount: any;
  discounts: any[];
  due_date: any;
  effective_at: number;
  ending_balance: number;
  footer: any;
  from_invoice: any;
  hosted_invoice_url: string;
  invoice_pdf: string;
  last_finalization_error: any;
  latest_revision: any;
  lines: Lines;
  livemode: boolean;
  metadata: Metadata;
  next_payment_attempt: any;
  number: string;
  on_behalf_of: any;
  paid: boolean;
  paid_out_of_band: boolean;
  payment_intent: any;
  payment_settings: PaymentSettings;
  period_end: number;
  period_start: number;
  post_payment_credit_notes_amount: number;
  pre_payment_credit_notes_amount: number;
  quote: any;
  receipt_number: any;
  rendering_options: any;
  shipping_cost: any;
  shipping_details: any;
  starting_balance: number;
  statement_descriptor: any;
  status: string;
  status_transitions: StatusTransitions;
  subscription: string;
  subscription_details: SubscriptionDetails;
  subtotal: number;
  subtotal_excluding_tax: number;
  tax: any;
  test_clock: any;
  total: number;
  total_discount_amounts: any[];
  total_excluding_tax: number;
  total_tax_amounts: any[];
  transfer_data: any;
  webhooks_delivered_at: number;
}
export interface AutomaticTax {
  enabled: boolean;
  status: any;
}
export interface Lines {
  object: string;
  data: Daum[];
  has_more: boolean;
  total_count: number;
  url: string;
}
export interface Daum {
  id: string;
  object: string;
  amount: number;
  amount_excluding_tax: number;
  currency: string;
  description: string;
  discount_amounts: any[];
  discountable: boolean;
  discounts: any[];
  livemode: boolean;
  metadata: Metadata;
  period: Period;
  plan: Plan;
  price: Price;
  proration: boolean;
  proration_details: ProrationDetails;
  quantity: number;
  subscription: string;
  subscription_item: string;
  tax_amounts: any[];
  tax_rates: any[];
  type: string;
  unit_amount_excluding_tax: string;
}
export interface Period {
  end: number;
  start: number;
}
export interface Plan {
  id: string;
  object: string;
  active: boolean;
  aggregate_usage: any;
  amount: number;
  amount_decimal: string;
  billing_scheme: string;
  created: number;
  currency: string;
  interval: string;
  interval_count: number;
  livemode: boolean;
  metadata: Metadata;
  nickname: any;
  product: string;
  tiers_mode: any;
  transform_usage: any;
  trial_period_days: any;
  usage_type: string;
}
export interface Price {
  id: string;
  object: string;
  active: boolean;
  billing_scheme: string;
  created: number;
  currency: string;
  custom_unit_amount: any;
  livemode: boolean;
  lookup_key: any;
  metadata: Metadata;
  nickname: any;
  product: string;
  recurring: Recurring;
  tax_behavior: string;
  tiers_mode: any;
  transform_quantity: any;
  type: string;
  unit_amount: number;
  unit_amount_decimal: string;
}
export interface Recurring {
  aggregate_usage: any;
  interval: string;
  interval_count: number;
  trial_period_days: any;
  usage_type: string;
}
export interface ProrationDetails {
  credited_items: any;
}
export interface PaymentSettings {
  default_mandate: any;
  payment_method_options: any;
  payment_method_types: any;
}
export interface StatusTransitions {
  finalized_at: number;
  marked_uncollectible_at: any;
  paid_at: number;
  voided_at: any;
}
export interface SubscriptionDetails {
  metadata: Metadata;
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/types/stripe-payment-intent.ts

```typescript
import { Metadata } from './stripe.common';
export interface StripePaymentIntent {
  id: string;
  object: string;
  amount: number;
  amount_capturable: number;
  amount_details: AmountDetails;
  amount_received: number;
  application: any;
  application_fee_amount: any;
  automatic_payment_methods: any;
  canceled_at: any;
  cancellation_reason: any;
  capture_method: string;
  charges: Charges;
  client_secret: string;
  confirmation_method: string;
  created: number;
  currency: string;
  customer: string;
  description: any;
  invoice: any;
  last_payment_error: any;
  latest_charge: string;
  livemode: boolean;
  metadata: Metadata;
  next_action: any;
  on_behalf_of: any;
  payment_method: string;
  payment_method_options: PaymentMethodOptions;
  payment_method_types: string[];
  processing: any;
  receipt_email: string;
  review: any;
  setup_future_usage: string;
  shipping: any;
  source: any;
  statement_descriptor: any;
  statement_descriptor_suffix: any;
  status: string;
  transfer_data: any;
  transfer_group: any;
}
export interface StripeSetupIntent {
  id: string;
  object: string;
  application: any;
  automatic_payment_methods: any;
  cancellation_reason: any;
  client_secret: string;
  created: number;
  customer: string;
  description: any;
  flow_directions: any;
  last_setup_error: any;
  latest_attempt: any;
  livemode: boolean;
  mandate: any;
  metadata: Metadata;
  next_action: any;
  on_behalf_of: any;
  payment_method: any;
  payment_method_configuration_details: any;
  payment_method_options: PaymentMethodOptions;
  payment_method_types: string[];
  single_use_mandate: any;
  status: string;
  usage: string;
}
export interface AmountDetails {
  tip: Tip;
}
export interface Tip {}
export interface Charges {
  object: string;
  data: Daum[];
  has_more: boolean;
  total_count: number;
  url: string;
}
export interface Daum {
  id: string;
  object: string;
  amount: number;
  amount_captured: number;
  amount_refunded: number;
  application: any;
  application_fee: any;
  application_fee_amount: any;
  balance_transaction: string;
  billing_details: BillingDetails;
  calculated_statement_descriptor: string;
  captured: boolean;
  created: number;
  currency: string;
  customer: string;
  description: any;
  destination: any;
  dispute: any;
  disputed: boolean;
  failure_balance_transaction: any;
  failure_code: any;
  failure_message: any;
  fraud_details: FraudDetails;
  invoice: any;
  livemode: boolean;
  metadata: Metadata;
  on_behalf_of: any;
  order: any;
  outcome: Outcome;
  paid: boolean;
  payment_intent: string;
  payment_method: string;
  payment_method_details: PaymentMethodDetails;
  receipt_email: string;
  receipt_number: any;
  receipt_url: string;
  refunded: boolean;
  refunds: Refunds;
  review: any;
  shipping: any;
  source: any;
  source_transfer: any;
  statement_descriptor: any;
  statement_descriptor_suffix: any;
  status: string;
  transfer_data: any;
  transfer_group: any;
}
export interface BillingDetails {
  address: Address;
  email: any;
  name: any;
  phone: any;
}
export interface Address {
  city: any;
  country: string;
  line1: any;
  line2: any;
  postal_code: any;
  state: any;
}
export interface FraudDetails {}
export interface Outcome {
  network_status: string;
  reason: any;
  risk_level: string;
  risk_score: number;
  seller_message: string;
  type: string;
}
export interface PaymentMethodDetails {
  card: Card;
  type: string;
}
export interface Card {
  brand: string;
  checks: Checks;
  country: string;
  exp_month: number;
  exp_year: number;
  fingerprint: string;
  funding: string;
  installments: any;
  last4: string;
  mandate: any;
  network: string;
  network_token: NetworkToken;
  three_d_secure: any;
  wallet: any;
}
export interface Checks {
  address_line1_check: any;
  address_postal_code_check: any;
  cvc_check: string;
}
export interface NetworkToken {
  used: boolean;
}
export interface Refunds {
  object: string;
  data: any[];
  has_more: boolean;
  total_count: number;
  url: string;
}
export interface PaymentMethodOptions {
  card: Card2;
}
export interface Card2 {
  installments: any;
  mandate_options: any;
  network: any;
  request_three_d_secure: string;
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/types/stripe.common.ts

```typescript
import { StripeInvoice } from './stripe-invoice';
import { StripePaymentIntent } from './stripe-payment-intent';
export interface Metadata {
  orderCode: string;
  channelToken: string;
  paymentMethodCode: string;
  amount: number;
}
export interface Data {
  object: StripeInvoice | StripePaymentIntent;
}
export interface Request {
  id?: any;
  idempotency_key?: any;
}
export interface IncomingStripeWebhook {
  id: string;
  object: string;
  api_version: string;
  created: number;
  data: Data;
  livemode: boolean;
  pending_webhooks: number;
  request: Request;
  type: string;
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/vendure-config/custom-fields.ts

```typescript
import { CustomFieldConfig, LanguageCode } from '@vendure/core';
export const orderLineCustomFields: CustomFieldConfig[] = [
  {
    name: 'subscriptionIds',
    label: [
      {
        languageCode: LanguageCode.en,
        value: 'Subscription IDs',
      },
    ],
    type: 'string',
    list: true,
    public: false,
    readonly: true,
    internal: true,
    nullable: true,
  },
];
```

## File: packages/vendure-plugin-stripe-subscription/src/api/vendure-config/has-stripe-subscription-products-payment-checker.ts

```typescript
import {
  Injector,
  LanguageCode,
  Order,
  PaymentMethodEligibilityChecker,
} from '@vendure/core';
import { StripeSubscriptionService } from '../stripe-subscription.service';
let stripeSubscriptionService: StripeSubscriptionService;
export const hasStripeSubscriptionProductsPaymentChecker =
  new PaymentMethodEligibilityChecker({
    code: 'has-stripe-subscription-products-checker',
    description: [
      {
        languageCode: LanguageCode.en,
        value: 'Checks if the order has Subscription products.',
      },
    ],
    args: {},
    init: (injector: Injector) => {
      stripeSubscriptionService = injector.get(StripeSubscriptionService);
    },
    check: async (ctx, order, args) => {
      if (
        await stripeSubscriptionService.subscriptionHelper.hasSubscriptions(
          ctx,
          order
        )
      ) {
        return true;
      }
      return false;
    },
  });
```

## File: packages/vendure-plugin-stripe-subscription/src/api/vendure-config/stripe-subscription.handler.ts

```typescript
import {
  CreatePaymentResult,
  CreateRefundResult,
  Injector,
  LanguageCode,
  Logger,
  PaymentMethodHandler,
  SettlePaymentResult,
} from '@vendure/core';
import { loggerCtx } from '../../constants';
import { StripeSubscriptionService } from '../stripe-subscription.service';
import { printMoney } from '../util';
let service: StripeSubscriptionService;
export const stripeSubscriptionHandler = new PaymentMethodHandler({
  code: 'stripe-subscription',
  description: [
    {
      languageCode: LanguageCode.en,
      value: 'Stripe Subscription',
    },
  ],
  args: {
    apiKey: {
      type: 'string',
      label: [{ languageCode: LanguageCode.en, value: 'API key' }],
      ui: { component: 'password-form-input' },
    },
    publishableKey: {
      type: 'string',
      required: false,
      label: [{ languageCode: LanguageCode.en, value: 'Publishable key' }],
      description: [
        {
          languageCode: LanguageCode.en,
          value: 'For use in the storefront only.',
        },
      ],
    },
    webhookSecret: {
      type: 'string',
      required: false,
      label: [
        {
          languageCode: LanguageCode.en,
          value: 'Webhook secret',
        },
      ],
      description: [
        {
          languageCode: LanguageCode.en,
          value:
            'Secret to validate incoming webhooks. Get this from he created webhooks in your Stripe dashboard',
        },
      ],
      ui: { component: 'password-form-input' },
    },
  },
  init(injector: Injector) {
    service = injector.get(StripeSubscriptionService);
  },
  async createPayment(
    ctx,
    order,
    amount,
    _,
    metadata
  ): Promise<CreatePaymentResult> {
    if (ctx.apiType !== 'admin') {
      throw Error(`CreatePayment is not allowed for apiType '${ctx.apiType}'`);
    }
    return {
      amount: metadata.amount,
      state: 'Settled',
      transactionId: metadata.setupIntentId,
      metadata,
    };
  },
  settlePayment(): SettlePaymentResult {
    return {
      success: true,
    };
  },
  async createRefund(
    ctx,
    input,
    amount,
    order,
    payment,
    args
  ): Promise<CreateRefundResult> {
    const { stripeClient } = await service.getStripeContext(ctx);
    const refund = await stripeClient.refunds.create({
      payment_intent: payment.transactionId,
      amount,
    });
    Logger.info(
      `Refund of ${printMoney(amount)} created for payment ${
        payment.transactionId
      } for order ${order.id}`,
      loggerCtx
    );
    await service.logHistoryEntry(
      ctx,
      order.id,
      `Created refund of ${printMoney(amount)}`
    );
    return {
      state: 'Settled',
      metadata: refund,
    };
  },
});
```

## File: packages/vendure-plugin-stripe-subscription/src/api/admin-graphql.ts

```typescript
import { gql } from 'graphql-tag';
import { commonSchemaExtensions } from './common-graphql';
export const adminApiSchemaExtensions = gql`
  ${commonSchemaExtensions}
  extend type Mutation {
    createStripeSubscriptionIntent(orderId: ID!): StripeSubscriptionIntent!
  }
`;
```

## File: packages/vendure-plugin-stripe-subscription/src/api/common-graphql.ts

```typescript
import { gql } from 'graphql-tag';
const _codegenAdditions = gql`
  scalar DateTime
  scalar JSON
`;
export const commonSchemaExtensions = gql`
  enum StripeSubscriptionInterval {
    week
    month
    year
  }
  type StripeSubscription {
    name: String!
    variantId: ID!
    amountDueNow: Int!
    priceIncludesTax: Boolean!
    recurring: StripeSubscriptionRecurringPayment!
  }
  type StripeSubscriptionRecurringPayment {
    amount: Int!
    interval: StripeSubscriptionInterval!
    intervalCount: Int!
    startDate: DateTime!
    endDate: DateTime
  }
  enum StripeSubscriptionIntentType {
    PaymentIntent
    SetupIntent
  }
  type StripeSubscriptionIntent {
    clientSecret: String!
    intentType: StripeSubscriptionIntentType!
  }
  extend type PaymentMethodQuote {
    stripeSubscriptionPublishableKey: String
  }
  extend type OrderLine {
    """
    These subscriptions are calculated dynamically, and should not be used for historical data.
    Actual created subscriptions should be fetched from he connected Stripe account.
    """
    stripeSubscriptions: [StripeSubscription!]
  }
  extend type Query {
    previewStripeSubscriptions(
      productVariantId: ID!
      customInputs: JSON
    ): [StripeSubscription!]!
    previewStripeSubscriptionsForProduct(
      productId: ID!
      customInputs: JSON
    ): [StripeSubscription!]!
  }
`;
```

## File: packages/vendure-plugin-stripe-subscription/src/api/shop-graphql.ts

```typescript
import { gql } from 'graphql-tag';
import { commonSchemaExtensions } from './common-graphql';
export const shopApiSchemaExtensions = gql`
  ${commonSchemaExtensions}
  extend type Mutation {
    createStripeSubscriptionIntent: StripeSubscriptionIntent!
  }
`;
```

## File: packages/vendure-plugin-stripe-subscription/src/api/stripe-subscription.controller.ts

```typescript
import { Body, Controller, Headers, Inject, Post, Req } from '@nestjs/common';
import { Logger, OrderService } from '@vendure/core';
import { Request } from 'express';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { StripeSubscriptionPluginOptions } from '../stripe-subscription.plugin';
import { StripeSubscriptionService } from './stripe-subscription.service';
import { StripeInvoice } from './types/stripe-invoice';
import {
  StripePaymentIntent,
  StripeSetupIntent,
} from './types/stripe-payment-intent';
import { IncomingStripeWebhook } from './types/stripe.common';
export type RequestWithRawBody = Request & { rawBody: any };
@Controller('stripe-subscriptions')
export class StripeSubscriptionController {
  constructor(
    private stripeSubscriptionService: StripeSubscriptionService,
    private orderService: OrderService,
    @Inject(PLUGIN_INIT_OPTIONS)
    private options: StripeSubscriptionPluginOptions
  ) {}
  @Post('webhook')
  async webhook(
    @Headers('stripe-signature') signature: string | undefined,
    @Req() request: RequestWithRawBody
  ): Promise<void> {
    const body = JSON.parse(request.body.toString()) as IncomingStripeWebhook;
    Logger.info(`Incoming webhook ${body.type}`, loggerCtx);
    const orderCode =
      body.data.object.metadata?.orderCode ??
      (body.data.object as StripeInvoice).lines?.data[0]?.metadata.orderCode;
    const channelToken =
      body.data.object.metadata?.channelToken ??
      (body.data.object as StripeInvoice).lines?.data[0]?.metadata.channelToken;
    if (!StripeSubscriptionService.webhookEvents.includes(body.type as any)) {
      Logger.info(
        `Received incoming '${body.type}' webhook, not processing this event.`,
        loggerCtx
      );
      return;
    }
    if (!orderCode || !channelToken) {
      return Logger.info(
        `Incoming webhook is missing metadata.orderCode/channelToken, ignoring. We should receive another one with metadata...`,
        loggerCtx
      );
    }
    try {
      const ctx = await this.stripeSubscriptionService.createContext(
        channelToken,
        request
      );
      const order = await this.orderService.findOneByCode(ctx, orderCode);
      if (!order) {
        throw Error(`Cannot find order with code ${orderCode}`);
      }
      const { stripeClient } =
        await this.stripeSubscriptionService.getStripeContext(ctx);
      if (!this.options?.disableWebhookSignatureChecking) {
        stripeClient.validateWebhookSignature(request.rawBody, signature);
      }
      if (
        body.type === 'payment_intent.succeeded' ||
        body.type === 'setup_intent.succeeded'
      ) {
        await this.stripeSubscriptionService.handleIntentSucceeded(
          ctx,
          body.data.object as StripePaymentIntent & StripeSetupIntent,
          order
        );
      } else if (
        body.type === 'invoice.payment_failed' ||
        body.type === 'invoice.payment_action_required'
      ) {
        const invoiceObject = body.data.object as StripeInvoice;
        await this.stripeSubscriptionService.handleInvoicePaymentFailed(
          ctx,
          invoiceObject,
          order
        );
      }
      Logger.info(`Successfully handled webhook ${body.type}`, loggerCtx);
    } catch (error) {
      Logger.error(
        `Failed to process incoming webhook ${body.type} (${body.id}): ${
          (error as Error)?.message
        }`,
        loggerCtx,
        (error as Error)?.stack
      );
      throw error;
    }
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/stripe-subscription.resolver.ts

```typescript
import {
  Args,
  Mutation,
  Parent,
  Query,
  ResolveField,
  Resolver,
} from '@nestjs/graphql';
import { PaymentMethodQuote } from '@vendure/common/lib/generated-shop-types';
import {
  Allow,
  Ctx,
  EntityHydrator,
  OrderLine,
  PaymentMethodService,
  Permission,
  ProductPriceApplicator,
  RequestContext,
  UserInputError,
} from '@vendure/core';
import { Request } from 'express';
import {
  Mutation as GraphqlShopMutation,
  Query as GraphqlQuery,
  QueryPreviewStripeSubscriptionsArgs,
  QueryPreviewStripeSubscriptionsForProductArgs,
  StripeSubscription,
} from './generated/shop-graphql';
import {
  Mutation as GraphqlAdminMutation,
  MutationCreateStripeSubscriptionIntentArgs,
} from './generated/admin-graphql';
import { StripeSubscriptionService } from './stripe-subscription.service';
export type RequestWithRawBody = Request & { rawBody: any };
@Resolver()
export class StripeSubscriptionCommonResolver {
  constructor(
    private stripeSubscriptionService: StripeSubscriptionService,
    private paymentMethodService: PaymentMethodService,
    private entityHydrator: EntityHydrator,
    private productPriceApplicator: ProductPriceApplicator
  ) {}
  @Query()
  async previewStripeSubscriptions(
    @Ctx() ctx: RequestContext,
    @Args()
    { productVariantId, customInputs }: QueryPreviewStripeSubscriptionsArgs
  ): Promise<GraphqlQuery['previewStripeSubscriptions']> {
    return this.stripeSubscriptionService.subscriptionHelper.previewSubscription(
      ctx,
      productVariantId,
      customInputs
    );
  }
  @Query()
  async previewStripeSubscriptionsForProduct(
    @Ctx() ctx: RequestContext,
    @Args()
    { productId, customInputs }: QueryPreviewStripeSubscriptionsForProductArgs
  ): Promise<GraphqlQuery['previewStripeSubscriptionsForProduct']> {
    return this.stripeSubscriptionService.subscriptionHelper.previewSubscriptionsForProduct(
      ctx,
      productId,
      customInputs
    );
  }
  @ResolveField('stripeSubscriptionPublishableKey')
  @Resolver('PaymentMethodQuote')
  async stripeSubscriptionPublishableKey(
    @Ctx() ctx: RequestContext,
    @Parent() paymentMethodQuote: PaymentMethodQuote
  ): Promise<string | undefined> {
    const paymentMethod = await this.paymentMethodService.findOne(
      ctx,
      paymentMethodQuote.id
    );
    return paymentMethod?.handler.args.find((a) => a.name === 'publishableKey')
      ?.value;
  }
  @ResolveField('stripeSubscriptions')
  @Resolver('OrderLine')
  async stripeSubscriptions(
    @Ctx() ctx: RequestContext,
    @Parent() orderLine: OrderLine
  ): Promise<StripeSubscription[] | undefined> {
    await this.entityHydrator.hydrate(ctx, orderLine, {
      relations: ['order', 'productVariant'],
    });
    await this.entityHydrator.hydrate(ctx, orderLine.productVariant, {
      relations: ['productVariantPrices', 'taxCategory'],
    });
    await this.productPriceApplicator.applyChannelPriceAndTax(
      orderLine.productVariant,
      ctx,
      orderLine.order
    );
    const subscriptionsForOrderLine =
      await this.stripeSubscriptionService.subscriptionHelper.getSubscriptionsForOrderLine(
        ctx,
        orderLine,
        orderLine.order
      );
    return subscriptionsForOrderLine.map((s) => ({
      ...s,
      variantId: orderLine.productVariant.id,
    }));
  }
}
@Resolver()
export class StripeSubscriptionShopApiResolver {
  constructor(private stripeSubscriptionService: StripeSubscriptionService) {}
  @Mutation()
  @Allow(Permission.Owner)
  async createStripeSubscriptionIntent(
    @Ctx() ctx: RequestContext
  ): Promise<GraphqlShopMutation['createStripeSubscriptionIntent']> {
    const res = await this.stripeSubscriptionService.createIntent(ctx);
    return res;
  }
}
@Resolver()
export class StripeSubscriptionAdminApiResolver {
  constructor(private stripeSubscriptionService: StripeSubscriptionService) {}
  @Mutation()
  @Allow(Permission.Owner)
  async createStripeSubscriptionIntent(
    @Ctx() ctx: RequestContext,
    @Args() args: MutationCreateStripeSubscriptionIntentArgs
  ): Promise<GraphqlAdminMutation['createStripeSubscriptionIntent']> {
    const res = await this.stripeSubscriptionService.createIntentForDraftOrder(
      ctx,
      args.orderId
    );
    return res;
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/stripe-subscription.service.ts

```typescript
import { Inject, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { StockMovementType } from '@vendure/common/lib/generated-types';
import {
  ActiveOrderService,
  ChannelService,
  EntityHydrator,
  EntityNotFoundError,
  ErrorResult,
  EventBus,
  HistoryService,
  ID,
  JobQueue,
  JobQueueService,
  LanguageCode,
  Logger,
  Order,
  OrderLine,
  OrderLineEvent,
  OrderService,
  OrderStateTransitionError,
  PaymentMethod,
  PaymentMethodEvent,
  PaymentMethodService,
  ProductVariantService,
  RequestContext,
  SerializedRequestContext,
  StockMovementEvent,
  TransactionalConnection,
  UserInputError,
} from '@vendure/core';
import { Cancellation } from '@vendure/core/dist/entity/stock-movement/cancellation.entity';
import { Release } from '@vendure/core/dist/entity/stock-movement/release.entity';
import { randomUUID } from 'crypto';
import { Request } from 'express';
import { filter } from 'rxjs/operators';
import Stripe from 'stripe';
import { Subscription, SubscriptionHelper } from '../';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { StripeSubscriptionPluginOptions } from '../stripe-subscription.plugin';
import { StripeSubscriptionIntent } from './generated/shop-graphql';
import { StripeClient } from './stripe.client';
import { StripeInvoice } from './types/stripe-invoice';
import {
  StripePaymentIntent,
  StripeSetupIntent,
} from './types/stripe-payment-intent';
import { printMoney } from './util';
import { stripeSubscriptionHandler } from './vendure-config/stripe-subscription.handler';
export interface StripeContext {
  paymentMethod: PaymentMethod;
  stripeClient: StripeClient;
}
interface CreateSubscriptionsJob {
  action: 'createSubscriptionsForOrder';
  ctx: SerializedRequestContext;
  orderCode: string;
  stripeCustomerId: string;
  stripePaymentMethodId: string;
}
interface CancelSubscriptionsJob {
  action: 'cancelSubscriptionsForOrderline';
  ctx: SerializedRequestContext;
  orderLineId: ID;
}
export type JobData = CreateSubscriptionsJob | CancelSubscriptionsJob;
@Injectable()
export class StripeSubscriptionService {
  constructor(
    private paymentMethodService: PaymentMethodService,
    private activeOrderService: ActiveOrderService,
    private entityHydrator: EntityHydrator,
    private channelService: ChannelService,
    private orderService: OrderService,
    private historyService: HistoryService,
    private eventBus: EventBus,
    private jobQueueService: JobQueueService,
    private moduleRef: ModuleRef,
    private connection: TransactionalConnection,
    productVariantService: ProductVariantService,
    @Inject(PLUGIN_INIT_OPTIONS)
    private options: StripeSubscriptionPluginOptions
  ) {
    this.subscriptionHelper = new SubscriptionHelper(
      loggerCtx,
      moduleRef,
      productVariantService,
      this.options.subscriptionStrategy!
    );
  }
  private jobQueue!: JobQueue<JobData>;
  readonly subscriptionHelper: SubscriptionHelper;
  static webhookEvents: Stripe.WebhookEndpointCreateParams.EnabledEvent[] = [
    'payment_intent.succeeded',
    'setup_intent.succeeded',
    'invoice.payment_failed',
    'invoice.payment_succeeded',
    'invoice.payment_action_required',
  ];
  async onModuleInit() {
    this.jobQueue = await this.jobQueueService.createQueue({
      name: 'stripe-subscription',
      process: async ({ data, id }) => {
        const ctx = RequestContext.deserialize(data.ctx);
        if (data.action === 'cancelSubscriptionsForOrderline') {
          this.cancelSubscriptionForOrderLine(ctx, data.orderLineId);
        } else if (data.action === 'createSubscriptionsForOrder') {
          const order = await this.orderService.findOneByCode(
            ctx,
            data.orderCode,
            []
          );
          try {
            await this.createSubscriptions(
              ctx,
              data.orderCode,
              data.stripeCustomerId,
              data.stripePaymentMethodId
            );
          } catch (error) {
            Logger.warn(
              `Failed to process job ${data.action} (${id}) for channel ${data.ctx._channel.token}: ${error}`,
              loggerCtx
            );
            if (order) {
              await this.logHistoryEntry(
                ctx,
                order.id,
                'Failed to create subscription',
                error
              );
            }
            throw error;
          }
        }
      },
    });
    this.eventBus
      .ofType(StockMovementEvent)
      .pipe(
        filter(
          (event) =>
            event.type === StockMovementType.RELEASE ||
            event.type === StockMovementType.CANCELLATION
        )
      )
      .subscribe(async (event) => {
        const cancelOrReleaseEvents = event.stockMovements as (
          | Cancellation
          | Release
        )[];
        const stockEvents = cancelOrReleaseEvents.filter(
          (event) => (event.orderLine.customFields as any).subscriptionIds
        );
        await Promise.all(
          stockEvents.map((stockEvent) =>
            this.jobQueue.add({
              ctx: event.ctx.serialize(),
              action: 'cancelSubscriptionsForOrderline',
              orderLineId: stockEvent.orderLine.id,
            })
          )
        );
      });
    this.eventBus.ofType(PaymentMethodEvent).subscribe(async (event) => {
      if (event.type === 'created' || event.type === 'updated') {
        const paymentMethod = event.entity;
        if (paymentMethod.handler?.code === stripeSubscriptionHandler.code) {
          await this.registerWebhooks(event.ctx, paymentMethod).catch((e) => {
            Logger.error(
              `Failed to register webhooks for channel ${event.ctx.channel.token}: ${e}`,
              loggerCtx
            );
          });
        }
      }
    });
  }
  async registerWebhooks(
    ctx: RequestContext,
    paymentMethod: PaymentMethod
  ): Promise<Stripe.Response<Stripe.WebhookEndpoint> | undefined> {
    const webhookDescription = `Vendure Stripe Subscription Webhook for channel ${ctx.channel.token}`;
    const apiKey = paymentMethod.handler.args.find(
      (arg) => arg.name === 'apiKey'
    )?.value;
    if (!apiKey) {
      throw new UserInputError(
        `No api key found for payment method ${paymentMethod.code}, can not register webhooks`
      );
    }
    const stripeClient = new StripeClient('not-yet-available-secret', apiKey, {
      apiVersion: null as any,
    });
    const webhookUrl = `${this.options.vendureHost}/stripe-subscriptions/webhook`;
    const webhooks = await stripeClient.webhookEndpoints.list({ limit: 100 });
    if (webhooks.data.length === 100) {
      Logger.error(
        `Your Stripe account has too many webhooks setup, ` +
          `you will need to manually create the webhook with events ${StripeSubscriptionService.webhookEvents.join(
            ', '
          )}`,
        loggerCtx
      );
      return;
    }
    const existingWebhook = webhooks.data.find(
      (w) => w.description === webhookDescription
    );
    if (existingWebhook) {
      await stripeClient.webhookEndpoints.del(existingWebhook.id);
    }
    const createdHook = await stripeClient.webhookEndpoints.create({
      enabled_events: StripeSubscriptionService.webhookEvents,
      description: webhookDescription,
      url: webhookUrl,
    });
    paymentMethod.handler.args.forEach((arg) => {
      if (arg.name === 'webhookSecret') {
        arg.value = createdHook.secret!;
      }
    });
    const res = await this.connection
      .getRepository(ctx, PaymentMethod)
      .save(paymentMethod);
    Logger.info(
      `Created webhook ${createdHook.id} for payment method '${res.code}' for channel ${ctx.channel.token}`,
      loggerCtx
    );
    return createdHook;
  }
  async cancelSubscriptionForOrderLine(
    ctx: RequestContext,
    orderLineId: ID
  ): Promise<void> {
    const order = await this.orderService.findOneByOrderLineId(
      ctx,
      orderLineId,
      ['lines']
    );
    if (!order) {
      throw Error(`Order for OrderLine ${orderLineId} not found`);
    }
    const line = order?.lines.find((l) => l.id == orderLineId) as
      | any
      | undefined;
    if (!line?.customFields.subscriptionIds?.length) {
      return Logger.info(
        `OrderLine ${orderLineId} of ${orderLineId} has no subscriptionIds. Not cancelling anything... `,
        loggerCtx
      );
    }
    await this.entityHydrator.hydrate(ctx, line, { relations: ['order'] });
    const { stripeClient } = await this.getStripeContext(ctx);
    for (const subscriptionId of line.customFields.subscriptionIds) {
      try {
        await stripeClient.subscriptions.update(subscriptionId, {
          cancel_at_period_end: true,
        });
        Logger.info(`Cancelled subscription ${subscriptionId}`);
        await this.logHistoryEntry(
          ctx,
          order!.id,
          `Cancelled subscription ${subscriptionId}`,
          undefined,
          undefined,
          subscriptionId
        );
      } catch (e: unknown) {
        Logger.error(
          `Failed to cancel subscription ${subscriptionId}`,
          loggerCtx
        );
        await this.logHistoryEntry(
          ctx,
          order.id,
          `Failed to cancel ${subscriptionId}`,
          e,
          undefined,
          subscriptionId
        );
      }
    }
  }
  async getAllSubscriptions(
    ctx: RequestContext,
    params?: Stripe.SubscriptionListParams,
    options?: Stripe.RequestOptions
  ): Promise<Stripe.ApiListPromise<Stripe.Subscription>> {
    const { stripeClient } = await this.getStripeContext(ctx);
    return stripeClient.subscriptions.list(params, options);
  }
  async getSubscription(
    ctx: RequestContext,
    subscriptionId: string
  ): Promise<Stripe.Response<Stripe.Subscription>> {
    const { stripeClient } = await this.getStripeContext(ctx);
    return stripeClient.subscriptions.retrieve(subscriptionId);
  }
  async createIntent(ctx: RequestContext): Promise<StripeSubscriptionIntent> {
    let order = await this.activeOrderService.getActiveOrder(ctx, undefined);
    if (!order) {
      throw new UserInputError('No active order for session');
    }
    return this.createIntentByOrder(ctx, order);
  }
  async createIntentForDraftOrder(
    ctx: RequestContext,
    orderId: ID
  ): Promise<StripeSubscriptionIntent> {
    let order = await this.orderService.findOne(ctx, orderId);
    if (!order) {
      throw new EntityNotFoundError('Order', orderId);
    }
    return this.createIntentByOrder(ctx, order);
  }
  async createIntentByOrder(
    ctx: RequestContext,
    order: Order
  ): Promise<StripeSubscriptionIntent> {
    await this.entityHydrator.hydrate(ctx, order, {
      relations: ['customer', 'shippingLines', 'lines.productVariant'],
      applyProductVariantPrices: true,
    });
    if (!order.lines?.length) {
      throw new UserInputError('Cannot create intent for empty order');
    }
    if (!order.customer) {
      throw new UserInputError(
        'Cannot create intent for order without customer'
      );
    }
    if (!order.shippingLines?.length) {
      throw new UserInputError(
        'Cannot create intent for order without shippingMethod'
      );
    }
    const eligibleStripeMethodCodes = (
      await this.orderService.getEligiblePaymentMethods(ctx, order.id)
    )
      .filter((m) => m.isEligible)
      .map((m) => m.code);
    const { stripeClient, paymentMethod } = await this.getStripeContext(ctx);
    if (!eligibleStripeMethodCodes.includes(paymentMethod.code)) {
      throw new UserInputError(
        `No eligible payment method found for order ${order.code} with handler code '${stripeSubscriptionHandler.code}'`
      );
    }
    await this.orderService.transitionToState(
      ctx,
      order.id,
      'ArrangingPayment'
    );
    const stripeCustomer = await stripeClient.getOrCreateCustomer(
      order.customer
    );
    const stripePaymentMethods = ['card'];
    let intent: Stripe.PaymentIntent | Stripe.SetupIntent;
    if (order.totalWithTax > 0) {
      intent = await stripeClient.paymentIntents.create({
        customer: stripeCustomer.id,
        payment_method_types: stripePaymentMethods,
        setup_future_usage: 'off_session',
        amount: order.totalWithTax,
        currency: order.currencyCode,
        metadata: {
          orderCode: order.code,
          channelToken: ctx.channel.token,
          amount: order.totalWithTax,
        },
      });
    } else {
      intent = await stripeClient.setupIntents.create({
        customer: stripeCustomer.id,
        payment_method_types: stripePaymentMethods,
        usage: 'off_session',
        metadata: {
          orderCode: order.code,
          channelToken: ctx.channel.token,
          amount: order.totalWithTax,
        },
      });
    }
    const intentType =
      intent.object === 'payment_intent' ? 'PaymentIntent' : 'SetupIntent';
    if (!intent.client_secret) {
      throw Error(
        `No client_secret found in ${intentType} response, something went wrong!`
      );
    }
    Logger.info(
      `Created ${intentType} '${intent.id}' for order ${order.code}`,
      loggerCtx
    );
    return {
      clientSecret: intent.client_secret,
      intentType,
    };
  }
  async handleInvoicePaymentFailed(
    ctx: RequestContext,
    object: StripeInvoice,
    order: Order
  ): Promise<void> {
    const amount = object.lines?.data[0]?.plan?.amount;
    const message = amount
      ? `Subscription payment of ${printMoney(amount)} failed`
      : 'Subscription payment failed';
    await this.logHistoryEntry(
      ctx,
      order.id,
      message,
      `${message} - ${object.id}`,
      undefined,
      object.subscription
    );
  }
  async handleIntentSucceeded(
    ctx: RequestContext,
    object: StripePaymentIntent | StripeSetupIntent,
    order: Order
  ): Promise<void> {
    const {
      paymentMethod: { code: paymentMethodCode },
    } = await this.getStripeContext(ctx);
    if (!object.customer) {
      await this.logHistoryEntry(
        ctx,
        order.id,
        '',
        `No customer ID found in incoming webhook. Can not create subscriptions for this order.`
      );
      throw Error(`No customer found in webhook data for order ${order.code}`);
    }
    // Create subscriptions for customer
    this.jobQueue
      .add(
        {
          action: 'createSubscriptionsForOrder',
          ctx: ctx.serialize(),
          orderCode: order.code,
          stripePaymentMethodId: object.payment_method,
          stripeCustomerId: object.customer,
        },
        { retries: 0 }
      )
      .catch((e) =>
        Logger.error(
          `Failed to add subscription-creation job to queue`,
          loggerCtx
        )
      );
    if (order.state !== 'ArrangingPayment') {
      const transitionToStateResult = await this.orderService.transitionToState(
        ctx,
        order.id,
        'ArrangingPayment'
      );
      if (transitionToStateResult instanceof OrderStateTransitionError) {
        throw Error(
          `Error transitioning order ${order.code} from ${transitionToStateResult.fromState} to ${transitionToStateResult.toState}: ${transitionToStateResult.message}`
        );
      }
    }
    const addPaymentToOrderResult = await this.orderService.addPaymentToOrder(
      ctx,
      order.id,
      {
        method: paymentMethodCode,
        metadata: {
          setupIntentId: object.id,
          amount: object.metadata.amount,
        },
      }
    );
    if ((addPaymentToOrderResult as ErrorResult).errorCode) {
      throw Error(
        `[${loggerCtx}]: Error adding payment to order ${order.code}: ${
          (addPaymentToOrderResult as ErrorResult).message
        }`
      );
    }
    Logger.info(
      `Successfully settled payment for order ${
        order.code
      } with amount ${printMoney(object.metadata.amount)}, for channel ${
        ctx.channel.token
      }`,
      loggerCtx
    );
  }
  private async createSubscriptions(
    ctx: RequestContext,
    orderCode: string,
    stripeCustomerId: string,
    stripePaymentMethodId: string
  ): Promise<void> {
    const order = await this.orderService.findOneByCode(ctx, orderCode, [
      'customer',
      'lines',
      'lines.productVariant',
    ]);
    if (!order) {
      throw Error(`[${loggerCtx}]: Cannot find order with code ${orderCode}`);
    }
    try {
      if (!(await this.subscriptionHelper.hasSubscriptions(ctx, order))) {
        Logger.info(
          `Order ${order.code} doesn't have any subscriptions. No action needed`,
          loggerCtx
        );
        return;
      }
      const { stripeClient } = await this.getStripeContext(ctx);
      const customer = await stripeClient.customers.retrieve(stripeCustomerId);
      if (!customer) {
        throw Error(
          `[${loggerCtx}]: Failed to create subscription for customer ${stripeCustomerId} because it doesn't exist in Stripe`
        );
      }
      const subscriptionDefinitions =
        await this.subscriptionHelper.getSubscriptionsForOrder(ctx, order);
      Logger.info(`Creating subscriptions for ${orderCode}`, loggerCtx);
      const subscriptionsPerOrderLine = new Map<ID, string[]>();
      for (const subscriptionDefinition of subscriptionDefinitions) {
        try {
          const product = await stripeClient.products.create({
            name: subscriptionDefinition.name,
          });
          const createdSubscription =
            await stripeClient.createOffSessionSubscription({
              customerId: stripeCustomerId,
              productId: product.id,
              currencyCode: order.currencyCode,
              amount: subscriptionDefinition.recurring.amount,
              interval: subscriptionDefinition.recurring.interval,
              intervalCount: subscriptionDefinition.recurring.intervalCount,
              paymentMethodId: stripePaymentMethodId,
              startDate: subscriptionDefinition.recurring.startDate,
              endDate: subscriptionDefinition.recurring.endDate,
              description: `'${subscriptionDefinition.name} for order '${order.code}'`,
              orderCode: order.code,
              channelToken: ctx.channel.token,
            });
          if (
            createdSubscription.status !== 'active' &&
            createdSubscription.status !== 'trialing'
          ) {
            Logger.error(
              `Failed to create active subscription ${subscriptionDefinition.name} (${createdSubscription.id}) for order ${order.code}! It is still in status '${createdSubscription.status}'`,
              loggerCtx
            );
            await this.logHistoryEntry(
              ctx,
              order.id,
              `Failed to create subscription ${subscriptionDefinition.name}`,
              `Subscription status is ${createdSubscription.status}`,
              subscriptionDefinition,
              createdSubscription.id
            );
            continue;
          }
          Logger.info(
            `Created subscription '${subscriptionDefinition.name}' (${
              createdSubscription.id
            }): ${printMoney(subscriptionDefinition.recurring.amount)}`,
            loggerCtx
          );
          await this.logHistoryEntry(
            ctx,
            order.id,
            `Created subscription for ${subscriptionDefinition.name}`,
            undefined,
            subscriptionDefinition,
            createdSubscription.id
          );
          const existingSubscriptionIds =
            subscriptionsPerOrderLine.get(subscriptionDefinition.orderLineId) ||
            [];
          existingSubscriptionIds.push(createdSubscription.id);
          subscriptionsPerOrderLine.set(
            subscriptionDefinition.orderLineId,
            existingSubscriptionIds
          );
        } catch (e: unknown) {
          await this.logHistoryEntry(
            ctx,
            order.id,
            'An unknown error occured creating subscriptions',
            e
          );
          throw e;
        }
      }
      for (const [
        orderLineId,
        subscriptionIds,
      ] of subscriptionsPerOrderLine.entries()) {
        await this.saveSubscriptionIds(ctx, orderLineId, subscriptionIds);
      }
    } catch (e: unknown) {
      await this.logHistoryEntry(ctx, order.id, '', e);
      throw e;
    }
  }
  /**
   * Save subscriptionIds on order line
   */
  async saveSubscriptionIds(
    ctx: RequestContext,
    orderLineId: ID,
    subscriptionIds: string[]
  ): Promise<void> {
    await this.connection
      .getRepository(ctx, OrderLine)
      .update({ id: orderLineId }, { customFields: { subscriptionIds } });
  }
  async createContext(
    channelToken: string,
    req: Request
  ): Promise<RequestContext> {
    const channel = await this.channelService.getChannelFromToken(channelToken);
    return new RequestContext({
      apiType: 'admin',
      isAuthorized: true,
      authorizedAsOwnerOnly: false,
      channel,
      languageCode: LanguageCode.en,
      req,
    });
  }
  async getStripeContext(ctx: RequestContext): Promise<StripeContext> {
    const paymentMethods = await this.paymentMethodService.findAll(ctx, {
      filter: { enabled: { eq: true } },
    });
    const stripePaymentMethods = paymentMethods.items.filter(
      (pm) => pm.handler.code === stripeSubscriptionHandler.code
    );
    if (stripePaymentMethods.length > 1) {
      throw new UserInputError(
        `Multiple payment methods found with handler 'stripe-subscription', there should only be 1 per channel!`
      );
    }
    const paymentMethod = stripePaymentMethods[0];
    if (!paymentMethod) {
      throw new UserInputError(
        `No enabled payment method found with handler 'stripe-subscription'`
      );
    }
    const apiKey = paymentMethod.handler.args.find(
      (arg) => arg.name === 'apiKey'
    )?.value;
    let webhookSecret = paymentMethod.handler.args.find(
      (arg) => arg.name === 'webhookSecret'
    )?.value;
    if (!apiKey) {
      Logger.warn(
        `No api key is configured for ${paymentMethod.code}`,
        loggerCtx
      );
      throw Error(
        `Payment method ${paymentMethod.code} has no api key configured`
      );
    }
    if (!webhookSecret) {
      Logger.warn(
        `No webhook secret configured for ${paymentMethod.code}`,
        loggerCtx
      );
      throw Error(
        `Payment method ${paymentMethod.code} has no webhook secret configured`
      );
    }
    return {
      paymentMethod: paymentMethod,
      stripeClient: new StripeClient(webhookSecret, apiKey, {
        apiVersion: null as any,
      }),
    };
  }
  async logHistoryEntry(
    ctx: RequestContext,
    orderId: ID,
    message: string,
    error?: unknown,
    subscription?: Subscription,
    subscriptionId?: string
  ): Promise<void> {
    let prettifiedError = error
      ? JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)))
      : undefined;
    await this.historyService.createHistoryEntryForOrder(
      {
        ctx,
        orderId,
        type: 'STRIPE_SUBSCRIPTION_NOTIFICATION' as any,
        data: {
          message,
          valid: !error,
          error: prettifiedError,
          subscriptionId,
          subscription,
        },
      },
      false
    );
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/stripe.client.ts

```typescript
import { Customer } from '@vendure/core';
import Stripe from 'stripe';
interface SubscriptionInput {
  customerId: string;
  productId: string;
  currencyCode: string;
  amount: number;
  interval: Stripe.SubscriptionCreateParams.Item.PriceData.Recurring.Interval;
  intervalCount: number;
  paymentMethodId: string;
  startDate: Date;
  orderCode: string;
  channelToken: string;
  endDate?: Date;
  description?: string;
}
export class StripeClient extends Stripe {
  constructor(
    public webhookSecret: string,
    apiKey: string,
    config: Stripe.StripeConfig
  ) {
    super(apiKey, config);
  }
  async getOrCreateCustomer(customer: Customer): Promise<Stripe.Customer> {
    const stripeCustomers = await this.customers.list({
      email: customer.emailAddress,
    });
    if (stripeCustomers.data.length > 0) {
      return stripeCustomers.data[0];
    }
    return await this.customers.create({
      email: customer.emailAddress,
      name: `${customer.firstName} ${customer.lastName}`,
    });
  }
  validateWebhookSignature(
    payload: Buffer,
    signature: string | undefined
  ): void {
    if (!signature) {
      throw Error(`Can not validate webhook signature without a signature!`);
    }
    this.webhooks.constructEvent(payload, signature, this.webhookSecret);
  }
  async createOffSessionSubscription({
    customerId,
    productId,
    currencyCode,
    amount,
    interval,
    intervalCount,
    paymentMethodId,
    startDate,
    endDate,
    description,
    orderCode,
    channelToken,
  }: SubscriptionInput): Promise<Stripe.Subscription> {
    return this.subscriptions.create({
      customer: customerId,
      cancel_at: endDate ? this.toStripeTimeStamp(endDate) : undefined,
      trial_end: this.toStripeTimeStamp(startDate),
      proration_behavior: 'none',
      description: description,
      items: [
        {
          price_data: {
            product: productId,
            currency: currencyCode,
            unit_amount: amount,
            recurring: {
              interval: interval,
              interval_count: intervalCount,
            },
          },
        },
      ],
      off_session: true,
      default_payment_method: paymentMethodId,
      payment_behavior: 'allow_incomplete',
      metadata: {
        orderCode,
        channelToken,
      },
    });
  }
  toStripeTimeStamp(date: Date): number {
    return Math.round(date.getTime() / 1000);
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/subscription-order-item-calculation.ts

```typescript
import {
  Injector,
  Order,
  OrderItemPriceCalculationStrategy,
  PriceCalculationResult,
  ProductVariant,
  RequestContext,
} from '@vendure/core';
import { DefaultOrderItemPriceCalculationStrategy } from '@vendure/core/dist/config/order/default-order-item-price-calculation-strategy';
import { CustomOrderLineFields } from '@vendure/core/dist/entity/custom-entity-fields';
import { StripeSubscriptionService } from './stripe-subscription.service';
let injector: Injector;
export class SubscriptionOrderItemCalculation
  extends DefaultOrderItemPriceCalculationStrategy
  implements OrderItemPriceCalculationStrategy
{
  init(_injector: Injector): void | Promise<void> {
    injector = _injector;
  }
  async calculateUnitPrice(
    ctx: RequestContext,
    productVariant: ProductVariant,
    orderLineCustomFields: CustomOrderLineFields,
    order: Order,
    orderLineQuantity: number
  ): Promise<PriceCalculationResult> {
    const subcriptionService = injector.get(StripeSubscriptionService);
    if (!subcriptionService) {
      throw new Error('Subscription service not initialized');
    }
    if (
      !(await subcriptionService.subscriptionHelper.isSubscription(
        ctx,
        productVariant
      ))
    ) {
      return super.calculateUnitPrice(ctx, productVariant);
    }
    const subscription =
      await subcriptionService.subscriptionHelper.defineSubscription(
        ctx,
        productVariant,
        order,
        orderLineCustomFields,
        orderLineQuantity
      );
    if (!Array.isArray(subscription)) {
      return {
        priceIncludesTax: subscription.priceIncludesTax,
        price: subscription.amountDueNow ?? 0,
      };
    }
    if (!subscription.length) {
      throw Error(
        `Subscription strategy returned an empty array. Must contain atleast 1 subscription`
      );
    }
    const total = subscription.reduce((acc, sub) => acc + sub.amountDueNow, 0);
    return {
      priceIncludesTax: subscription[0].priceIncludesTax,
      price: total,
    };
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/src/api/util.ts

```typescript
export function printMoney(amount: number): string {
  return (amount / 100).toFixed(2);
}
```

## File: packages/vendure-plugin-stripe-subscription/src/ui/history-entry.component.ts

```typescript
import { Component } from '@angular/core';
import {
  OrderDetailFragment,
  OrderHistoryEntryComponent,
  TimelineDisplayType,
  TimelineHistoryEntry,
  SharedModule,
} from '@vendure/admin-ui/core';
@Component({
  standalone: true,
  imports: [SharedModule],
  selector: 'stripe-subscription-notification-component',
  template: `
    <span>{{ entry.data.message }}</span>
    <a
      *ngIf="entry.data.subscriptionId"
      [href]="
        'https://dashboard.stripe.com/subscriptions/' +
        entry.data.subscriptionId
      "
      class="btn btn-link btn-sm details-button"
      target="_blank"
    >
      <clr-icon shape="export" size="12"></clr-icon>
    </a>
    <br />
    <vdr-history-entry-detail *ngIf="entry.data.error">
      <vdr-object-tree [value]="entry.data.error"></vdr-object-tree>
    </vdr-history-entry-detail>
    <vdr-history-entry-detail
      *ngIf="entry.data.subscription"
      title="Subscription"
    >
      <vdr-object-tree [value]="entry.data.subscription"></vdr-object-tree>
    </vdr-history-entry-detail>
  `,
})
export class HistoryEntryComponent implements OrderHistoryEntryComponent {
  entry!: TimelineHistoryEntry;
  order!: OrderDetailFragment;
  constructor() {}
  getDisplayType(entry: TimelineHistoryEntry): TimelineDisplayType {
    return entry.data.valid ? 'success' : 'error';
  }
  isFeatured(entry: TimelineHistoryEntry): boolean {
    return !entry.data.valid;
  }
  getName(entry: TimelineHistoryEntry): string {
    return 'Stripe Subscriptions';
  }
  getIconShape(entry: TimelineHistoryEntry) {
    return this.isFeatured(entry) ? 'exclamation-circle' : undefined;
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/src/ui/stripe-subscription-shared.module.ts

```typescript
import { NgModule } from '@angular/core';
import {
  addNavMenuItem,
  registerFormInputComponent,
  registerHistoryEntryComponent,
  SharedModule,
} from '@vendure/admin-ui/core';
import { HistoryEntryComponent } from './history-entry.component';
@NgModule({
  imports: [SharedModule],
  providers: [
    registerHistoryEntryComponent({
      type: 'STRIPE_SUBSCRIPTION_NOTIFICATION',
      component: HistoryEntryComponent,
    }),
  ],
})
export class StripeSubscriptionSharedModule {}
```

## File: packages/vendure-plugin-stripe-subscription/src/constants.ts

```typescript
export const loggerCtx = 'StripeSubscriptionPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('STRIPE_SUBSCRIPTION_PLUGIN_OPTIONS');
```

## File: packages/vendure-plugin-stripe-subscription/src/index.ts

```typescript
export * from '../../util/src/subscription/default-subscription-strategy';
export * from '../../util/src/subscription/subscription-strategy';
export * from '../../util/src/subscription/subscription-helper';
export * from './stripe-subscription.plugin';
export * from './api/generated/shop-graphql';
export { MutationCreateStripeSubscriptionIntentArgs } from './api/generated/admin-graphql';
export * from './api/stripe-subscription.service';
export * from './api/vendure-config/has-stripe-subscription-products-payment-checker';
export * from './api/vendure-config/stripe-subscription.handler';
export * from './types';
export * from './api/stripe.client';
```

## File: packages/vendure-plugin-stripe-subscription/src/stripe-subscription.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { rawBodyMiddleware } from '../../util/src/raw-body.middleware';
import { DefaultSubscriptionStrategy, SubscriptionStrategy } from './';
import path from 'path';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import { orderLineCustomFields } from './api/vendure-config/custom-fields';
import { stripeSubscriptionHandler } from './api/vendure-config/stripe-subscription.handler';
import { hasStripeSubscriptionProductsPaymentChecker } from './api/vendure-config/has-stripe-subscription-products-payment-checker';
import { SubscriptionOrderItemCalculation } from './api/subscription-order-item-calculation';
import { StripeSubscriptionService } from './api/stripe-subscription.service';
import { StripeSubscriptionController } from './api/stripe-subscription.controller';
import {
  StripeSubscriptionAdminApiResolver,
  StripeSubscriptionCommonResolver,
  StripeSubscriptionShopApiResolver,
} from './api/stripe-subscription.resolver';
import { shopApiSchemaExtensions } from './api/shop-graphql';
import { adminApiSchemaExtensions } from './api/admin-graphql';
export interface StripeSubscriptionPluginOptions {
  disableWebhookSignatureChecking?: boolean;
  vendureHost: string;
  subscriptionStrategy?: SubscriptionStrategy;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  shopApiExtensions: {
    schema: shopApiSchemaExtensions,
    resolvers: [
      StripeSubscriptionCommonResolver,
      StripeSubscriptionShopApiResolver,
    ],
  },
  adminApiExtensions: {
    schema: adminApiSchemaExtensions,
    resolvers: [
      StripeSubscriptionCommonResolver,
      StripeSubscriptionAdminApiResolver,
    ],
  },
  controllers: [StripeSubscriptionController],
  providers: [
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => StripeSubscriptionPlugin.options,
    },
    StripeSubscriptionService,
  ],
  configuration: (config) => {
    config.paymentOptions.paymentMethodHandlers.push(stripeSubscriptionHandler);
    config.paymentOptions.paymentMethodEligibilityCheckers = [
      ...(config.paymentOptions.paymentMethodEligibilityCheckers ?? []),
      hasStripeSubscriptionProductsPaymentChecker,
    ];
    config.customFields.OrderLine.push(...orderLineCustomFields);
    config.apiOptions.middleware.push({
      route: '/stripe-subscriptions*',
      handler: rawBodyMiddleware,
      beforeListen: true,
    });
    config.orderOptions.orderItemPriceCalculationStrategy =
      new SubscriptionOrderItemCalculation();
    return config;
  },
  compatibility: '>=2.2.0',
})
export class StripeSubscriptionPlugin {
  static options: StripeSubscriptionPluginOptions = {
    disableWebhookSignatureChecking: false,
    vendureHost: '',
    subscriptionStrategy: new DefaultSubscriptionStrategy(),
  };
  static init(options: StripeSubscriptionPluginOptions) {
    this.options = {
      ...this.options,
      ...options,
    };
    return StripeSubscriptionPlugin;
  }
  static ui: AdminUiExtension = {
    id: 'stripe-subscription-extension',
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'shared',
        ngModuleFileName: 'stripe-subscription-shared.module.ts',
        ngModuleName: 'StripeSubscriptionSharedModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-stripe-subscription/src/types.ts

```typescript
import { CustomOrderLineFields } from '@vendure/core/dist/entity/custom-entity-fields';
declare module '@vendure/core/dist/entity/custom-entity-fields' {
  interface CustomOrderLineFields {
    subscriptionIds?: string[];
    subscriptionHash?: string;
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/test/helpers/default-strategy-test-wrapper.ts

```typescript
import { RequestContext, ProductVariant } from '@vendure/core';
import { DefaultSubscriptionStrategy } from '../../src';
export class DefaultStrategyTestWrapper extends DefaultSubscriptionStrategy {
  isSubscription(ctx: RequestContext, variant: ProductVariant): boolean {
    if (variant.id === 2) {
      return false;
    } else {
      return true;
    }
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/test/helpers/downpayment-subscription-strategy.ts

```typescript
import {
  RequestContext,
  OrderLine,
  Injector,
  ProductVariant,
  Order,
} from '@vendure/core';
import { Subscription, SubscriptionStrategy } from '../../src';
export class DownPaymentSubscriptionStrategy implements SubscriptionStrategy {
  durationInMonths = 12;
  isSubscription(ctx: RequestContext, variant: ProductVariant): boolean {
    return true;
  }
  defineSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    order: Order,
    orderLineCustomFields: { [key: string]: any },
    quantity: number
  ): Subscription[] {
    return this.getSubscriptionsForVariant(
      productVariant,
      orderLineCustomFields.subscriptionDownpayment,
      this.durationInMonths
    );
  }
  previewSubscription(
    ctx: RequestContext,
    injector: Injector,
    productVariant: ProductVariant,
    customInputs: {
      subscriptionDownpayment: number;
    }
  ): Subscription[] {
    return this.getSubscriptionsForVariant(
      productVariant,
      customInputs.subscriptionDownpayment,
      this.durationInMonths
    );
  }
  private getSubscriptionsForVariant(
    productVariant: ProductVariant,
    downpayment: number,
    durationInMonths: number
  ): Subscription[] {
    const discountPerMonth = downpayment / durationInMonths;
    const subscriptions: Subscription[] = [];
    subscriptions.push({
      name: `Monthly subscription - ${productVariant.name}`,
      priceIncludesTax: productVariant.listPriceIncludesTax,
      amountDueNow: 0,
      recurring: {
        amount: productVariant.listPrice - discountPerMonth,
        interval: 'month',
        intervalCount: 1,
        startDate: new Date(),
      },
    });
    if (downpayment > 0) {
      subscriptions.push({
        name: `Downpayment subscription - ${productVariant.name}`,
        priceIncludesTax: productVariant.listPriceIncludesTax,
        amountDueNow: 0,
        recurring: {
          amount: downpayment,
          interval: 'month',
          intervalCount: durationInMonths,
          startDate: new Date(),
        },
      });
    }
    return subscriptions;
  }
}
```

## File: packages/vendure-plugin-stripe-subscription/test/helpers/graphql-helpers.ts

```typescript
import { gql } from 'graphql-tag';
import { SimpleGraphQLClient } from '@vendure/testing';
import { ChannelService, RequestContext } from '@vendure/core';
import { TestServer } from '@vendure/testing/lib/test-server';
export const ADD_ITEM_TO_ORDER = gql`
  mutation AddItemToOrder($productVariantId: ID!, $quantity: Int!) {
    addItemToOrder(productVariantId: $productVariantId, quantity: $quantity) {
      ... on Order {
        id
        code
        totalWithTax
        total
        lines {
          id
          stripeSubscriptions {
            name
            amountDueNow
            variantId
            priceIncludesTax
            recurring {
              amount
              interval
              intervalCount
              startDate
              endDate
            }
          }
        }
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const GET_ACTIVE_ORDER = gql`
  query activeOrder {
    activeOrder {
      id
      code
      totalWithTax
      total
      lines {
        id
        stripeSubscriptions {
          name
          amountDueNow
          variantId
          priceIncludesTax
          recurring {
            amount
            interval
            intervalCount
            startDate
            endDate
          }
        }
      }
    }
  }
`;
export const CREATE_PAYMENT_METHOD = gql`
  mutation CreatePaymentMethod($input: CreatePaymentMethodInput!) {
    createPaymentMethod(input: $input) {
      id
    }
  }
`;
export const GET_PAYMENT_METHODS = gql`
  query paymentMethods {
    paymentMethods {
      items {
        code
        handler {
          args {
            name
            value
            __typename
          }
        }
      }
    }
  }
`;
export const SET_SHIPPING_ADDRESS = gql`
  mutation SetShippingAddress($input: CreateAddressInput!) {
    setOrderShippingAddress(input: $input) {
      ... on Order {
        shippingAddress {
          fullName
          company
          streetLine1
          streetLine2
          city
          province
          postalCode
          country
          phoneNumber
        }
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const SET_SHIPPING_METHOD = gql`
  mutation SetShippingMethod($id: [ID!]!) {
    setOrderShippingMethod(shippingMethodId: $id) {
      ... on Order {
        id
        code
      }
      ... on ErrorResult {
        errorCode
        message
      }
    }
  }
`;
export const CREATE_SHOP_PAYMENT_LINK = gql`
  mutation createStripeSubscriptionIntent {
    createStripeSubscriptionIntent {
      clientSecret
      intentType
    }
  }
`;
export const CREATE_ADMIN_PAYMENT_LINK = gql`
  mutation createStripeSubscriptionIntent($orderId: ID!) {
    createStripeSubscriptionIntent(orderId: $orderId) {
      clientSecret
      intentType
    }
  }
`;
export const ELIGIBLE_PAYMENT_METHODS = gql`
  query eligiblePaymentMethods {
    eligiblePaymentMethods {
      id
      name
      stripeSubscriptionPublishableKey
    }
  }
`;
export const PREVIEW_SUBSCRIPTIONS = gql`
  query previewStripeSubscriptions($productVariantId: ID!) {
    previewStripeSubscriptions(productVariantId: $productVariantId) {
      name
      amountDueNow
      variantId
      priceIncludesTax
      recurring {
        amount
        interval
        intervalCount
        startDate
        endDate
      }
    }
  }
`;
export const PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT = gql`
  query previewStripeSubscriptionsForProduct($productId: ID!) {
    previewStripeSubscriptionsForProduct(productId: $productId) {
      name
      amountDueNow
      variantId
      priceIncludesTax
      recurring {
        amount
        interval
        intervalCount
        startDate
        endDate
      }
    }
  }
`;
export const CANCEL_ORDER = gql`
  mutation CancelOrder($input: CancelOrderInput!) {
    cancelOrder(input: $input) {
      __typename
    }
  }
`;
export const REFUND_ORDER = gql`
  mutation RefundOrder($input: RefundOrderInput!) {
    refundOrder(input: $input) {
      __typename
    }
  }
`;
export function getOneMonthFromNow() {
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate(), 12);
}
export async function setShipping(
  shopClient: SimpleGraphQLClient
): Promise<void> {
  await shopClient.query(SET_SHIPPING_ADDRESS, {
    input: {
      fullName: 'name',
      streetLine1: '12 the street',
      city: 'Leeuwarden',
      postalCode: '123456',
      countryCode: 'AT',
    },
  });
  await shopClient.query(SET_SHIPPING_METHOD, {
    id: [1],
  });
}
export async function getDefaultCtx(server: TestServer) {
  const channel = await server.app.get(ChannelService).getDefaultChannel();
  return new RequestContext({
    apiType: 'admin',
    isAuthorized: true,
    authorizedAsOwnerOnly: false,
    channel,
  });
}
```

## File: packages/vendure-plugin-stripe-subscription/test/helpers/stripe-test-checkout.plugin.ts

```typescript
import { PluginCommonModule, VendurePlugin } from '@vendure/core';
import { Body, Controller, Get, Headers, Res } from '@nestjs/common';
import { Response } from 'express';
import { intent } from '../dev-server';
@Controller()
export class CheckoutController {
  @Get('checkout')
  async webhook(
    @Headers('stripe-signature') signature: string | undefined,
    @Res() res: Response,
    @Body() body: any
  ): Promise<void> {
    const confirmMethod =
      intent.intentType === 'SetupIntent' ? 'confirmSetup' : 'confirmPayment';
    res.send(`
<head>
  <title>Checkout</title>
  <script src="https://js.stripe.com/v3/"></script>
</head>
<html>
<form id="payment-form">
  <div id="payment-element">
    <!-- Elements will create form elements here -->
  </div>
  <button id="submit">Submit</button>
  <div id="error-message">
    <!-- Display error message to your customers here -->
  </div>
</form>
<script>
// Set your publishable key: remember to change this to your live publishable key in production
// See your keys here: https://dashboard.stripe.com/apikeys
const stripe = Stripe('${process.env.STRIPE_PUBLISHABLE_KEY}');
const options = {
  clientSecret: '${intent.clientSecret}',
  // Fully customizable with appearance API.
  appearance: {/*...*/},
};
// Set up Stripe.js and Elements to use in checkout form, passing the client secret obtained in step 3
const elements = stripe.elements(options);
// Create and mount the Payment Element
const paymentElement = elements.create('payment');
paymentElement.mount('#payment-element');
const form = document.getElementById('payment-form');
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  // confirmMethod needs to be 'confirmPayment' or 'confirmSetup'
  const {error} = await stripe.${confirmMethod}({
    //\`Elements\` instance that was used to create the Payment Element
    elements,
    confirmParams: {
      return_url: 'http://localhost:3050/checkout?success=true',
    }
  });
  if (error) {
    // This point will only be reached if there is an immediate error when
    // confirming the payment. Show error to your customer (for example, payment
    // details incomplete)
    const messageContainer = document.querySelector('#error-message');
    messageContainer.textContent = error.message;
  } else {
    // Your customer will be redirected to your \`return_url\`. For some payment
    // methods like iDEAL, your customer will be redirected to an intermediate
    // site first to authorize the payment, then redirected to the \`return_url\`.
  }
});
</script>
</html>
    `);
  }
}
@VendurePlugin({
  imports: [PluginCommonModule],
  controllers: [CheckoutController],
})
export class StripeTestCheckoutPlugin {}
```

## File: packages/vendure-plugin-stripe-subscription/test/dev-server.ts

```typescript
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LanguageCode,
  LogLevel,
  mergeConfig,
  RequestContextService,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
} from '@vendure/testing';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import path from 'path';
import {
  StripeSubscriptionIntent,
  StripeSubscriptionPlugin,
  StripeSubscriptionService,
} from '../src/';
import {
  ADD_ITEM_TO_ORDER,
  CREATE_SHOP_PAYMENT_LINK,
  CREATE_PAYMENT_METHOD,
  setShipping,
} from './helpers/graphql-helpers';
import { StripeTestCheckoutPlugin } from './helpers/stripe-test-checkout.plugin';
export let intent: StripeSubscriptionIntent;
(async () => {
  require('dotenv').config();
  const { testConfig } = require('@vendure/testing');
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const config = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    authOptions: {
      cookieOptions: {
        secret: '123',
      },
    },
    apiOptions: {
      adminApiPlayground: {},
      shopApiPlayground: {},
    },
    plugins: [
      StripeTestCheckoutPlugin,
      StripeSubscriptionPlugin.init({
        vendureHost: process.env.VENDURE_HOST!,
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
        app: process.env.COMPILE_ADMIN
          ? compileUiExtensions({
              outputPath: path.join(__dirname, '__admin-ui'),
              extensions: [StripeSubscriptionPlugin.ui],
              devMode: true,
            })
          : undefined,
      }),
    ],
  });
  const { server, shopClient, adminClient } = createTestEnvironment(config);
  await server.init({
    initialData: {
      ...require('../../test/src/initial-data').initialData,
      shippingMethods: [{ name: 'Standard Shipping', price: 0 }],
    },
    productsCsvPath: '../test/src/products-import.csv',
  });
  await adminClient.asSuperAdmin();
  await adminClient.query(CREATE_PAYMENT_METHOD, {
    input: {
      code: 'stripe-subscription-method',
      enabled: true,
      handler: {
        code: 'stripe-subscription',
        arguments: [
          { name: 'webhookSecret', value: '' },
          { name: 'apiKey', value: process.env.STRIPE_APIKEY },
          { name: 'publishableKey', value: process.env.STRIPE_PUBLISHABLE_KEY },
        ],
      },
      translations: [
        {
          languageCode: LanguageCode.en,
          name: 'Stripe test payment',
          description: 'This is a Stripe payment method',
        },
      ],
    },
  });
  console.log(`Created paymentMethod stripe-subscription`);
  await shopClient.asUserWithCredentials('hayden.zieme12@hotmail.com', 'test');
  let { addItemToOrder: order } = await shopClient.query(ADD_ITEM_TO_ORDER, {
    productVariantId: '1',
    quantity: 1,
  });
  await setShipping(shopClient);
  console.log(`Prepared order ${order?.code}`);
  console.log(`Waiting 5 seconds for webhooks to be registered`);
  await new Promise((resolve) => setTimeout(resolve, 5000));
  const { createStripeSubscriptionIntent } = await shopClient.query(
    CREATE_SHOP_PAYMENT_LINK
  );
  intent = createStripeSubscriptionIntent;
  console.log(
    `Go to http://localhost:3050/checkout/ to test your ${intent.intentType}`
  );
})();
```

## File: packages/vendure-plugin-stripe-subscription/test/stripe-subscription.spec.ts

```typescript
import {
  DefaultLogger,
  EventBus,
  LogLevel,
  mergeConfig,
  OrderPlacedEvent,
  OrderService,
  OrderStateTransitionEvent,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import nock from 'nock';
import { afterEach, beforeAll, describe, expect, it } from 'vitest';
import { getOrder } from '../../test/src/admin-utils';
import { initialData } from '../../test/src/initial-data';
import { stripeSubscriptionHandler, StripeSubscriptionPlugin } from '../src';
import { DefaultStrategyTestWrapper } from './helpers/default-strategy-test-wrapper';
import {
  ADD_ITEM_TO_ORDER,
  CANCEL_ORDER,
  CREATE_SHOP_PAYMENT_LINK,
  CREATE_ADMIN_PAYMENT_LINK,
  CREATE_PAYMENT_METHOD,
  ELIGIBLE_PAYMENT_METHODS,
  getDefaultCtx,
  getOneMonthFromNow,
  GET_ACTIVE_ORDER,
  GET_PAYMENT_METHODS,
  PREVIEW_SUBSCRIPTIONS,
  PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT,
  REFUND_ORDER,
  setShipping,
} from './helpers/graphql-helpers';
describe('Stripe Subscription Plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        StripeSubscriptionPlugin.init({
          disableWebhookSignatureChecking: true,
          vendureHost: 'https://public-test-host.io',
          subscriptionStrategy: new DefaultStrategyTestWrapper(),
        }),
      ],
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData,
      productsCsvPath: '../test/src/products-import.csv',
    });
    serverStarted = true;
  }, 60000);
  afterEach(async () => {
    nock.cleanAll();
  });
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  let orderEvents: (OrderStateTransitionEvent | OrderPlacedEvent)[] = [];
  it('Listens for OrderPlacedEvent and OrderStateTransitionEvents', async () => {
    server.app
      .get(EventBus)
      .ofType(OrderPlacedEvent)
      .subscribe((event) => {
        orderEvents.push(event);
      });
    server.app
      .get(EventBus)
      .ofType(OrderStateTransitionEvent)
      .subscribe((event) => {
        orderEvents.push(event);
      });
  });
  const createdWebhooks: any[] = [];
  it('Creates Stripe Subscription payment method', async () => {
    nock('https://api.stripe.com')
      .get(/webhook_endpoints.*/)
      .reply(200, { data: [] });
    nock('https://api.stripe.com')
      .post(/webhook_endpoints.*/, (body) => {
        createdWebhooks.push(body);
        return true;
      })
      .reply(200, {
        secret: 'whsec_testing',
      });
    await adminClient.asSuperAdmin();
    const { createPaymentMethod } = await adminClient.query(
      CREATE_PAYMENT_METHOD,
      {
        input: {
          translations: [
            {
              languageCode: 'en',
              name: 'Stripe test payment',
              description: 'This is a Stripe payment method',
            },
          ],
          code: 'stripe-subscription-method',
          enabled: true,
          checker: {
            code: 'has-stripe-subscription-products-checker',
            arguments: [],
          },
          handler: {
            code: stripeSubscriptionHandler.code,
            arguments: [
              {
                name: 'webhookSecret',
                value: '',
              },
              { name: 'apiKey', value: 'test-api-key' },
              { name: 'publishableKey', value: 'test-publishable-key' },
            ],
          },
        },
      }
    );
    await new Promise((resolve) => setTimeout(resolve, 1000));
    expect(createPaymentMethod.id).toBe('T_1');
  });
  it('Created webhooks and saved webhook secrets', async () => {
    const { paymentMethods } = await adminClient.query(GET_PAYMENT_METHODS);
    const webhookSecret = paymentMethods.items[0].handler.args.find(
      (a: any) => a.name === 'webhookSecret'
    )?.value;
    expect(createdWebhooks.length).toBe(1);
    expect(paymentMethods.items[0].code).toBe('stripe-subscription-method');
    expect(webhookSecret).toBe('whsec_testing');
  });
  it('Previews subscription for variant', async () => {
    const {
      previewStripeSubscriptions: [subscription],
    } = await shopClient.query(PREVIEW_SUBSCRIPTIONS, {
      productVariantId: 'T_1',
    });
    expect(subscription).toEqual({
      name: 'Subscription Laptop 13 inch 8GB',
      amountDueNow: 129900,
      variantId: 'T_1',
      priceIncludesTax: false,
      recurring: {
        amount: 129900,
        interval: 'month',
        intervalCount: 1,
        startDate: getOneMonthFromNow().toISOString(),
        endDate: null,
      },
    });
  });
  it('Preview subscriptions for product', async () => {
    const { previewStripeSubscriptionsForProduct: subscriptions } =
      await shopClient.query(PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT, {
        productId: 'T_1',
      });
    const nonSubscription = subscriptions.find((s) => s.variantId === 'T_2');
    expect(nonSubscription).toBeUndefined();
    expect(subscriptions.length).toBe(3);
  });
  it('Previews subscription for variant for via admin API', async () => {
    const {
      previewStripeSubscriptions: [subscription],
    } = await adminClient.query(PREVIEW_SUBSCRIPTIONS, {
      productVariantId: 'T_1',
    });
    expect(subscription).toEqual({
      name: 'Subscription Laptop 13 inch 8GB',
      amountDueNow: 129900,
      variantId: 'T_1',
      priceIncludesTax: false,
      recurring: {
        amount: 129900,
        interval: 'month',
        intervalCount: 1,
        startDate: getOneMonthFromNow().toISOString(),
        endDate: null,
      },
    });
  });
  it('Preview subscriptions for product via admin API', async () => {
    const { previewStripeSubscriptionsForProduct: subscriptions } =
      await adminClient.query(PREVIEW_SUBSCRIPTIONS_FOR_PRODUCT, {
        productId: 'T_1',
      });
    const nonSubscription = subscriptions.find((s) => s.variantId === 'T_2');
    expect(nonSubscription).toBeUndefined();
    expect(subscriptions.length).toBe(3);
  });
  it('Previews subscription for variant for via admin API', async () => {
    const {
      previewStripeSubscriptions: [subscription],
    } = await adminClient.query(PREVIEW_SUBSCRIPTIONS, {
      productVariantId: 'T_1',
    });
    expect(subscription).toEqual({
      name: 'Subscription Laptop 13 inch 8GB',
      amountDueNow: 129900,
      variantId: 'T_1',
      priceIncludesTax: false,
      recurring: {
        amount: 129900,
        interval: 'month',
        intervalCount: 1,
        startDate: getOneMonthFromNow().toISOString(),
        endDate: null,
      },
    });
  });
  let orderCode: string | undefined;
  it('Adds a subscription to order', async () => {
    await shopClient.asUserWithCredentials(
      'hayden.zieme12@hotmail.com',
      'test'
    );
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: 'T_1',
        quantity: 1,
      }
    );
    orderCode = order.code;
    expect(order.total).toBe(129900);
    expect(order.lines[0].stripeSubscriptions.length).toBe(1);
  });
  it('Adds a non-subscription item to order', async () => {
    const { addItemToOrder: order } = await shopClient.query(
      ADD_ITEM_TO_ORDER,
      {
        productVariantId: 'T_2',
        quantity: 1,
      }
    );
    orderCode = order.code;
    expect(order.lines[0].stripeSubscriptions.length).toBe(1);
    expect(order.lines[1].stripeSubscriptions.length).toBe(0);
  });
  it('Has subscriptions on an order line', async () => {
    const { activeOrder } = await shopClient.query(GET_ACTIVE_ORDER);
    expect(activeOrder.lines[0].stripeSubscriptions[0]).toEqual({
      name: 'Subscription Laptop 13 inch 8GB',
      amountDueNow: 129900,
      variantId: 'T_1',
      priceIncludesTax: false,
      recurring: {
        amount: 129900,
        interval: 'month',
        intervalCount: 1,
        startDate: getOneMonthFromNow().toISOString(),
        endDate: null,
      },
    });
  });
  it('Sets a shipping method and customer details', async () => {
    await setShipping(shopClient);
  });
  it('Exposes publishable key via eligible payment methods', async () => {
    const { eligiblePaymentMethods } = await shopClient.query(
      ELIGIBLE_PAYMENT_METHODS
    );
    expect(eligiblePaymentMethods[0].stripeSubscriptionPublishableKey).toBe(
      'test-publishable-key'
    );
  });
  it('Created a PaymentIntent via Shop API', async () => {
    let paymentIntentInput: any = {};
    nock('https://api.stripe.com')
      .get(/customers.*/)
      .reply(200, { data: [{ id: 'customer-test-id' }] });
    nock('https://api.stripe.com')
      .post(/payment_intents.*/, (body) => {
        paymentIntentInput = body;
        return true;
      })
      .reply(200, {
        client_secret: 'mock-secret-1234',
        object: 'payment_intent',
      });
    const { createStripeSubscriptionIntent: intent } = await shopClient.query(
      CREATE_SHOP_PAYMENT_LINK
    );
    expect(intent.clientSecret).toBe('mock-secret-1234');
    expect(intent.intentType).toBe('PaymentIntent');
    expect(paymentIntentInput.setup_future_usage).toBe('off_session');
    expect(paymentIntentInput.customer).toBe('customer-test-id');
    const totalDueNow = (129900 + 139900) * 1.2 + 500;
    expect(paymentIntentInput.amount).toBe(String(totalDueNow));
  });
  it('Created a PaymentIntent via Admin API', async () => {
    const { activeOrder } = await shopClient.query(GET_ACTIVE_ORDER);
    let paymentIntentInput: any = {};
    nock('https://api.stripe.com')
      .get(/customers.*/)
      .reply(200, { data: [{ id: 'customer-test-id' }] });
    nock('https://api.stripe.com')
      .post(/payment_intents.*/, (body) => {
        paymentIntentInput = body;
        return true;
      })
      .reply(200, {
        client_secret: 'mock-secret-1234',
        object: 'payment_intent',
      });
    const { createStripeSubscriptionIntent: intent } = await adminClient.query(
      CREATE_ADMIN_PAYMENT_LINK,
      {
        orderId: activeOrder.id,
      }
    );
    expect(intent.clientSecret).toBe('mock-secret-1234');
    expect(intent.intentType).toBe('PaymentIntent');
    expect(paymentIntentInput.setup_future_usage).toBe('off_session');
    expect(paymentIntentInput.customer).toBe('customer-test-id');
    const totalDueNow = (129900 + 139900) * 1.2 + 500;
    expect(paymentIntentInput.amount).toBe(String(totalDueNow));
  });
  let createdSubscriptions: any[] = [];
  it('Settles order on incoming succeeded webhook', async () => {
    nock('https://api.stripe.com')
      .get(/customers.*/)
      .reply(200, { data: [{ id: 'customer-test-id' }] });
    nock('https://api.stripe.com')
      .post(/products.*/)
      .reply(200, {
        id: 'test-product',
      })
      .persist(true);
    nock('https://api.stripe.com')
      .post(/subscriptions.*/, (body) => {
        createdSubscriptions.push(body);
        return true;
      })
      .times(3)
      .reply(200, {
        id: 'mock-sub',
        status: 'active',
      });
    let adminOrder = await getOrder(adminClient, '1');
    await adminClient.fetch(
      'http://localhost:3050/stripe-subscriptions/webhook',
      {
        method: 'POST',
        body: JSON.stringify({
          type: 'payment_intent.succeeded',
          data: {
            object: {
              customer: 'mock',
              metadata: {
                orderCode,
                channelToken: 'e2e-default-channel',
                amount: adminOrder!.totalWithTax,
              },
            },
          },
        }),
      }
    );
    await new Promise((resolve) => setTimeout(resolve, 500));
    adminOrder = await getOrder(adminClient, '1');
    expect(adminOrder?.state).toBe('PaymentSettled');
  });
  it('Created subscriptions', async () => {
    expect(createdSubscriptions.length).toBe(1);
  });
  it('Saved subscriptionIds on order line', async () => {
    const ctx = await getDefaultCtx(server);
    const internalOrder = await server.app.get(OrderService).findOne(ctx, 1);
    const subscriptionIds: string[] = [];
    internalOrder?.lines.forEach((line) => {
      if (line.customFields.subscriptionIds) {
        subscriptionIds.push(...line.customFields.subscriptionIds);
      }
    });
    expect(subscriptionIds.length).toBe(1);
  });
  it('Should cancel subscription', async () => {
    let subscriptionRequests: any[] = [];
    nock('https://api.stripe.com')
      .post(/subscriptions*/, (body) => {
        subscriptionRequests.push(body);
        return true;
      })
      .reply(200, {});
    await adminClient.query(CANCEL_ORDER, {
      input: {
        lines: [
          {
            orderLineId: 'T_1',
            quantity: 1,
          },
        ],
        orderId: 'T_1',
        reason: 'Customer request',
        cancelShipping: false,
      },
    });
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(subscriptionRequests[0].cancel_at_period_end).toBe('true');
  });
  it('Should refund subscription', async () => {
    let refundRequests: any = [];
    nock('https://api.stripe.com')
      .post(/refunds*/, (body) => {
        refundRequests.push(body);
        return true;
      })
      .reply(200, {});
    await adminClient.query(REFUND_ORDER, {
      input: {
        lines: [
          {
            orderLineId: 'T_1',
            quantity: 1,
          },
        ],
        reason: 'Customer request',
        shipping: 0,
        adjustment: 0,
        paymentId: 'T_1',
      },
    });
    expect(refundRequests[0].amount).toBeDefined();
  });
  it(`Published all OrderEvents with a ctx.req`, () => {
    expect.hasAssertions();
    orderEvents.forEach((event) => {
      expect(event.ctx.req).toBeDefined();
    });
  });
});
```

## File: packages/vendure-plugin-stripe-subscription/vitest.config.ts

```typescript
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {},
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-plugin-variant-bulk-update/src/bulk-update-service.ts

```typescript
import {
  EventBus,
  ID,
  Logger,
  PLUGIN_INIT_OPTIONS,
  Product,
  ProductEvent,
  ProductVariant,
  ProductVariantEvent,
  ProductVariantPrice,
  ProductVariantService,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { loggerCtx } from './constants';
import type { BulkUpdateOptions } from './variant-bulk-update.plugin';
import { In } from 'typeorm';
import { UpdateProductVariantInput } from '@vendure/common/lib/generated-types';
type ProductWithCustomFields = Product & {
  customFields?: Record<string, any>;
};
type ProductEventWithCustomFields = ProductEvent & {
  product: ProductWithCustomFields;
};
@Injectable()
export class BulkUpdateService implements OnApplicationBootstrap {
  constructor(
    private eventBus: EventBus,
    private connection: TransactionalConnection,
    @Inject(PLUGIN_INIT_OPTIONS) private options: BulkUpdateOptions
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    this.eventBus.ofType(ProductEvent).subscribe(async (event) => {
      try {
        if (event.type !== 'updated' && event.type !== 'created') {
          return;
        }
        const { product, ctx } = event as ProductEventWithCustomFields;
        if (this.options.enablePriceBulkUpdate && product.customFields?.price) {
          await this.updatePriceOfVariants(
            ctx,
            product,
            product.customFields.price
          ).catch((e) => {
            Logger.error(
              `Error updating prices of variants for product '${product.id}': ${e?.message}`,
              loggerCtx
            );
          });
          await this.clearProductBulkPrice(ctx, product);
        }
        const shouldUpdateCustomFields =
          this.options.bulkUpdateCustomFields.find(
            (customFieldName) =>
              product.customFields?.[customFieldName] !== undefined
          );
        if (shouldUpdateCustomFields) {
          await this.updateCustomFieldsOfVariants(ctx, product).catch((e) => {
            Logger.error(
              `Error updating custom fields of variants for product '${product.id}': ${e?.message}`,
              loggerCtx
            );
          });
        }
      } catch (e: any) {
        Logger.error(e?.message, loggerCtx);
      }
    });
  }
  async updatePriceOfVariants(
    ctx: RequestContext,
    product: ProductWithCustomFields,
    price: number
  ): Promise<void> {
    const variants = await this.getAllVariantsForProduct(ctx, product.id);
    const variantIds = variants.map((v) => v.id);
    const res = await this.connection
      .getRepository(ctx, ProductVariantPrice)
      .createQueryBuilder('price')
      .update({
        price,
      })
      .where({
        variant: In(variantIds),
        channelId: ctx.channelId,
      })
      .execute();
    Logger.info(
      `Updated prices of ${res.affected} variants of product ${product.id} to ${product.customFields?.price}`,
      loggerCtx
    );
    await this.eventBus.publish(
      new ProductVariantEvent(ctx, variants, 'updated')
    );
  }
  private async clearProductBulkPrice(
    ctx: RequestContext,
    product: ProductWithCustomFields
  ): Promise<void> {
    await this.connection
      .getRepository(ctx, Product)
      .createQueryBuilder('product')
      .update({
        customFields: {
          price: null,
        },
      })
      .where({
        id: product.id,
      })
      .execute();
  }
  async updateCustomFieldsOfVariants(
    ctx: RequestContext,
    updatedProduct: ProductWithCustomFields
  ): Promise<void> {
    const customFields: Record<string, any> = {};
    for (const customFieldName of this.options.bulkUpdateCustomFields) {
      if (updatedProduct.customFields?.[customFieldName] !== undefined) {
        customFields[customFieldName] =
          updatedProduct.customFields[customFieldName];
      }
    }
    const variants = await this.getAllVariantsForProduct(
      ctx,
      updatedProduct.id
    );
    const variantIds = variants.map((v) => v.id);
    const res = await this.connection
      .getRepository(ctx, ProductVariant)
      .createQueryBuilder('variant')
      .update({
        customFields,
      })
      .where({
        id: In(variantIds),
      })
      .execute();
    Logger.info(
      `Updated custom fields '${this.options.bulkUpdateCustomFields.join(
        ','
      )}' of ${res.affected} variants of product ${updatedProduct.id}`,
      loggerCtx
    );
    const inputs: UpdateProductVariantInput[] = variants.map((v) => ({
      id: v.id,
      customFields,
    }));
    await this.eventBus.publish(
      new ProductVariantEvent(ctx, variants, 'updated', inputs)
    );
  }
  private getAllVariantsForProduct(
    ctx: RequestContext,
    productId: ID
  ): Promise<ProductVariant[]> {
    return this.connection
      .getRepository(ctx, ProductVariant)
      .createQueryBuilder('variant')
      .select(['variant.id'])
      .where('variant.productId = :productId', { productId })
      .getMany();
  }
}
```

## File: packages/vendure-plugin-variant-bulk-update/src/constants.ts

```typescript
export const loggerCtx = 'VariantBulkUpdatePlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-variant-bulk-update/src/variant-bulk-update.plugin.ts

```typescript
import {
  LanguageCode,
  PLUGIN_INIT_OPTIONS,
  PluginCommonModule,
  VendurePlugin,
} from '@vendure/core';
import { BulkUpdateService } from './bulk-update-service';
import { OnApplicationBootstrap } from '@nestjs/common';
export interface BulkUpdateOptions {
  enablePriceBulkUpdate: boolean;
  bulkUpdateCustomFields: string[];
}
@VendurePlugin({
  imports: [PluginCommonModule],
  providers: [
    BulkUpdateService,
    {
      provide: PLUGIN_INIT_OPTIONS,
      useFactory: () => VariantBulkUpdatePlugin.options,
    },
  ],
  configuration: (config) => {
    if (VariantBulkUpdatePlugin.options?.enablePriceBulkUpdate) {
      config.customFields.Product.push({
        name: 'price',
        type: 'int',
        public: true,
        nullable: true,
        label: [
          {
            languageCode: LanguageCode.en,
            value: 'Price',
          },
        ],
        description: [
          {
            languageCode: LanguageCode.en,
            value:
              'Setting this field will update the variant prices every time you update the product',
          },
        ],
        ui: { tab: 'Bulk update', component: 'currency-form-input' },
      });
    }
    return config;
  },
  compatibility: '>=2.2.0',
})
export class VariantBulkUpdatePlugin implements OnApplicationBootstrap {
  static options: BulkUpdateOptions;
  static init(options: BulkUpdateOptions): typeof VariantBulkUpdatePlugin {
    this.options = options;
    return VariantBulkUpdatePlugin;
  }
  onApplicationBootstrap() {
    if (!VariantBulkUpdatePlugin.options) {
      throw Error(
        'Please use VariantBulkUpdatePlugin.init({ // options }) to initialize this plugin. See the README for more information'
      );
    }
  }
}
```

## File: packages/vendure-plugin-variant-bulk-update/test/dev-server.ts

```typescript
import { initialData } from '../../test/src/initial-data';
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  DefaultLogger,
  DefaultSearchPlugin,
  LogLevel,
  mergeConfig,
} from '@vendure/core';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { VariantBulkUpdatePlugin } from '../src/variant-bulk-update.plugin';
require('dotenv').config();
(async () => {
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  const devConfig = mergeConfig(testConfig, {
    logger: new DefaultLogger({ level: LogLevel.Debug }),
    apiOptions: {
      adminApiPlayground: {},
    },
    customFields: {
      Product: [
        {
          name: 'unavailable',
          type: 'boolean',
        },
      ],
      ProductVariant: [
        {
          name: 'unavailable',
          type: 'boolean',
        },
      ],
    },
    plugins: [
      VariantBulkUpdatePlugin.init({
        enablePriceBulkUpdate: true,
        bulkUpdateCustomFields: ['unavailable'],
      }),
      DefaultSearchPlugin,
      AdminUiPlugin.init({
        port: 3002,
        route: 'admin',
      }),
    ],
  });
  const { server, adminClient, shopClient } = createTestEnvironment(devConfig);
  await server.init({
    initialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-variant-bulk-update/test/variant-bulk-update.spec.ts

```typescript
import { DefaultLogger, LogLevel, mergeConfig } from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { initialData } from '../../test/src/initial-data';
import gql from 'graphql-tag';
import { expect, describe, beforeAll, afterAll, it, vi, test } from 'vitest';
import { VariantBulkUpdatePlugin } from '../src/variant-bulk-update.plugin';
describe('Limit variants per order plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3106,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        VariantBulkUpdatePlugin.init({
          enablePriceBulkUpdate: true,
          bulkUpdateCustomFields: ['unavailable'],
        }),
      ],
      customFields: {
        Product: [
          {
            name: 'unavailable',
            type: 'boolean',
          },
        ],
        ProductVariant: [
          {
            name: 'unavailable',
            type: 'boolean',
          },
        ],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData,
      productsCsvPath: '../test/src/products-import.csv',
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
  }, 60000);
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Updates variant prices', async () => {
    await adminClient.asSuperAdmin();
    await adminClient.query(gql`
      mutation {
        updateProduct(
          input: { id: "T_1", customFields: { price: 2222, unavailable: true } }
        ) {
          ... on Product {
            id
          }
        }
      }
    `);
    await new Promise((resolve) => setTimeout(resolve, 300)); // Let the worker do its work
    const { product } = await adminClient.query(gql`
      query {
        product(id: "T_1") {
          variants {
            price
            customFields {
              unavailable
            }
          }
        }
      }
    `);
    expect(product.variants[0].price).toBe(2222);
    expect(product.variants[1].price).toBe(2222);
    expect(product.variants[0].customFields.unavailable).toBe(true);
    expect(product.variants[1].customFields.unavailable).toBe(true);
  });
  it('Updates custom fields back to false', async () => {
    await adminClient.asSuperAdmin();
    await adminClient.query(gql`
      mutation {
        updateProduct(
          input: { id: "T_1", customFields: { unavailable: false } }
        ) {
          ... on Product {
            id
          }
        }
      }
    `);
    await new Promise((resolve) => setTimeout(resolve, 300)); // Let the worker do its work
    const { product } = await adminClient.query(gql`
      query {
        product(id: "T_1") {
          variants {
            price
            customFields {
              unavailable
            }
          }
        }
      }
    `);
    expect(product.variants[0].customFields.unavailable).toBe(false);
    expect(product.variants[1].customFields.unavailable).toBe(false);
  });
  afterAll(() => {
    return server.destroy();
  });
});
```

## File: packages/vendure-plugin-webhook/src/api/api-extension.ts

```typescript
import gql from 'graphql-tag';
export const adminSchema = gql`
  input WebhookInput {
    event: String!
    url: String!
    transformerName: String
  }
  type Webhook {
    id: ID!
    event: String!
    url: String!
    requestTransformer: WebhookRequestTransformer
  }
  type WebhookRequestTransformer {
    name: String!
    supportedEvents: [String!]!
  }
  extend type Mutation {
    """
    Set all webhooks for the current channel. This will overwrite any existing webhooks.
    """
    setWebhooks(webhooks: [WebhookInput!]!): [Webhook!]!
  }
  extend type Query {
    """
    Get all webhooks for the current channel
    """
    webhooks: [Webhook!]!
    """
    Get all available Vendure events that can be used to trigger webhooks
    """
    availableWebhookEvents: [String!]!
    """
    "
    Get all available webhook request transformers
    """
    availableWebhookRequestTransformers: [WebhookRequestTransformer!]!
  }
`;
```

## File: packages/vendure-plugin-webhook/src/api/request-transformer.ts

```typescript
import {
  Injector,
  ProductEvent,
  ProductVariantEvent,
  RequestContext,
  Type,
  VendureEvent,
} from '@vendure/core';
import { Webhook } from './webhook.entity';
export type TransformFn<T extends EventWithContext> = (
  event: T,
  injector: Injector,
  webhook: Webhook
) => WebhookRequest | Promise<WebhookRequest> | false | Promise<false>;
export type EventWithContext = VendureEvent & {
  ctx: RequestContext;
};
export interface WebhookRequest {
  body?: ArrayBuffer | ArrayBufferView | string;
  headers?: Record<string, string>;
}
export class RequestTransformer<T extends Array<Type<EventWithContext>>> {
  readonly name: string;
  readonly supportedEvents: T;
  readonly transform: TransformFn<InstanceType<T[number]>>;
  constructor(
    private readonly options: {
      name: string;
      supportedEvents: T;
      transform: TransformFn<InstanceType<T[number]>>;
    }
  ) {
    this.name = options.name;
    this.supportedEvents = options.supportedEvents;
    this.transform = options.transform;
  }
}
new RequestTransformer({
  name: 'Stringify Product events',
  supportedEvents: [ProductEvent, ProductVariantEvent],
  transform: (event: ProductEvent | ProductVariantEvent, injector) => {
    return {};
  },
});
```

## File: packages/vendure-plugin-webhook/src/api/webhook.entity.ts

```typescript
import { Column, Entity } from 'typeorm';
import { DeepPartial, VendureEntity } from '@vendure/core';
@Entity()
export class Webhook extends VendureEntity {
  constructor(input?: DeepPartial<Webhook>) {
    super(input);
  }
  @Column()
  channelId!: string;
  @Column()
  url!: string;
  @Column()
  event!: string;
  @Column({ nullable: true })
  transformerName?: string;
}
```

## File: packages/vendure-plugin-webhook/src/api/webhook.resolver.ts

```typescript
import {
  Args,
  Mutation,
  Query,
  Resolver,
  ResolveField,
  Parent,
} from '@nestjs/graphql';
import {
  Allow,
  Ctx,
  PermissionDefinition,
  ProductEvent,
  RequestContext,
} from '@vendure/core';
import { WebhookService } from './webhook.service';
import {
  Webhook,
  WebhookInput,
  WebhookRequestTransformer,
} from '../generated/graphql-types';
import { Webhook as WebhookEntity } from './webhook.entity';
import { RequestTransformer } from './request-transformer';
export const webhookPermission = new PermissionDefinition({
  name: 'SetWebhook',
  description: 'Allows setting a webhook URL',
});
@Resolver()
export class WebhookResolver {
  constructor(private webhookService: WebhookService) {}
  @Mutation()
  @Allow(webhookPermission.Permission)
  async setWebhooks(
    @Ctx() ctx: RequestContext,
    @Args('webhooks') webhooks: WebhookInput[]
  ): Promise<Webhook[]> {
    return this.webhookService.saveWebhooks(ctx, webhooks);
  }
  @Query()
  @Allow(webhookPermission.Permission)
  async webhooks(@Ctx() ctx: RequestContext): Promise<Webhook[]> {
    return this.webhookService.getAllWebhooks(ctx);
  }
  @Query()
  @Allow(webhookPermission.Permission)
  async availableWebhookEvents(): Promise<string[]> {
    return this.webhookService.getAvailableEvents();
  }
  @Query()
  @Allow(webhookPermission.Permission)
  async availableWebhookRequestTransformers(): Promise<
    WebhookRequestTransformer[]
  > {
    const transformers = this.webhookService.getAvailableTransformers();
    return transformers.map(mapToGraphqlTransformer);
  }
}
@Resolver('Webhook')
export class WebhookRequestTransformerResolver {
  constructor(private webhookService: WebhookService) {}
  @ResolveField()
  async requestTransformer(
    @Ctx() ctx: RequestContext,
    @Parent() webhook: WebhookEntity
  ): Promise<WebhookRequestTransformer | undefined> {
    if (!webhook.transformerName) {
      return;
    }
    const transformers = this.webhookService.getAvailableTransformers();
    const transformer = transformers.find(
      (t) => t.name === webhook.transformerName
    );
    if (!transformer) {
      return;
    }
    return mapToGraphqlTransformer(transformer);
  }
}
export function mapToGraphqlTransformer(
  transformer: RequestTransformer<any>
): WebhookRequestTransformer {
  return {
    name: transformer.name,
    supportedEvents: transformer.supportedEvents.map(
      (event: any) => event.name
    ),
  };
}
```

## File: packages/vendure-plugin-webhook/src/api/webhook.service.ts

```typescript
import { Inject, Injectable, OnApplicationBootstrap } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  EventBus,
  ID,
  Injector,
  Logger,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { Webhook } from './webhook.entity';
import fetch from 'node-fetch';
import { loggerCtx, PLUGIN_INIT_OPTIONS } from '../constants';
import { EventWithContext, RequestTransformer } from './request-transformer';
import { WebhookPluginOptions } from '../webhook.plugin';
import { WebhookInput } from '../generated/graphql-types';
@Injectable()
export class WebhookService implements OnApplicationBootstrap {
  webhookQueue = new Map<ID, Webhook>();
  constructor(
    private eventBus: EventBus,
    private connection: TransactionalConnection,
    private moduleRef: ModuleRef,
    @Inject(PLUGIN_INIT_OPTIONS) private options: WebhookPluginOptions
  ) {}
  async onApplicationBootstrap(): Promise<void> {
    if (!this.options.events || this.options.events.length === 0) {
      throw Error(
        `Please specify VendureEvents with Webhook.init() to use this plugin.`
      );
    }
    if (this.options.disabled) {
      Logger.info(
        `Webhook plugin disabled,not listening for events`,
        loggerCtx
      );
      return;
    }
    this.options.events.forEach((configuredEvent) => {
      this.eventBus.ofType(configuredEvent).subscribe(async (event) => {
        try {
          await this.addWebhookToQueue(event);
          await new Promise((resolve) =>
            setTimeout(resolve, this.options.delay)
          );
          await this.processQueue(event);
        } catch (e: unknown) {
          Logger.error(
            `Failed to call webhook for event ${event.constructor.name} for channel ${event.ctx.channelId}: ${e}`,
            loggerCtx
          );
        }
      });
      Logger.info(`Listening for ${configuredEvent.name}`, loggerCtx);
    });
  }
  getAvailableEvents(): string[] {
    return this.options.events.map((eventType) => eventType.name);
  }
  getAvailableTransformers(): RequestTransformer<any>[] {
    return this.options.requestTransformers || [];
  }
  async getAllWebhooks(ctx: RequestContext): Promise<Webhook[]> {
    return this.connection
      .getRepository(ctx, Webhook)
      .find({ where: { channelId: String(ctx.channelId) } });
  }
  async getWebhooksForEvent<T extends EventWithContext>(
    event: T
  ): Promise<Webhook[]> {
    const eventName = event.constructor.name;
    return this.connection.getRepository(event.ctx, Webhook).find({
      where: { channelId: String(event.ctx.channelId), event: eventName },
    });
  }
  async saveWebhooks(
    ctx: RequestContext,
    inputs: WebhookInput[]
  ): Promise<Webhook[]> {
    const repository = this.connection.getRepository(ctx, Webhook);
    await repository.delete({ channelId: String(ctx.channelId) });
    const webhooks: Partial<Webhook>[] = inputs.map((input) => ({
      channelId: String(ctx.channelId),
      url: input.url,
      event: input.event,
      transformerName: input.transformerName ?? undefined,
    }));
    await repository.save(webhooks);
    return this.getAllWebhooks(ctx);
  }
  async addWebhookToQueue(event: EventWithContext): Promise<void> {
    const webhooks = await this.getWebhooksForEvent(event);
    webhooks.map((webhook) => {
      this.webhookQueue.set(webhook.id, webhook);
    });
    if (webhooks.length > 0) {
      Logger.info(
        `Added ${webhooks.length} webhooks to the webhook queue for ${event.constructor.name}`,
        loggerCtx
      );
    }
  }
  async processQueue(event: EventWithContext): Promise<void> {
    if (this.webhookQueue.size === 0) {
      return;
    }
    const webhooks: Webhook[] = [];
    this.webhookQueue.forEach((webhook) => webhooks.push(webhook));
    this.webhookQueue.clear();
    await Promise.all(
      webhooks.map(async (webhook) => {
        try {
          await this.callWebhook(webhook, event);
        } catch (e) {
          Logger.error(
            `Failed to call webhook for event ${webhook.event} channel ${webhook.channelId}: ${e}`,
            loggerCtx
          );
        }
      })
    );
  }
  async callWebhook(webhook: Webhook, event: EventWithContext): Promise<void> {
    if (!webhook.transformerName) {
      await fetch(webhook.url, { method: 'POST' });
      return Logger.info(
        `Successfully triggered webhook for event ${webhook.event} for channel ${webhook.channelId} without transformer`,
        loggerCtx
      );
    }
    const transformer = this.getAvailableTransformers().find(
      (transformer) => transformer.name === webhook.transformerName
    );
    if (!transformer) {
      throw Error(`Could not find transformer ${webhook.transformerName}`);
    }
    const request = await transformer.transform(
      event,
      new Injector(this.moduleRef),
      webhook
    );
    if (request === false) {
      Logger.info(
        `Ignoring event ${event.constructor.name} for channel ${webhook.channelId} because transformer "${webhook.transformerName}" returned false`,
        loggerCtx
      );
      return;
    }
    try {
      await fetch(webhook.url, {
        method: 'POST',
        headers: request.headers,
        body: request.body,
      });
      Logger.info(
        `Successfully triggered webhook for event ${event.constructor.name} for channel ${webhook.channelId} with transformer "${webhook.transformerName}"`,
        loggerCtx
      );
    } catch (error) {
      Logger.error(
        `Failed to call webhook for event ${webhook.event} channel ${webhook.channelId}: ${error}`,
        loggerCtx
      );
    }
  }
}
```

## File: packages/vendure-plugin-webhook/src/ui/graphql-types.ts

```typescript
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type Scalars = {
  ID: number | string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};
export type Mutation = {
  __typename?: 'Mutation';
  setWebhooks: Array<Webhook>;
};
export type MutationSetWebhooksArgs = {
  webhooks: Array<WebhookInput>;
};
export type Query = {
  __typename?: 'Query';
  availableWebhookEvents: Array<Scalars['String']>;
  availableWebhookRequestTransformers: Array<WebhookRequestTransformer>;
  webhooks: Array<Webhook>;
};
export type Webhook = {
  __typename?: 'Webhook';
  event: Scalars['String'];
  id: Scalars['ID'];
  requestTransformer?: Maybe<WebhookRequestTransformer>;
  url: Scalars['String'];
};
export type WebhookInput = {
  event: Scalars['String'];
  transformerName?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};
export type WebhookRequestTransformer = {
  __typename?: 'WebhookRequestTransformer';
  name: Scalars['String'];
  supportedEvents: Array<Scalars['String']>;
};
export type SetWebhooksMutationVariables = Exact<{
  webhooks: Array<WebhookInput> | WebhookInput;
}>;
export type SetWebhooksMutation = {
  __typename?: 'Mutation';
  setWebhooks: Array<{
    __typename?: 'Webhook';
    id: number | string;
    event: string;
    url: string;
    requestTransformer?: {
      __typename?: 'WebhookRequestTransformer';
      name: string;
      supportedEvents: Array<string>;
    } | null;
  }>;
};
export type WebhooksQueryVariables = Exact<{ [key: string]: never }>;
export type WebhooksQuery = {
  __typename?: 'Query';
  webhooks: Array<{
    __typename?: 'Webhook';
    id: number | string;
    event: string;
    url: string;
    requestTransformer?: {
      __typename?: 'WebhookRequestTransformer';
      name: string;
      supportedEvents: Array<string>;
    } | null;
  }>;
};
export type AvailableWebhookEventsQueryVariables = Exact<{
  [key: string]: never;
}>;
export type AvailableWebhookEventsQuery = {
  __typename?: 'Query';
  availableWebhookEvents: Array<string>;
};
export type AvailableWebhookRequestTransformersQueryVariables = Exact<{
  [key: string]: never;
}>;
export type AvailableWebhookRequestTransformersQuery = {
  __typename?: 'Query';
  availableWebhookRequestTransformers: Array<{
    __typename?: 'WebhookRequestTransformer';
    name: string;
    supportedEvents: Array<string>;
  }>;
};
export const SetWebhooks = gql`
  mutation setWebhooks($webhooks: [WebhookInput!]!) {
    setWebhooks(webhooks: $webhooks) {
      id
      event
      requestTransformer {
        name
        supportedEvents
      }
      url
    }
  }
`;
export const Webhooks = gql`
  query webhooks {
    webhooks {
      id
      event
      requestTransformer {
        name
        supportedEvents
      }
      url
    }
  }
`;
export const AvailableWebhookEvents = gql`
  query availableWebhookEvents {
    availableWebhookEvents
  }
`;
export const AvailableWebhookRequestTransformers = gql`
  query availableWebhookRequestTransformers {
    availableWebhookRequestTransformers {
      name
      supportedEvents
    }
  }
`;
```

## File: packages/vendure-plugin-webhook/src/ui/queries.ts

```typescript
import gql from 'graphql-tag';
export const setWebhooksMutation = gql`
  mutation setWebhooks($webhooks: [WebhookInput!]!) {
    setWebhooks(webhooks: $webhooks) {
      id
      event
      requestTransformer {
        name
        supportedEvents
      }
      url
    }
  }
`;
export const getWebhooksQuery = gql`
  query webhooks {
    webhooks {
      id
      event
      requestTransformer {
        name
        supportedEvents
      }
      url
    }
  }
`;
export const getAvailableWebhookEventsQuery = gql`
  query availableWebhookEvents {
    availableWebhookEvents
  }
`;
export const getAvailableWebhookRequestTransformersQuery = gql`
  query availableWebhookRequestTransformers {
    availableWebhookRequestTransformers {
      name
      supportedEvents
    }
  }
`;
```

## File: packages/vendure-plugin-webhook/src/ui/webhook-nav.module.ts

```typescript
import { NgModule } from '@angular/core';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
@NgModule({
  imports: [SharedModule],
  providers: [
    addNavMenuItem(
      {
        id: 'webhook',
        label: 'Webhook',
        routerLink: ['/extensions/webhook'],
        icon: 'cloud-traffic',
        requiresPermission: 'SetWebhook',
      },
      'settings'
    ),
  ],
})
export class WebhookNavModule {}
```

## File: packages/vendure-plugin-webhook/src/ui/webhook.component.ts

```typescript
import { ChangeDetectorRef, Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { DataService, NotificationService } from '@vendure/admin-ui/core';
import {
  getAvailableWebhookEventsQuery,
  getAvailableWebhookRequestTransformersQuery,
  getWebhooksQuery,
  setWebhooksMutation,
} from './queries';
import {
  Webhook,
  WebhookInput,
  WebhookRequestTransformer,
} from './graphql-types';
@Component({
  selector: 'webhook-component',
  templateUrl: './webhook.component.html',
})
export class WebhookComponent implements OnInit {
  webhooks: Webhook[] = [];
  currentPage: number = 1;
  itemsPerPage: number = 10;
  eventName: string | undefined;
  requestTransformerName: string | undefined;
  url: string | undefined;
  showMessage = false;
  availableWeebhookEvents: string[] = [];
  filteredWeebhookEvents: string[] = [];
  avaiabelWebhookRequestTransformers: WebhookRequestTransformer[] = [];
  constructor(
    private formBuilder: FormBuilder,
    protected dataService: DataService,
    private changeDetector: ChangeDetectorRef,
    private notificationService: NotificationService
  ) {}
  ngOnInit() {
    this.dataService
      .query(getAvailableWebhookEventsQuery)
      .single$.subscribe((e: any) => {
        this.filteredWeebhookEvents = this.availableWeebhookEvents =
          e.availableWebhookEvents;
      });
    this.dataService.query(getWebhooksQuery).single$.subscribe((s: any) => {
      this.webhooks = s.webhooks;
    });
    this.dataService
      .query(getAvailableWebhookRequestTransformersQuery)
      .single$.toPromise()
      .then((d: any) => {
        this.avaiabelWebhookRequestTransformers =
          d.availableWebhookRequestTransformers;
      });
  }
  setPageNumber(event: number) {
    this.currentPage = event;
  }
  setItemsPerPage(event: number) {
    this.itemsPerPage = event;
  }
  showCreateModal() {
    this.showMessage = true;
    this.eventName = '';
    this.requestTransformerName = '';
    this.url = '';
    this.changeDetector.detectChanges();
  }
  create() {
    if (
      this.url &&
      this.url !== '' &&
      this.eventName &&
      this.eventName !== ''
    ) {
      this.dataService
        .mutate(setWebhooksMutation, {
          webhooks: [
            ...this.webhooks.map((w: Webhook) => {
              return {
                event: w.event,
                transformerName: w.requestTransformer?.name,
                url: w.url,
              };
            }),
            {
              event: this.eventName,
              transformerName: this.requestTransformerName,
              url: this.url,
            },
          ],
        })
        .subscribe((s: any) => {
          this.showMessage = false;
          this.notificationService.success('Webhook created successfully');
          this.webhooks = s.setWebhooks;
          this.changeDetector.detectChanges();
        });
    } else {
      this.notificationService.error('Please enter all the required fields');
    }
  }
  deleteWeebhook(id: number) {
    this.webhooks = this.webhooks.filter((w: Webhook) => w.id != id);
    this.changeDetector.detectChanges();
    this.dataService
      .mutate(setWebhooksMutation, {
        webhooks: [
          ...this.webhooks.map((w: Webhook) => {
            return {
              event: w.event,
              transformerName: w.requestTransformer?.name,
              url: w.url,
            };
          }),
        ],
      })
      .subscribe((s: any) => {
        this.webhooks = s.setWebhooks;
        this.notificationService.success('Webhook deleted successfully');
      });
  }
  requestTransformerSelected(setRequestTransformerName?: string) {
    if (setRequestTransformerName) {
      this.filteredWeebhookEvents =
        this.avaiabelWebhookRequestTransformers.find(
          (v) => v.name === this.requestTransformerName
        )?.supportedEvents ?? [];
    } else if (this.requestTransformerName) {
      this.filteredWeebhookEvents =
        this.avaiabelWebhookRequestTransformers.find(
          (v) => v.name === this.requestTransformerName
        )?.supportedEvents ?? [];
    } else {
      this.filteredWeebhookEvents = this.availableWeebhookEvents;
    }
    this.eventName = this.filteredWeebhookEvents.find(
      (v) => v === this.eventName
    );
    this.changeDetector.detectChanges();
  }
  duplicate(requestTransformer: string, url: string) {
    this.requestTransformerName = requestTransformer;
    this.requestTransformerSelected(requestTransformer);
    this.url = url;
    this.showMessage = true;
    this.changeDetector.detectChanges();
  }
}
```

## File: packages/vendure-plugin-webhook/src/ui/webhook.module.ts

```typescript
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { addNavMenuItem, SharedModule } from '@vendure/admin-ui/core';
import { WebhookComponent } from './webhook.component';
@NgModule({
  imports: [
    SharedModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: WebhookComponent,
        data: { breadcrumb: 'Webhook' },
      },
    ]),
  ],
  providers: [
    addNavMenuItem(
      {
        id: 'webhook',
        label: 'Webhook',
        routerLink: ['/extensions/webhook'],
        icon: 'cursor-hand-open',
      },
      'settings'
    ),
  ],
  declarations: [WebhookComponent],
})
export class WebhookModule {}
```

## File: packages/vendure-plugin-webhook/src/constants.ts

```typescript
export const loggerCtx = 'WebhookPlugin';
export const PLUGIN_INIT_OPTIONS = Symbol('PLUGIN_INIT_OPTIONS');
```

## File: packages/vendure-plugin-webhook/src/index.ts

```typescript
export * from './api/request-transformer';
export * from './webhook.plugin';
```

## File: packages/vendure-plugin-webhook/src/webhook.plugin.ts

```typescript
import { PluginCommonModule, Type, VendurePlugin } from '@vendure/core';
import { AdminUiExtension } from '@vendure/ui-devkit/compiler';
import path from 'path';
import { adminSchema } from './api/api-extension';
import {
  webhookPermission,
  WebhookRequestTransformerResolver,
  WebhookResolver,
} from './api/webhook.resolver';
import { WebhookService } from './api/webhook.service';
import {
  EventWithContext,
  RequestTransformer,
} from './api/request-transformer';
import { PLUGIN_INIT_OPTIONS } from './constants';
import { Webhook } from './api/webhook.entity';
export interface WebhookPluginOptions {
  events: Type<EventWithContext>[];
  requestTransformers?: Array<RequestTransformer<Type<EventWithContext>[]>>;
  delay?: number;
  disabled?: boolean;
}
@VendurePlugin({
  imports: [PluginCommonModule],
  entities: [Webhook],
  providers: [
    WebhookService,
    { provide: PLUGIN_INIT_OPTIONS, useFactory: () => WebhookPlugin.options },
  ],
  adminApiExtensions: {
    schema: adminSchema,
    resolvers: [WebhookResolver, WebhookRequestTransformerResolver],
  },
  configuration: (config) => {
    config.authOptions.customPermissions.push(webhookPermission);
    return config;
  },
  compatibility: '>=2.2.0',
})
export class WebhookPlugin {
  static options: WebhookPluginOptions = {
    events: [],
    delay: 0,
  };
  static init(options: WebhookPluginOptions): typeof WebhookPlugin {
    this.options = {
      ...this.options,
      ...options,
    };
    return WebhookPlugin;
  }
  static ui: AdminUiExtension = {
    extensionPath: path.join(__dirname, 'ui'),
    ngModules: [
      {
        type: 'lazy',
        route: 'webhook',
        ngModuleFileName: 'webhook.module.ts',
        ngModuleName: 'WebhookModule',
      },
      {
        type: 'shared',
        ngModuleFileName: 'webhook-nav.module.ts',
        ngModuleName: 'WebhookNavModule',
      },
    ],
  };
}
```

## File: packages/vendure-plugin-webhook/test/dev-server.ts

```typescript
import {
  createTestEnvironment,
  registerInitializer,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import {
  AttemptedLoginEvent,
  DefaultLogger,
  DefaultSearchPlugin,
  InitialData,
  LogLevel,
  ProductEvent,
} from '@vendure/core';
import { initialData } from '../../test/src/initial-data';
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';
import { WebhookPlugin } from '../src';
import { compileUiExtensions } from '@vendure/ui-devkit/compiler';
import * as path from 'path';
import { stringifyProductTransformer } from './test-helpers';
(async () => {
  testConfig.logger = new DefaultLogger({ level: LogLevel.Debug });
  registerInitializer('sqljs', new SqljsInitializer('__data__'));
  testConfig.plugins.push(
    WebhookPlugin.init({
      delay: 3000,
      events: [ProductEvent, AttemptedLoginEvent],
      requestTransformers: [stringifyProductTransformer],
    })
  );
  testConfig.plugins.push(DefaultSearchPlugin);
  testConfig.plugins.push(
    AdminUiPlugin.init({
      route: 'admin',
      port: 3002,
      app: compileUiExtensions({
        outputPath: path.join(__dirname, '__admin-ui'),
        extensions: [WebhookPlugin.ui],
        devMode: true,
      }),
    })
  );
  testConfig.apiOptions.shopApiPlayground = {};
  testConfig.apiOptions.adminApiPlayground = {};
  const { server } = createTestEnvironment(testConfig);
  await server.init({
    initialData: initialData as InitialData,
    productsCsvPath: '../test/src/products-import.csv',
  });
})();
```

## File: packages/vendure-plugin-webhook/test/e2e.spec.ts

```typescript
import {
  AccountRegistrationEvent,
  ChannelService,
  DefaultLogger,
  EventBus,
  InitialData,
  LogLevel,
  mergeConfig,
  ProductEvent,
  RequestContext,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { getSuperadminContext } from '@vendure/testing/lib/utils/get-superadmin-context';
import { TestServer } from '@vendure/testing/lib/test-server';
import nock from 'nock';
import { initialData } from '../../test/src/initial-data';
import { WebhookPlugin } from '../src';
import {
  AvailableWebhookEventsQuery,
  AvailableWebhookRequestTransformersQuery,
  SetWebhooksMutation,
  SetWebhooksMutationVariables,
  WebhooksQuery,
} from '../src/generated/graphql-types';
import {
  getAvailableWebhookEventsQuery,
  getAvailableWebhookRequestTransformersQuery,
  getWebhooksQuery,
  setWebhooksMutation,
} from '../src/ui/queries';
import { stringifyProductTransformer } from './test-helpers';
import { describe, beforeAll, it, expect, afterEach, afterAll } from 'vitest';
import getFilesInAdminUiFolder from '../../test/src/compile-admin-ui.util';
describe('Webhook plugin', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let serverStarted = false;
  let ctx: RequestContext;
  const testProductWebhookUrl = 'https://rebuild-static-site.io';
  const testRegistrationUrl = 'https://my-security-logger.io';
  function publishMockProductEvent() {
    server.app
      .get(EventBus)
      .publish(new ProductEvent(ctx, undefined as any, 'created'));
  }
  function publishMockRegistrationEvent() {
    server.app
      .get(EventBus)
      .publish(new AccountRegistrationEvent(ctx, {} as any));
  }
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      apiOptions: {
        port: 3104,
      },
      logger: new DefaultLogger({ level: LogLevel.Debug }),
      plugins: [
        WebhookPlugin.init({
          delay: 200,
          events: [ProductEvent, AccountRegistrationEvent],
          requestTransformers: [stringifyProductTransformer],
        }),
      ],
    });
    ({ server, adminClient } = createTestEnvironment(config));
    await server.init({
      initialData: initialData as InitialData,
      productsCsvPath: '../test/src/products-import.csv',
    });
    serverStarted = true;
    ctx = await getSuperadminContext(server.app);
  }, 60000);
  afterEach(() => nock.cleanAll());
  it('Should start successfully', async () => {
    await expect(serverStarted).toBe(true);
  });
  it('Should set webhooks for channel', async () => {
    await adminClient.asSuperAdmin();
    const { setWebhooks } = await adminClient.query<
      SetWebhooksMutation,
      SetWebhooksMutationVariables
    >(setWebhooksMutation, {
      webhooks: [
        {
          event: 'ProductEvent',
          url: testProductWebhookUrl,
          transformerName: stringifyProductTransformer.name,
        },
        {
          event: 'AccountRegistrationEvent',
          url: testRegistrationUrl,
        },
      ],
    });
    await expect(setWebhooks[0].event).toBe('ProductEvent');
    await expect(setWebhooks[0].url).toBe(testProductWebhookUrl);
    await expect(setWebhooks[0].requestTransformer?.supportedEvents[0]).toBe(
      'ProductEvent'
    );
    await expect(setWebhooks[0].requestTransformer?.name).toBeDefined();
    await expect(setWebhooks[1].event).toBe('AccountRegistrationEvent');
    await expect(setWebhooks[1].url).toBe(testRegistrationUrl);
    await expect(setWebhooks[1].requestTransformer).toBe(null);
  });
  it('Should get all webhooks for current channel', async () => {
    const { webhooks } = await adminClient.query<WebhooksQuery>(
      getWebhooksQuery
    );
    await expect(webhooks.length).toBe(2);
    await expect(webhooks[0].event).toBe('ProductEvent');
    await expect(webhooks[0].url).toBe(testProductWebhookUrl);
    await expect(webhooks[0].requestTransformer?.supportedEvents[0]).toBe(
      'ProductEvent'
    );
    await expect(webhooks[0].requestTransformer?.name).toBeDefined();
  });
  it('Should get available events', async () => {
    const { availableWebhookEvents } =
      await adminClient.query<AvailableWebhookEventsQuery>(
        getAvailableWebhookEventsQuery
      );
    const hasRegistrationEvent = availableWebhookEvents.some(
      (event) => event === 'AccountRegistrationEvent'
    );
    const hasProductEvent = availableWebhookEvents.some(
      (event) => event === 'ProductEvent'
    );
    await expect(availableWebhookEvents.length).toBe(2);
    await expect(hasRegistrationEvent).toBe(true);
    await expect(hasProductEvent).toBe(true);
  });
  it('Should get available request tranformers', async () => {
    const { availableWebhookRequestTransformers } =
      await adminClient.query<AvailableWebhookRequestTransformersQuery>(
        getAvailableWebhookRequestTransformersQuery
      );
    expect(availableWebhookRequestTransformers.length).toBe(1);
    expect(availableWebhookRequestTransformers[0].name).toBe(
      'Stringify Product events'
    );
    expect(availableWebhookRequestTransformers[0].supportedEvents[0]).toBe(
      'ProductEvent'
    );
  });
  it('Should call webhook on ProductEvent with custom body and headers', async () => {
    const receivedPayloads: any[] = [];
    let receivedHeaders: any;
    nock(testProductWebhookUrl)
      .post(/.*/, (body) => {
        receivedPayloads.push(body);
        return true;
      })
      .reply(200, function () {
        receivedHeaders = this.req.headers;
      });
    publishMockProductEvent();
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(receivedPayloads.length).toBe(1);
    expect(receivedPayloads[0].type).toBe('created');
    expect(receivedPayloads[0].ctx).toBeDefined();
    expect(receivedHeaders['x-custom-header']).toEqual([
      'stringify-custom-header',
    ]);
  });
  it('Should call webhook on AccountRegistrationEvent with empty body', async () => {
    const receivedPayloads: any[] = [];
    nock(testRegistrationUrl)
      .post(/.*/, (body) => {
        receivedPayloads.push(body);
        return true;
      })
      .reply(200);
    publishMockRegistrationEvent();
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(receivedPayloads.length).toBe(1);
  });
  it('Should call webhook once with multiple events within 200ms', async () => {
    let received: any[] = [];
    nock(testProductWebhookUrl)
      .post(/.*/, (body) => !!received.push(body))
      .reply(200, {})
      .persist();
    publishMockProductEvent();
    publishMockProductEvent();
    publishMockProductEvent();
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(received.length).toBe(1);
  });
  it('Should call webhook twice when events are apart more than 200ms', async () => {
    let received: any[] = [];
    nock(testProductWebhookUrl)
      .persist()
      .post(/.*/, (body) => !!received.push(body))
      .reply(200, {})
      .persist();
    publishMockProductEvent();
    await new Promise((resolve) => setTimeout(resolve, 300));
    publishMockProductEvent();
    await new Promise((resolve) => setTimeout(resolve, 500));
    expect(received.length).toBe(2);
  });
  if (process.env.TEST_ADMIN_UI) {
    it('Should compile admin', async () => {
      const files = await getFilesInAdminUiFolder(__dirname, WebhookPlugin.ui);
      expect(files?.length).toBeGreaterThan(0);
    }, 200000);
  }
  afterAll(async () => {
    await server.destroy();
  }, 100000);
});
```

## File: packages/vendure-plugin-webhook/test/test-helpers.ts

```typescript
import { Logger, ProductEvent } from '@vendure/core';
import { RequestTransformer } from '../src/api/request-transformer';
import util from 'util';
export const stringifyProductTransformer = new RequestTransformer({
  name: 'Stringify Product events',
  supportedEvents: [ProductEvent],
  transform: (event, injector) => {
    if (event instanceof ProductEvent) {
      return {
        body: JSON.stringify({ type: event.type, ctx: event.ctx.serialize() }),
        headers: {
          'x-custom-header': 'stringify-custom-header',
          'content-type': 'application/json',
        },
      };
    }
    Logger.warn(
      `This transformer is only for transforming ProductEvents, but got ${event.constructor.name}. Not handling this event.`,
      'WebhookStringifyProductTransformer'
    );
    return {};
  },
});
```

## File: packages/vendure-plugin-webhook/vitest.config.ts

```typescript
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    testTimeout: 10000,
  },
  plugins: [
    swc.vite({
      jsc: {
        transform: {
          useDefineForClassFields: false,
        },
      },
    }),
  ],
});
```

## File: packages/vendure-scripts/src/assign-customers-to-channel.ts

```typescript
import {
  Customer,
  ID,
  Injector,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { IsNull } from 'typeorm';
import { assignEntitiesToChannel } from './util';
export async function assignCustomersToChannel(
  sourceChannelId: ID,
  targetChannelId: ID,
  injector: Injector,
  ctx: RequestContext,
  batch: number = 10
): Promise<void> {
  await assignEntitiesToChannel<Customer>(
    sourceChannelId,
    targetChannelId,
    injector,
    ctx,
    getCustomers,
    batch
  );
}
function getCustomers(
  ctx: RequestContext,
  sourceChanneId: ID,
  injector: Injector,
  skip: number = 0,
  take: number = 10
): Promise<Customer[]> {
  const conn = injector.get(TransactionalConnection);
  const customerRepo = conn.getRepository(ctx, Customer);
  return customerRepo
    .createQueryBuilder('customer')
    .innerJoin('customer.channels', 'channel')
    .select('customer.id')
    .setFindOptions({
      take,
      skip,
      where: {
        deletedAt: IsNull(),
        channels: {
          id: sourceChanneId,
        },
      },
    })
    .getMany();
}
```

## File: packages/vendure-scripts/src/assign-orders-to-channel.ts

```typescript
import {
  ID,
  Injector,
  Order,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import { assignEntitiesToChannel } from './util';
export async function assignOrdersToChannel(
  sourceChannelId: ID,
  targetChannelId: ID,
  injector: Injector,
  ctx: RequestContext,
  batch: number = 10
): Promise<void> {
  await assignEntitiesToChannel<Order>(
    sourceChannelId,
    targetChannelId,
    injector,
    ctx,
    getOrders,
    batch
  );
}
function getOrders(
  ctx: RequestContext,
  sourceChanneId: ID,
  injector: Injector,
  skip: number = 0,
  take: number = 10
): Promise<Order[]> {
  const conn = injector.get(TransactionalConnection);
  const orderRepo = conn.getRepository(ctx, Order);
  return orderRepo
    .createQueryBuilder('order')
    .innerJoin('order.channels', 'channel')
    .select('order.id')
    .setFindOptions({ take, skip, where: { channels: { id: sourceChanneId } } })
    .getMany();
}
```

## File: packages/vendure-scripts/src/assign-products-to-channel.ts

```typescript
import {
  AssetService,
  ChannelService,
  ID,
  Injector,
  Product,
  ProductService,
  ProductVariantService,
  RequestContext,
  SearchService,
  TransactionalConnection,
} from '@vendure/core';
import { FindOptionsWhere, IsNull } from 'typeorm';
import { getSuperadminContextInChannel } from '../../util/src/superadmin-request-context';
export async function assignAllProductsToChannel(
  sourceChannelId: ID,
  targetChannelId: ID,
  injector: Injector,
  ctx: RequestContext,
  batch: number = 10
): Promise<void> {
  await assignProductsInBatch(
    targetChannelId,
    sourceChannelId,
    injector,
    ctx,
    batch
  );
}
async function assignProductsInBatch(
  targetChannelId: ID,
  sourceChannelId: ID,
  injector: Injector,
  ctx: RequestContext,
  batch: number = 10
): Promise<void> {
  let totalCount = 0;
  let products: Product[];
  const conn = injector.get(TransactionalConnection);
  const channelService = injector.get(ChannelService);
  const targetChannel = await channelService.findOne(ctx, targetChannelId);
  const ctxInTargetChannel = await getSuperadminContextInChannel(
    injector,
    targetChannel!
  );
  const searchService = injector.get(SearchService);
  await conn.startTransaction(ctx);
  do {
    products = await getProductsWithRelations(
      ctx,
      injector,
      {
        channels: { id: sourceChannelId },
        deletedAt: IsNull(),
      },
      batch,
      totalCount
    );
    totalCount += products.length;
    await assignProductsToChannel(targetChannelId, injector, products, ctx);
  } while (products.length);
  await searchService.reindex(ctxInTargetChannel);
  await conn.commitOpenTransaction(ctx);
}
export async function assignProductsToChannel(
  targetChannelId: ID,
  injector: Injector,
  products: Product[],
  ctx: RequestContext
): Promise<void> {
  const assetService = injector.get(AssetService);
  const productAssetIds = products
    .map((product) => (product.assets ?? []).map((asset) => asset.id))
    .flat();
  const variantAssetIds = products
    .map((p) => p.variants.map((v) => (v.assets ?? []).map((a) => a.id)).flat())
    .flat();
  const assetIds = [...productAssetIds, ...variantAssetIds];
  await assetService.assignToChannel(ctx, {
    assetIds,
    channelId: targetChannelId,
  });
  const productVariantService = injector.get(ProductVariantService);
  const variantIds = products
    .map((product) => (product.variants ?? []).map((variant) => variant.id))
    .flat();
  await productVariantService.assignProductVariantsToChannel(ctx, {
    channelId: targetChannelId,
    productVariantIds: variantIds,
  });
  await injector.get(ProductService).assignProductsToChannel(ctx, {
    channelId: targetChannelId,
    productIds: products.map((product) => product.id),
  });
}
async function getProductsWithRelations(
  ctx: RequestContext,
  injector: Injector,
  condition:
    | FindOptionsWhere<Product>
    | FindOptionsWhere<Product>[]
    | undefined,
  take: number = 10,
  skip: number = 0
) {
  const conn = injector.get(TransactionalConnection);
  const productRepo = conn.getRepository(ctx, Product);
  return productRepo
    .createQueryBuilder('product')
    .select('product.id')
    .addSelect('channel.id')
    .addSelect('facet.id')
    .addSelect('asset.id')
    .addSelect('variant.id')
    .innerJoin('product.channels', 'channel')
    .innerJoin('product.variants', 'variant')
    .leftJoin('product.facetValues', 'facetValue')
    .leftJoin('facetValue.facet', 'facet')
    .leftJoin('product.assets', 'asset')
    .setFindOptions({ where: condition, take, skip })
    .getMany();
}
```

## File: packages/vendure-scripts/src/constants.ts

```typescript
export const loggerCtx = 'VendureScripts';
```

## File: packages/vendure-scripts/src/copy-database.ts

```typescript
const Confirm = require('prompt-confirm');
import { spawn } from 'child_process';
export interface DBConfig {
  username: string;
  password: string;
  host: string;
  databaseName: string;
}
export async function exportDbToFile(
  config: DBConfig,
  exportFile = `/tmp/db_export.sql`,
  requiresPrompt = true
): Promise<string> {
  if (requiresPrompt) {
    const promptCommand = new Confirm(
      `Downloading database ${config.databaseName} (${config.host}) to "${exportFile}". Proceed?`
    );
    const accept = await promptCommand.run();
    if (!accept) {
      process.exit(0);
    }
  }
  await execute(
    `mysqldump -v --set-gtid-purged=OFF --column-statistics=0 -u ${config.username} -h ${config.host} --password='${config.password}' ${config.databaseName} > ${exportFile}`
  );
  return exportFile;
}
export async function insertIntoDb(
  config: DBConfig,
  sqlFile: string,
  requiresPrompt = true
): Promise<void> {
  if (requiresPrompt) {
    const promptCommand = new Confirm(
      `Inserting "${sqlFile}" into database ${config.databaseName} (${config.host}). Proceed?`
    );
    const accept = await promptCommand.run();
    if (!accept) {
      process.exit(0);
    }
  }
  await execute(
    `mysql --verbose -u ${config.username} -h ${config.host} --password='${config.password}' ${config.databaseName} < ${sqlFile}`
  );
}
async function execute(command: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const proc = spawn(command, [], { stdio: 'inherit', shell: true });
    proc.on('error', function (error) {
      reject(new Error(error.message));
    });
    proc.on('exit', function (code) {
      if (code !== 0) {
        reject(new Error('exited with code ' + code));
      } else {
        resolve();
      }
    });
  });
}
```

## File: packages/vendure-scripts/src/index.ts

```typescript
export * from './assign-products-to-channel';
export * from './assign-customers-to-channel';
export * from './assign-orders-to-channel';
export * from './copy-database';
```

## File: packages/vendure-scripts/src/util.ts

```typescript
import {
  ChannelAware,
  ID,
  Injector,
  Logger,
  RequestContext,
  TransactionalConnection,
  VendureEntity,
} from '@vendure/core';
import { DataSource, FindOptionsWhere } from 'typeorm';
import { loggerCtx } from './constants';
export type GetEntityFunction<T> = (
  ctx: RequestContext,
  sourceChannelId: ID,
  injector: Injector,
  skip: number,
  take: number,
  condition?: FindOptionsWhere<T> | FindOptionsWhere<T>[]
) => Promise<T[]>;
export async function assignEntitiesToChannel<
  T extends VendureEntity & ChannelAware
>(
  sourceChannelId: ID,
  targetChannelId: ID,
  injector: Injector,
  ctx: RequestContext,
  getEntityFn: GetEntityFunction<T>,
  batchSize: number
): Promise<void> {
  let skip = 0;
  const conn = injector.get(TransactionalConnection);
  let items: T[];
  await conn.startTransaction(ctx);
  do {
    items = await getEntityFn(ctx, sourceChannelId, injector, skip, batchSize);
    if (items.length) {
      const entity = items[0].constructor;
      Logger.info(
        `Asigning ${entity.name}s ${skip}-${skip + batchSize} to Channel`,
        loggerCtx
      );
      await injector
        .get(DataSource)
        .getRepository(entity)
        .createQueryBuilder()
        .relation('channels')
        .of(items)
        .add(targetChannelId)
        .catch((e) => {
          Logger.error(
            `Error assigning ${entity.name}s ${skip}-${
              skip + batchSize
              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            } to Channel: ${e.message}`,
            loggerCtx
          );
        });
      skip += batchSize;
    }
  } while (items.length);
  await conn.commitOpenTransaction(ctx);
}
```

## File: packages/vendure-scripts/test/e2e.spec.ts

```typescript
import { ModuleRef } from '@nestjs/core';
import {
  ChannelService,
  CustomerService,
  Injector,
  mergeConfig,
  OrderService,
  ProductService,
  RequestContext,
} from '@vendure/core';
import {
  createTestEnvironment,
  registerInitializer,
  SimpleGraphQLClient,
  SqljsInitializer,
  testConfig,
} from '@vendure/testing';
import { TestServer } from '@vendure/testing/lib/test-server';
import { beforeAll, describe, expect, it } from 'vitest';
import { initialData } from '../../test/src/initial-data';
import { createSettledOrder } from '../../test/src/shop-utils';
import { testPaymentMethod } from '../../test/src/test-payment-method';
import { getSuperadminContextInChannel } from '../../util/src/superadmin-request-context';
import { assignAllProductsToChannel } from '../src';
import { assignCustomersToChannel } from '../src/assign-customers-to-channel';
import { assignOrdersToChannel } from '../src/assign-orders-to-channel';
import { CREATE_CHANNEL, createChannelInput } from './test-helpers';
describe('Vendure Scripts', function () {
  let server: TestServer;
  let adminClient: SimpleGraphQLClient;
  let shopClient: SimpleGraphQLClient;
  let serverStarted = false;
  let defaultChannelId = 1;
  let newChannelId = 2;
  let injector: Injector;
  let sourceChannelCtx: RequestContext;
  let targetChannelCtx: RequestContext;
  beforeAll(async () => {
    registerInitializer('sqljs', new SqljsInitializer('__data__'));
    const config = mergeConfig(testConfig, {
      logger: console,
      apiOptions: {
        port: 1234,
      },
      paymentOptions: {
        paymentMethodHandlers: [testPaymentMethod],
      },
    });
    ({ server, adminClient, shopClient } = createTestEnvironment(config));
    await server.init({
      initialData: {
        ...initialData,
        paymentMethods: [
          {
            name: testPaymentMethod.code,
            handler: { code: testPaymentMethod.code, arguments: [] },
          },
        ],
      },
      productsCsvPath: '../test/src/products-import.csv',
      customerCount: 5,
    });
    serverStarted = true;
    await adminClient.asSuperAdmin();
    await adminClient.query(CREATE_CHANNEL, {
      input: {
        ...createChannelInput,
        sellerId: 'T_1',
      },
    });
    injector = new Injector(server.app.get(ModuleRef));
    const channelService = server.app.get(ChannelService);
    const sourceChannel = await channelService.findOne(
      sourceChannelCtx,
      defaultChannelId
    );
    sourceChannelCtx = await getSuperadminContextInChannel(
      injector,
      sourceChannel!
    );
    const targetChannel = await channelService.findOne(
      sourceChannelCtx,
      newChannelId
    );
    targetChannelCtx = await getSuperadminContextInChannel(
      injector,
      targetChannel!
    );
  }, 60000);
  it('Should start successfully', async () => {
    expect(serverStarted).toBe(true);
  });
  it('Should assign all products from source to target channel', async () => {
    await assignAllProductsToChannel(
      defaultChannelId,
      newChannelId,
      injector,
      sourceChannelCtx
    );
    const targetChannelProducts = (
      await server.app
        .get(ProductService)
        .findAll(targetChannelCtx, undefined, [
          'featuredAsset',
          'assets',
          'channels',
          'facetValues',
          'facetValues.facet',
          'variants',
        ])
    ).items;
    expect(targetChannelProducts[0].id).toBe(1);
    expect(targetChannelProducts[0].variants[0].id).toBe(1);
    expect(targetChannelProducts[0].variants[1].id).toBe(2);
    expect(targetChannelProducts[0].variants[2].id).toBe(3);
    expect(targetChannelProducts[0].variants[3].id).toBe(4);
    expect(targetChannelProducts[0].facetValues[0].id).toBe(1);
    expect(targetChannelProducts[0].facetValues[0].facetId).toBe(1);
    expect(targetChannelProducts[0].facetValues[1].id).toBe(2);
    expect(targetChannelProducts[0].facetValues[1].facetId).toBe(2);
  });
  it('Should assign all customers from source  to target channel', async () => {
    await assignCustomersToChannel(
      defaultChannelId,
      newChannelId,
      injector,
      sourceChannelCtx
    );
    const customersInTargetChannel = (
      await server.app.get(CustomerService).findAll(targetChannelCtx, undefined)
    ).items;
    const customersInSourceChannel = (
      await server.app.get(CustomerService).findAll(sourceChannelCtx, undefined)
    ).items;
    expect(customersInTargetChannel.length).toBe(5);
    for (let sourceChannelCustomer of customersInSourceChannel) {
      expect(
        customersInTargetChannel.find(
          (targetChannelCustomer) =>
            targetChannelCustomer.id === sourceChannelCustomer.id
        )
      ).toBeDefined();
    }
  });
  it('Should assign all Orders from source to target Channel', async () => {
    await createSettledOrder(shopClient, 1);
    await createSettledOrder(shopClient, 1);
    await assignOrdersToChannel(
      defaultChannelId,
      newChannelId,
      injector,
      sourceChannelCtx
    );
    const ordersInTargetChannel = (
      await server.app.get(OrderService).findAll(targetChannelCtx, undefined)
    ).items;
    const ordersInSourceChannel = (
      await server.app.get(OrderService).findAll(sourceChannelCtx, undefined)
    ).items;
    expect(ordersInSourceChannel.length).toBe(2);
    expect(ordersInTargetChannel.length).toBe(2);
  });
});
```

## File: packages/vendure-scripts/test/test-helpers.ts

```typescript
import { CurrencyCode, LanguageCode } from '@vendure/core';
import { CreateChannelInput } from '@vendure/common/lib/generated-types';
import { gql } from 'graphql-tag';
export const createChannelInput: CreateChannelInput = {
  code: 'test-1',
  defaultLanguageCode: LanguageCode.en,
  defaultShippingZoneId: 1,
  defaultTaxZoneId: 1,
  pricesIncludeTax: true,
  token: 'test-1-token',
  defaultCurrencyCode: CurrencyCode.USD,
};
export const CREATE_CHANNEL = gql`
  mutation CreateChannelQuery($input: CreateChannelInput!) {
    createChannel(input: $input) {
      ... on Channel {
        code
        id
      }
    }
  }
`;
export const getAllProductsInChannel = gql`
  query GetAllProductsInChannel {
    products {
      items {
        id
      }
    }
  }
`;
```

## File: check-vendure-hub-plugins.ts

```typescript
import { SimpleGraphQLClient, testConfig } from '@vendure/testing';
import { readdir, readFile } from 'fs/promises';
import gql from 'graphql-tag';
import path from 'path';
const hubUrl = 'https://hub.vendure.io/shop-api/';
testConfig.apiOptions.channelTokenKey = undefined;
const client = new SimpleGraphQLClient(testConfig, hubUrl);
(async () => {
  const localPackageNames = await getLocalPackageNames();
  const plugins = await getPinelabPluginsInHub();
  const pluginsToBeCreated = localPackageNames.filter(
    (localName) =>
      !plugins.some((plugin) => plugin.customFields.packageName === localName)
  );
  const pluginsToBeDeleted = plugins
    .filter(
      (plugin) => !localPackageNames.includes(plugin.customFields.packageName)
    )
    .map((plugin) => plugin.customFields.packageName);
  console.log(
    '\x1b[32mPlugins to be created on Hub: \n ',
    pluginsToBeCreated.join('\n  ')
  );
  console.log(
    '\x1b[31mPlugins to be deleted from Hub: \n ',
    pluginsToBeDeleted.join('\n  ')
  );
})();
async function getPinelabPluginsInHub(): Promise<Plugin[]> {
  const result = await client.query(gql`
    {
      products(
        options: {
          take: 100
          filter: { repositoryUrl: { contains: "pinelab" } }
        }
      ) {
        totalItems
        items {
          id
          name
          customFields {
            packageName
            repositoryUrl
          }
        }
      }
    }
  `);
  return result.products.items;
}
```
