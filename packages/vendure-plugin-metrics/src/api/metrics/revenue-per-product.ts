import {
  Injector,
  Logger,
  OrderLine,
  ProductVariant,
  RequestContext,
  TransactionalConnection,
} from '@vendure/core';
import {
  AdvancedMetricSummaryInput,
  AdvancedMetricType,
} from '../../ui/generated/graphql';
import { MetricStrategy, NamedDatapoint } from '../metric-strategy';

const loggerCtx = 'SalesPerProductMetric';

/**
 * Calculates the revenue generated by each product variant.
 * calculates the total revenue if no variants are provided.
 */
export class RevenuePerProduct implements MetricStrategy<OrderLine> {
  readonly metricType: AdvancedMetricType = AdvancedMetricType.Currency;
  readonly code = 'revenue-per-product';

  getTitle(ctx: RequestContext): string {
    return `Revenue`;
  }

  getSortableField(entity: OrderLine): Date {
    return entity.order.orderPlacedAt ?? entity.order.updatedAt;
  }

  async loadEntities(
    ctx: RequestContext,
    injector: Injector,
    from: Date,
    to: Date,
    variants: ProductVariant[]
  ): Promise<OrderLine[]> {
    let skip = 0;
    const take = 1000;
    let hasMoreOrderLines = true;
    const lines: OrderLine[] = [];
    while (hasMoreOrderLines) {
      let query = injector
        .get(TransactionalConnection)
        .getRepository(ctx, OrderLine)
        .createQueryBuilder('orderLine')
        .leftJoin('orderLine.productVariant', 'productVariant')
        .addSelect(['productVariant.sku', 'productVariant.id'])
        .leftJoinAndSelect('orderLine.order', 'order')
        .leftJoin('order.channels', 'channel')
        .where(`channel.id=:channelId`, { channelId: ctx.channelId })
        .andWhere(`order.orderPlacedAt >= :from`, {
          from: from.toISOString(),
        })
        .andWhere(`order.orderPlacedAt <= :to`, {
          to: to.toISOString(),
        })
        .offset(skip)
        .limit(take);
      if (variants.length) {
        query = query.andWhere(`productVariant.id IN(:...variantIds)`, {
          variantIds: variants.map((v) => v.id),
        });
      }
      const [items, totalItems] = await query.getManyAndCount();
      lines.push(...items);
      Logger.info(
        `Fetched orderLines ${skip}-${skip + take} for channel ${
          ctx.channel.token
        }`,
        loggerCtx
      );
      skip += items.length;
      if (lines.length >= totalItems) {
        hasMoreOrderLines = false;
      }
    }
    return lines;
  }

  calculateDataPoints(
    ctx: RequestContext,
    lines: OrderLine[],
    variants: ProductVariant[]
  ): NamedDatapoint[] {
    if (!variants.length) {
      // Return total revenue
      let legendLabel = 'Total Revenue';
      if (ctx.channel.pricesIncludeTax) {
        legendLabel += ' (incl. tax)';
      } else {
        legendLabel += ' (excl. tax)';
      }
      const revenuePerOrder: { [orderId: string]: number } = {};
      const totalFieldName = ctx.channel.pricesIncludeTax
        ? 'totalWithTax'
        : 'total';
      lines.forEach((line) => {
        revenuePerOrder[line.order.id] = line.order[totalFieldName];
      });
      const totalRevenue = Object.values(revenuePerOrder).reduce(
        (total, current) => total + current,
        0
      );
      return [
        {
          legendLabel,
          value: totalRevenue / 100,
        },
      ];
    }
    // Else calculate revenue per variant
    const dataPoints: NamedDatapoint[] = [];
    const totalFieldName = ctx.channel.pricesIncludeTax
      ? 'proratedLinePriceWithTax'
      : 'proratedLinePrice';
    variants.forEach((variant) => {
      // Find order lines per variant id
      const linesForVariant = lines.filter(
        (line) => line.productVariant.id === variant.id
      );
      // Sum of order lines with this variant

      const revenue = linesForVariant.reduce(
        (total, current) => total + current[totalFieldName],
        0
      );
      dataPoints.push({
        legendLabel: variant.name,
        value: revenue / 100,
      });
    });
    return dataPoints;
  }
}
